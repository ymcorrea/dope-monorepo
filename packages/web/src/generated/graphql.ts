import { useQuery, useInfiniteQuery, UseQueryOptions, UseInfiniteQueryOptions, InfiniteData } from '@tanstack/react-query';
import { useFetchData } from 'hooks/fetcher';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  Address: { input: any; output: any; }
  BigInt: { input: any; output: any; }
  Bytes: { input: any; output: any; }
  Bytes32: { input: any; output: any; }
  Cursor: { input: any; output: any; }
  Long: { input: any; output: any; }
  Sex: { input: any; output: any; }
  Time: { input: any; output: any; }
  Timestamp: { input: any; output: any; }
};

export type BodyPart = Node & {
  __typename?: 'BodyPart';
  hustlerBeards?: Maybe<Array<Hustler>>;
  hustlerBodies?: Maybe<Array<Hustler>>;
  hustlerHairs?: Maybe<Array<Hustler>>;
  id: Scalars['ID']['output'];
  rle: Scalars['String']['output'];
  sex: BodyPartBodyPartSex;
  sprite?: Maybe<Scalars['String']['output']>;
  type: BodyPartBodyPartType;
};

/** BodyPartBodyPartSex is enum for the field sex */
export enum BodyPartBodyPartSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

/** BodyPartBodyPartType is enum for the field type */
export enum BodyPartBodyPartType {
  Beard = 'BEARD',
  Body = 'BODY',
  Hair = 'HAIR'
}

/** A connection to a list of items. */
export type BodyPartConnection = {
  __typename?: 'BodyPartConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BodyPartEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type BodyPartEdge = {
  __typename?: 'BodyPartEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<BodyPart>;
};

/**
 * BodyPartWhereInput is used for filtering BodyPart objects.
 * Input was generated by ent.
 */
export type BodyPartWhereInput = {
  and?: InputMaybe<Array<BodyPartWhereInput>>;
  /** hustler_beards edge predicates */
  hasHustlerBeards?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerBeardsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_bodies edge predicates */
  hasHustlerBodies?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerBodiesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_hairs edge predicates */
  hasHustlerHairs?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerHairsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<BodyPartWhereInput>;
  or?: InputMaybe<Array<BodyPartWhereInput>>;
  /** rle field predicates */
  rle?: InputMaybe<Scalars['String']['input']>;
  rleContains?: InputMaybe<Scalars['String']['input']>;
  rleContainsFold?: InputMaybe<Scalars['String']['input']>;
  rleEqualFold?: InputMaybe<Scalars['String']['input']>;
  rleGT?: InputMaybe<Scalars['String']['input']>;
  rleGTE?: InputMaybe<Scalars['String']['input']>;
  rleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  rleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  rleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  rleLT?: InputMaybe<Scalars['String']['input']>;
  rleLTE?: InputMaybe<Scalars['String']['input']>;
  rleNEQ?: InputMaybe<Scalars['String']['input']>;
  rleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** sex field predicates */
  sex?: InputMaybe<BodyPartBodyPartSex>;
  sexIn?: InputMaybe<Array<BodyPartBodyPartSex>>;
  sexNEQ?: InputMaybe<BodyPartBodyPartSex>;
  sexNotIn?: InputMaybe<Array<BodyPartBodyPartSex>>;
  /** sprite field predicates */
  sprite?: InputMaybe<Scalars['String']['input']>;
  spriteContains?: InputMaybe<Scalars['String']['input']>;
  spriteContainsFold?: InputMaybe<Scalars['String']['input']>;
  spriteEqualFold?: InputMaybe<Scalars['String']['input']>;
  spriteGT?: InputMaybe<Scalars['String']['input']>;
  spriteGTE?: InputMaybe<Scalars['String']['input']>;
  spriteHasPrefix?: InputMaybe<Scalars['String']['input']>;
  spriteHasSuffix?: InputMaybe<Scalars['String']['input']>;
  spriteIn?: InputMaybe<Array<Scalars['String']['input']>>;
  spriteIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  spriteLT?: InputMaybe<Scalars['String']['input']>;
  spriteLTE?: InputMaybe<Scalars['String']['input']>;
  spriteNEQ?: InputMaybe<Scalars['String']['input']>;
  spriteNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  spriteNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<BodyPartBodyPartType>;
  typeIn?: InputMaybe<Array<BodyPartBodyPartType>>;
  typeNEQ?: InputMaybe<BodyPartBodyPartType>;
  typeNotIn?: InputMaybe<Array<BodyPartBodyPartType>>;
};

export type Dope = Node & {
  __typename?: 'Dope';
  bestAskPriceEth?: Maybe<Scalars['Float']['output']>;
  claimed: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  index?: Maybe<Search>;
  items?: Maybe<Array<Item>>;
  lastCheckedGearClaim?: Maybe<Scalars['Time']['output']>;
  lastCheckedPaperClaim?: Maybe<Scalars['Time']['output']>;
  opened: Scalars['Boolean']['output'];
  order: Scalars['Int']['output'];
  rank?: Maybe<Scalars['Int']['output']>;
  score?: Maybe<Scalars['Int']['output']>;
  wallet?: Maybe<Wallet>;
};

/** A connection to a list of items. */
export type DopeConnection = {
  __typename?: 'DopeConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DopeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type DopeEdge = {
  __typename?: 'DopeEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Dope>;
};

/** Ordering options for Dope connections */
export type DopeOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Dopes. */
  field: DopeOrderField;
};

/** Properties by which Dope connections can be ordered. */
export enum DopeOrderField {
  BestAskPrice = 'BEST_ASK_PRICE',
  Id = 'ID',
  Rank = 'RANK'
}

/**
 * DopeWhereInput is used for filtering Dope objects.
 * Input was generated by ent.
 */
export type DopeWhereInput = {
  and?: InputMaybe<Array<DopeWhereInput>>;
  /** best_ask_price_eth field predicates */
  bestAskPriceEth?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthGT?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthGTE?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestAskPriceEthIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestAskPriceEthLT?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthLTE?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthNEQ?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestAskPriceEthNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** claimed field predicates */
  claimed?: InputMaybe<Scalars['Boolean']['input']>;
  claimedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** index edge predicates */
  hasIndex?: InputMaybe<Scalars['Boolean']['input']>;
  hasIndexWith?: InputMaybe<Array<SearchWhereInput>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemsWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']['input']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_checked_gear_claim field predicates */
  lastCheckedGearClaim?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedGearClaimGT?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedGearClaimGTE?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedGearClaimIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastCheckedGearClaimIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastCheckedGearClaimLT?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedGearClaimLTE?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedGearClaimNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedGearClaimNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastCheckedGearClaimNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** last_checked_paper_claim field predicates */
  lastCheckedPaperClaim?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedPaperClaimGT?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedPaperClaimGTE?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedPaperClaimIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastCheckedPaperClaimIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastCheckedPaperClaimLT?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedPaperClaimLTE?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedPaperClaimNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastCheckedPaperClaimNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastCheckedPaperClaimNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<DopeWhereInput>;
  /** opened field predicates */
  opened?: InputMaybe<Scalars['Boolean']['input']>;
  openedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<DopeWhereInput>>;
  /** order field predicates */
  order?: InputMaybe<Scalars['Int']['input']>;
  orderGT?: InputMaybe<Scalars['Int']['input']>;
  orderGTE?: InputMaybe<Scalars['Int']['input']>;
  orderIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  orderLT?: InputMaybe<Scalars['Int']['input']>;
  orderLTE?: InputMaybe<Scalars['Int']['input']>;
  orderNEQ?: InputMaybe<Scalars['Int']['input']>;
  orderNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** rank field predicates */
  rank?: InputMaybe<Scalars['Int']['input']>;
  rankGT?: InputMaybe<Scalars['Int']['input']>;
  rankGTE?: InputMaybe<Scalars['Int']['input']>;
  rankIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  rankIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  rankLT?: InputMaybe<Scalars['Int']['input']>;
  rankLTE?: InputMaybe<Scalars['Int']['input']>;
  rankNEQ?: InputMaybe<Scalars['Int']['input']>;
  rankNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  rankNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** score field predicates */
  score?: InputMaybe<Scalars['Int']['input']>;
  scoreGT?: InputMaybe<Scalars['Int']['input']>;
  scoreGTE?: InputMaybe<Scalars['Int']['input']>;
  scoreIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  scoreIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  scoreLT?: InputMaybe<Scalars['Int']['input']>;
  scoreLTE?: InputMaybe<Scalars['Int']['input']>;
  scoreNEQ?: InputMaybe<Scalars['Int']['input']>;
  scoreNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  scoreNotNil?: InputMaybe<Scalars['Boolean']['input']>;
};

export type Event = Node & {
  __typename?: 'Event';
  address: Scalars['Address']['output'];
  createdAt: Scalars['Time']['output'];
  hash: Hash;
  id: Scalars['ID']['output'];
  index: Scalars['Long']['output'];
  updatedAt: Scalars['Time']['output'];
};

/**
 * EventWhereInput is used for filtering Event objects.
 * Input was generated by ent.
 */
export type EventWhereInput = {
  and?: InputMaybe<Array<EventWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** index field predicates */
  index?: InputMaybe<Scalars['Long']['input']>;
  indexGT?: InputMaybe<Scalars['Long']['input']>;
  indexGTE?: InputMaybe<Scalars['Long']['input']>;
  indexIn?: InputMaybe<Array<Scalars['Long']['input']>>;
  indexLT?: InputMaybe<Scalars['Long']['input']>;
  indexLTE?: InputMaybe<Scalars['Long']['input']>;
  indexNEQ?: InputMaybe<Scalars['Long']['input']>;
  indexNotIn?: InputMaybe<Array<Scalars['Long']['input']>>;
  not?: InputMaybe<EventWhereInput>;
  or?: InputMaybe<Array<EventWhereInput>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']['input']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
};

export type GameHustler = Node & {
  __typename?: 'GameHustler';
  createdAt: Scalars['Time']['output'];
  id: Scalars['ID']['output'];
  items?: Maybe<Array<GameHustlerItem>>;
  lastPosition: Position;
  quests?: Maybe<Array<GameHustlerQuest>>;
  relations?: Maybe<Array<GameHustlerRelation>>;
};

export type GameHustlerItem = Node & {
  __typename?: 'GameHustlerItem';
  hustler?: Maybe<GameHustler>;
  id: Scalars['ID']['output'];
  item: Scalars['String']['output'];
};

/**
 * GameHustlerItemWhereInput is used for filtering GameHustlerItem objects.
 * Input was generated by ent.
 */
export type GameHustlerItemWhereInput = {
  and?: InputMaybe<Array<GameHustlerItemWhereInput>>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerWith?: InputMaybe<Array<GameHustlerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** item field predicates */
  item?: InputMaybe<Scalars['String']['input']>;
  itemContains?: InputMaybe<Scalars['String']['input']>;
  itemContainsFold?: InputMaybe<Scalars['String']['input']>;
  itemEqualFold?: InputMaybe<Scalars['String']['input']>;
  itemGT?: InputMaybe<Scalars['String']['input']>;
  itemGTE?: InputMaybe<Scalars['String']['input']>;
  itemHasPrefix?: InputMaybe<Scalars['String']['input']>;
  itemHasSuffix?: InputMaybe<Scalars['String']['input']>;
  itemIn?: InputMaybe<Array<Scalars['String']['input']>>;
  itemLT?: InputMaybe<Scalars['String']['input']>;
  itemLTE?: InputMaybe<Scalars['String']['input']>;
  itemNEQ?: InputMaybe<Scalars['String']['input']>;
  itemNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  not?: InputMaybe<GameHustlerItemWhereInput>;
  or?: InputMaybe<Array<GameHustlerItemWhereInput>>;
};

/** Ordering options for GameHustler connections */
export type GameHustlerOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order GameHustlers. */
  field: GameHustlerOrderField;
};

/** Properties by which GameHustler connections can be ordered. */
export enum GameHustlerOrderField {
  CreatedAt = 'CREATED_AT'
}

export type GameHustlerQuest = Node & {
  __typename?: 'GameHustlerQuest';
  completed: Scalars['Boolean']['output'];
  hustler?: Maybe<GameHustler>;
  id: Scalars['ID']['output'];
  quest: Scalars['String']['output'];
};

/**
 * GameHustlerQuestWhereInput is used for filtering GameHustlerQuest objects.
 * Input was generated by ent.
 */
export type GameHustlerQuestWhereInput = {
  and?: InputMaybe<Array<GameHustlerQuestWhereInput>>;
  /** completed field predicates */
  completed?: InputMaybe<Scalars['Boolean']['input']>;
  completedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerWith?: InputMaybe<Array<GameHustlerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<GameHustlerQuestWhereInput>;
  or?: InputMaybe<Array<GameHustlerQuestWhereInput>>;
  /** quest field predicates */
  quest?: InputMaybe<Scalars['String']['input']>;
  questContains?: InputMaybe<Scalars['String']['input']>;
  questContainsFold?: InputMaybe<Scalars['String']['input']>;
  questEqualFold?: InputMaybe<Scalars['String']['input']>;
  questGT?: InputMaybe<Scalars['String']['input']>;
  questGTE?: InputMaybe<Scalars['String']['input']>;
  questHasPrefix?: InputMaybe<Scalars['String']['input']>;
  questHasSuffix?: InputMaybe<Scalars['String']['input']>;
  questIn?: InputMaybe<Array<Scalars['String']['input']>>;
  questLT?: InputMaybe<Scalars['String']['input']>;
  questLTE?: InputMaybe<Scalars['String']['input']>;
  questNEQ?: InputMaybe<Scalars['String']['input']>;
  questNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
};

export type GameHustlerRelation = Node & {
  __typename?: 'GameHustlerRelation';
  citizen: Scalars['String']['output'];
  conversation: Scalars['String']['output'];
  hustler?: Maybe<GameHustler>;
  id: Scalars['ID']['output'];
  text: Scalars['Int']['output'];
};

/**
 * GameHustlerRelationWhereInput is used for filtering GameHustlerRelation objects.
 * Input was generated by ent.
 */
export type GameHustlerRelationWhereInput = {
  and?: InputMaybe<Array<GameHustlerRelationWhereInput>>;
  /** citizen field predicates */
  citizen?: InputMaybe<Scalars['String']['input']>;
  citizenContains?: InputMaybe<Scalars['String']['input']>;
  citizenContainsFold?: InputMaybe<Scalars['String']['input']>;
  citizenEqualFold?: InputMaybe<Scalars['String']['input']>;
  citizenGT?: InputMaybe<Scalars['String']['input']>;
  citizenGTE?: InputMaybe<Scalars['String']['input']>;
  citizenHasPrefix?: InputMaybe<Scalars['String']['input']>;
  citizenHasSuffix?: InputMaybe<Scalars['String']['input']>;
  citizenIn?: InputMaybe<Array<Scalars['String']['input']>>;
  citizenLT?: InputMaybe<Scalars['String']['input']>;
  citizenLTE?: InputMaybe<Scalars['String']['input']>;
  citizenNEQ?: InputMaybe<Scalars['String']['input']>;
  citizenNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** conversation field predicates */
  conversation?: InputMaybe<Scalars['String']['input']>;
  conversationContains?: InputMaybe<Scalars['String']['input']>;
  conversationContainsFold?: InputMaybe<Scalars['String']['input']>;
  conversationEqualFold?: InputMaybe<Scalars['String']['input']>;
  conversationGT?: InputMaybe<Scalars['String']['input']>;
  conversationGTE?: InputMaybe<Scalars['String']['input']>;
  conversationHasPrefix?: InputMaybe<Scalars['String']['input']>;
  conversationHasSuffix?: InputMaybe<Scalars['String']['input']>;
  conversationIn?: InputMaybe<Array<Scalars['String']['input']>>;
  conversationLT?: InputMaybe<Scalars['String']['input']>;
  conversationLTE?: InputMaybe<Scalars['String']['input']>;
  conversationNEQ?: InputMaybe<Scalars['String']['input']>;
  conversationNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerWith?: InputMaybe<Array<GameHustlerWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<GameHustlerRelationWhereInput>;
  or?: InputMaybe<Array<GameHustlerRelationWhereInput>>;
  /** text field predicates */
  text?: InputMaybe<Scalars['Int']['input']>;
  textGT?: InputMaybe<Scalars['Int']['input']>;
  textGTE?: InputMaybe<Scalars['Int']['input']>;
  textIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  textLT?: InputMaybe<Scalars['Int']['input']>;
  textLTE?: InputMaybe<Scalars['Int']['input']>;
  textNEQ?: InputMaybe<Scalars['Int']['input']>;
  textNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/**
 * GameHustlerWhereInput is used for filtering GameHustler objects.
 * Input was generated by ent.
 */
export type GameHustlerWhereInput = {
  and?: InputMaybe<Array<GameHustlerWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemsWith?: InputMaybe<Array<GameHustlerItemWhereInput>>;
  /** quests edge predicates */
  hasQuests?: InputMaybe<Scalars['Boolean']['input']>;
  hasQuestsWith?: InputMaybe<Array<GameHustlerQuestWhereInput>>;
  /** relations edge predicates */
  hasRelations?: InputMaybe<Scalars['Boolean']['input']>;
  hasRelationsWith?: InputMaybe<Array<GameHustlerRelationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<GameHustlerWhereInput>;
  or?: InputMaybe<Array<GameHustlerWhereInput>>;
};

export type Hash = {
  __typename?: 'Hash';
  value: Scalars['String']['output'];
};

export type Hustler = Node & {
  __typename?: 'Hustler';
  accessory?: Maybe<Item>;
  age: Scalars['Long']['output'];
  background?: Maybe<Scalars['String']['output']>;
  beard?: Maybe<BodyPart>;
  bestAskPriceEth?: Maybe<Scalars['Float']['output']>;
  body?: Maybe<BodyPart>;
  clothes?: Maybe<Item>;
  color?: Maybe<Scalars['String']['output']>;
  createdAt: Scalars['Time']['output'];
  drug?: Maybe<Item>;
  foot?: Maybe<Item>;
  hair?: Maybe<BodyPart>;
  hand?: Maybe<Item>;
  id: Scalars['ID']['output'];
  index?: Maybe<Search>;
  name?: Maybe<Scalars['String']['output']>;
  neck?: Maybe<Item>;
  order: Array<Scalars['Int']['output']>;
  ring?: Maybe<Item>;
  sex: HustlerHustlerSex;
  svg?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  type: HustlerHustlerType;
  vehicle?: Maybe<Item>;
  viewbox: Array<Scalars['Int']['output']>;
  waist?: Maybe<Item>;
  wallet?: Maybe<Wallet>;
  weapon?: Maybe<Item>;
};

/** A connection to a list of items. */
export type HustlerConnection = {
  __typename?: 'HustlerConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HustlerEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type HustlerEdge = {
  __typename?: 'HustlerEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Hustler>;
};

/** HustlerHustlerSex is enum for the field sex */
export enum HustlerHustlerSex {
  Female = 'FEMALE',
  Male = 'MALE'
}

/** HustlerHustlerType is enum for the field type */
export enum HustlerHustlerType {
  OriginalGangsta = 'ORIGINAL_GANGSTA',
  Regular = 'REGULAR'
}

/** Ordering options for Hustler connections */
export type HustlerOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Hustlers. */
  field: HustlerOrderField;
};

/** Properties by which Hustler connections can be ordered. */
export enum HustlerOrderField {
  BestAskPrice = 'BEST_ASK_PRICE',
  CreatedAt = 'CREATED_AT'
}

/**
 * HustlerWhereInput is used for filtering Hustler objects.
 * Input was generated by ent.
 */
export type HustlerWhereInput = {
  /** age field predicates */
  age?: InputMaybe<Scalars['Long']['input']>;
  ageGT?: InputMaybe<Scalars['Long']['input']>;
  ageGTE?: InputMaybe<Scalars['Long']['input']>;
  ageIn?: InputMaybe<Array<Scalars['Long']['input']>>;
  ageLT?: InputMaybe<Scalars['Long']['input']>;
  ageLTE?: InputMaybe<Scalars['Long']['input']>;
  ageNEQ?: InputMaybe<Scalars['Long']['input']>;
  ageNotIn?: InputMaybe<Array<Scalars['Long']['input']>>;
  and?: InputMaybe<Array<HustlerWhereInput>>;
  /** background field predicates */
  background?: InputMaybe<Scalars['String']['input']>;
  backgroundContains?: InputMaybe<Scalars['String']['input']>;
  backgroundContainsFold?: InputMaybe<Scalars['String']['input']>;
  backgroundEqualFold?: InputMaybe<Scalars['String']['input']>;
  backgroundGT?: InputMaybe<Scalars['String']['input']>;
  backgroundGTE?: InputMaybe<Scalars['String']['input']>;
  backgroundHasPrefix?: InputMaybe<Scalars['String']['input']>;
  backgroundHasSuffix?: InputMaybe<Scalars['String']['input']>;
  backgroundIn?: InputMaybe<Array<Scalars['String']['input']>>;
  backgroundIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  backgroundLT?: InputMaybe<Scalars['String']['input']>;
  backgroundLTE?: InputMaybe<Scalars['String']['input']>;
  backgroundNEQ?: InputMaybe<Scalars['String']['input']>;
  backgroundNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  backgroundNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** best_ask_price_eth field predicates */
  bestAskPriceEth?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthGT?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthGTE?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestAskPriceEthIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestAskPriceEthLT?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthLTE?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthNEQ?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestAskPriceEthNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** color field predicates */
  color?: InputMaybe<Scalars['String']['input']>;
  colorContains?: InputMaybe<Scalars['String']['input']>;
  colorContainsFold?: InputMaybe<Scalars['String']['input']>;
  colorEqualFold?: InputMaybe<Scalars['String']['input']>;
  colorGT?: InputMaybe<Scalars['String']['input']>;
  colorGTE?: InputMaybe<Scalars['String']['input']>;
  colorHasPrefix?: InputMaybe<Scalars['String']['input']>;
  colorHasSuffix?: InputMaybe<Scalars['String']['input']>;
  colorIn?: InputMaybe<Array<Scalars['String']['input']>>;
  colorIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  colorLT?: InputMaybe<Scalars['String']['input']>;
  colorLTE?: InputMaybe<Scalars['String']['input']>;
  colorNEQ?: InputMaybe<Scalars['String']['input']>;
  colorNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  colorNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** accessory edge predicates */
  hasAccessory?: InputMaybe<Scalars['Boolean']['input']>;
  hasAccessoryWith?: InputMaybe<Array<ItemWhereInput>>;
  /** beard edge predicates */
  hasBeard?: InputMaybe<Scalars['Boolean']['input']>;
  hasBeardWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** body edge predicates */
  hasBody?: InputMaybe<Scalars['Boolean']['input']>;
  hasBodyWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** clothes edge predicates */
  hasClothes?: InputMaybe<Scalars['Boolean']['input']>;
  hasClothesWith?: InputMaybe<Array<ItemWhereInput>>;
  /** drug edge predicates */
  hasDrug?: InputMaybe<Scalars['Boolean']['input']>;
  hasDrugWith?: InputMaybe<Array<ItemWhereInput>>;
  /** foot edge predicates */
  hasFoot?: InputMaybe<Scalars['Boolean']['input']>;
  hasFootWith?: InputMaybe<Array<ItemWhereInput>>;
  /** hair edge predicates */
  hasHair?: InputMaybe<Scalars['Boolean']['input']>;
  hasHairWith?: InputMaybe<Array<BodyPartWhereInput>>;
  /** hand edge predicates */
  hasHand?: InputMaybe<Scalars['Boolean']['input']>;
  hasHandWith?: InputMaybe<Array<ItemWhereInput>>;
  /** index edge predicates */
  hasIndex?: InputMaybe<Scalars['Boolean']['input']>;
  hasIndexWith?: InputMaybe<Array<SearchWhereInput>>;
  /** neck edge predicates */
  hasNeck?: InputMaybe<Scalars['Boolean']['input']>;
  hasNeckWith?: InputMaybe<Array<ItemWhereInput>>;
  /** ring edge predicates */
  hasRing?: InputMaybe<Scalars['Boolean']['input']>;
  hasRingWith?: InputMaybe<Array<ItemWhereInput>>;
  /** vehicle edge predicates */
  hasVehicle?: InputMaybe<Scalars['Boolean']['input']>;
  hasVehicleWith?: InputMaybe<Array<ItemWhereInput>>;
  /** waist edge predicates */
  hasWaist?: InputMaybe<Scalars['Boolean']['input']>;
  hasWaistWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']['input']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** weapon edge predicates */
  hasWeapon?: InputMaybe<Scalars['Boolean']['input']>;
  hasWeaponWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<HustlerWhereInput>;
  or?: InputMaybe<Array<HustlerWhereInput>>;
  /** sex field predicates */
  sex?: InputMaybe<HustlerHustlerSex>;
  sexIn?: InputMaybe<Array<HustlerHustlerSex>>;
  sexNEQ?: InputMaybe<HustlerHustlerSex>;
  sexNotIn?: InputMaybe<Array<HustlerHustlerSex>>;
  /** svg field predicates */
  svg?: InputMaybe<Scalars['String']['input']>;
  svgContains?: InputMaybe<Scalars['String']['input']>;
  svgContainsFold?: InputMaybe<Scalars['String']['input']>;
  svgEqualFold?: InputMaybe<Scalars['String']['input']>;
  svgGT?: InputMaybe<Scalars['String']['input']>;
  svgGTE?: InputMaybe<Scalars['String']['input']>;
  svgHasPrefix?: InputMaybe<Scalars['String']['input']>;
  svgHasSuffix?: InputMaybe<Scalars['String']['input']>;
  svgIn?: InputMaybe<Array<Scalars['String']['input']>>;
  svgIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  svgLT?: InputMaybe<Scalars['String']['input']>;
  svgLTE?: InputMaybe<Scalars['String']['input']>;
  svgNEQ?: InputMaybe<Scalars['String']['input']>;
  svgNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  svgNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']['input']>;
  titleContains?: InputMaybe<Scalars['String']['input']>;
  titleContainsFold?: InputMaybe<Scalars['String']['input']>;
  titleEqualFold?: InputMaybe<Scalars['String']['input']>;
  titleGT?: InputMaybe<Scalars['String']['input']>;
  titleGTE?: InputMaybe<Scalars['String']['input']>;
  titleHasPrefix?: InputMaybe<Scalars['String']['input']>;
  titleHasSuffix?: InputMaybe<Scalars['String']['input']>;
  titleIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  titleLT?: InputMaybe<Scalars['String']['input']>;
  titleLTE?: InputMaybe<Scalars['String']['input']>;
  titleNEQ?: InputMaybe<Scalars['String']['input']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  titleNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<HustlerHustlerType>;
  typeIn?: InputMaybe<Array<HustlerHustlerType>>;
  typeNEQ?: InputMaybe<HustlerHustlerType>;
  typeNotIn?: InputMaybe<Array<HustlerHustlerType>>;
};

export type Item = Node & {
  __typename?: 'Item';
  augmented?: Maybe<Scalars['Boolean']['output']>;
  base?: Maybe<Item>;
  bestAskPriceEth?: Maybe<Scalars['Float']['output']>;
  count?: Maybe<Scalars['Int']['output']>;
  derivative?: Maybe<Array<Item>>;
  dopes?: Maybe<Array<Dope>>;
  fullname: Scalars['String']['output'];
  greatness?: Maybe<Scalars['Int']['output']>;
  hustlerAccessories?: Maybe<Array<Hustler>>;
  hustlerClothes?: Maybe<Array<Hustler>>;
  hustlerDrugs?: Maybe<Array<Hustler>>;
  hustlerFeet?: Maybe<Array<Hustler>>;
  hustlerHands?: Maybe<Array<Hustler>>;
  hustlerNecks?: Maybe<Array<Hustler>>;
  hustlerRings?: Maybe<Array<Hustler>>;
  hustlerVehicles?: Maybe<Array<Hustler>>;
  hustlerWaists?: Maybe<Array<Hustler>>;
  hustlerWeapons?: Maybe<Array<Hustler>>;
  id: Scalars['ID']['output'];
  index?: Maybe<Search>;
  name: Scalars['String']['output'];
  namePrefix?: Maybe<Scalars['String']['output']>;
  nameSuffix?: Maybe<Scalars['String']['output']>;
  rles?: Maybe<RlEs>;
  sprite?: Maybe<Sprites>;
  suffix?: Maybe<Scalars['String']['output']>;
  svg?: Maybe<Scalars['String']['output']>;
  tier?: Maybe<ItemItemTier>;
  type: ItemItemType;
  wallets?: Maybe<Array<WalletItems>>;
};

/** A connection to a list of items. */
export type ItemConnection = {
  __typename?: 'ItemConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ItemEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type ItemEdge = {
  __typename?: 'ItemEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Item>;
};

/** ItemItemTier is enum for the field tier */
export enum ItemItemTier {
  BlackMarket = 'BLACK_MARKET',
  Common = 'COMMON',
  Custom = 'CUSTOM',
  Rare = 'RARE'
}

/** ItemItemType is enum for the field type */
export enum ItemItemType {
  Accessory = 'ACCESSORY',
  Clothes = 'CLOTHES',
  Drugs = 'DRUGS',
  Foot = 'FOOT',
  Hand = 'HAND',
  Neck = 'NECK',
  Ring = 'RING',
  Vehicle = 'VEHICLE',
  Waist = 'WAIST',
  Weapon = 'WEAPON'
}

/** Ordering options for Item connections */
export type ItemOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Items. */
  field: ItemOrderField;
};

/** Properties by which Item connections can be ordered. */
export enum ItemOrderField {
  BestAskPrice = 'BEST_ASK_PRICE',
  Greatness = 'GREATNESS'
}

/**
 * ItemWhereInput is used for filtering Item objects.
 * Input was generated by ent.
 */
export type ItemWhereInput = {
  and?: InputMaybe<Array<ItemWhereInput>>;
  /** augmented field predicates */
  augmented?: InputMaybe<Scalars['Boolean']['input']>;
  augmentedIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  augmentedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  augmentedNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** best_ask_price_eth field predicates */
  bestAskPriceEth?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthGT?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthGTE?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestAskPriceEthIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  bestAskPriceEthLT?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthLTE?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthNEQ?: InputMaybe<Scalars['Float']['input']>;
  bestAskPriceEthNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  bestAskPriceEthNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** count field predicates */
  count?: InputMaybe<Scalars['Int']['input']>;
  countGT?: InputMaybe<Scalars['Int']['input']>;
  countGTE?: InputMaybe<Scalars['Int']['input']>;
  countIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  countIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  countLT?: InputMaybe<Scalars['Int']['input']>;
  countLTE?: InputMaybe<Scalars['Int']['input']>;
  countNEQ?: InputMaybe<Scalars['Int']['input']>;
  countNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  countNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** greatness field predicates */
  greatness?: InputMaybe<Scalars['Int']['input']>;
  greatnessGT?: InputMaybe<Scalars['Int']['input']>;
  greatnessGTE?: InputMaybe<Scalars['Int']['input']>;
  greatnessIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  greatnessIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  greatnessLT?: InputMaybe<Scalars['Int']['input']>;
  greatnessLTE?: InputMaybe<Scalars['Int']['input']>;
  greatnessNEQ?: InputMaybe<Scalars['Int']['input']>;
  greatnessNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  greatnessNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** base edge predicates */
  hasBase?: InputMaybe<Scalars['Boolean']['input']>;
  hasBaseWith?: InputMaybe<Array<ItemWhereInput>>;
  /** derivative edge predicates */
  hasDerivative?: InputMaybe<Scalars['Boolean']['input']>;
  hasDerivativeWith?: InputMaybe<Array<ItemWhereInput>>;
  /** dopes edge predicates */
  hasDopes?: InputMaybe<Scalars['Boolean']['input']>;
  hasDopesWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler_accessories edge predicates */
  hasHustlerAccessories?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerAccessoriesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_clothes edge predicates */
  hasHustlerClothes?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerClothesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_drugs edge predicates */
  hasHustlerDrugs?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerDrugsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_feet edge predicates */
  hasHustlerFeet?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerFeetWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_hands edge predicates */
  hasHustlerHands?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerHandsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_necks edge predicates */
  hasHustlerNecks?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerNecksWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_rings edge predicates */
  hasHustlerRings?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerRingsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_vehicles edge predicates */
  hasHustlerVehicles?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerVehiclesWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_waists edge predicates */
  hasHustlerWaists?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerWaistsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** hustler_weapons edge predicates */
  hasHustlerWeapons?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerWeaponsWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** index edge predicates */
  hasIndex?: InputMaybe<Scalars['Boolean']['input']>;
  hasIndexWith?: InputMaybe<Array<SearchWhereInput>>;
  /** wallets edge predicates */
  hasWallets?: InputMaybe<Scalars['Boolean']['input']>;
  hasWalletsWith?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']['input']>;
  nameContains?: InputMaybe<Scalars['String']['input']>;
  nameContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameGT?: InputMaybe<Scalars['String']['input']>;
  nameGTE?: InputMaybe<Scalars['String']['input']>;
  nameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameLT?: InputMaybe<Scalars['String']['input']>;
  nameLTE?: InputMaybe<Scalars['String']['input']>;
  nameNEQ?: InputMaybe<Scalars['String']['input']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** name_prefix field predicates */
  namePrefix?: InputMaybe<Scalars['String']['input']>;
  namePrefixContains?: InputMaybe<Scalars['String']['input']>;
  namePrefixContainsFold?: InputMaybe<Scalars['String']['input']>;
  namePrefixEqualFold?: InputMaybe<Scalars['String']['input']>;
  namePrefixGT?: InputMaybe<Scalars['String']['input']>;
  namePrefixGTE?: InputMaybe<Scalars['String']['input']>;
  namePrefixHasPrefix?: InputMaybe<Scalars['String']['input']>;
  namePrefixHasSuffix?: InputMaybe<Scalars['String']['input']>;
  namePrefixIn?: InputMaybe<Array<Scalars['String']['input']>>;
  namePrefixIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  namePrefixLT?: InputMaybe<Scalars['String']['input']>;
  namePrefixLTE?: InputMaybe<Scalars['String']['input']>;
  namePrefixNEQ?: InputMaybe<Scalars['String']['input']>;
  namePrefixNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  namePrefixNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** name_suffix field predicates */
  nameSuffix?: InputMaybe<Scalars['String']['input']>;
  nameSuffixContains?: InputMaybe<Scalars['String']['input']>;
  nameSuffixContainsFold?: InputMaybe<Scalars['String']['input']>;
  nameSuffixEqualFold?: InputMaybe<Scalars['String']['input']>;
  nameSuffixGT?: InputMaybe<Scalars['String']['input']>;
  nameSuffixGTE?: InputMaybe<Scalars['String']['input']>;
  nameSuffixHasPrefix?: InputMaybe<Scalars['String']['input']>;
  nameSuffixHasSuffix?: InputMaybe<Scalars['String']['input']>;
  nameSuffixIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameSuffixIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  nameSuffixLT?: InputMaybe<Scalars['String']['input']>;
  nameSuffixLTE?: InputMaybe<Scalars['String']['input']>;
  nameSuffixNEQ?: InputMaybe<Scalars['String']['input']>;
  nameSuffixNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  nameSuffixNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<ItemWhereInput>;
  or?: InputMaybe<Array<ItemWhereInput>>;
  /** suffix field predicates */
  suffix?: InputMaybe<Scalars['String']['input']>;
  suffixContains?: InputMaybe<Scalars['String']['input']>;
  suffixContainsFold?: InputMaybe<Scalars['String']['input']>;
  suffixEqualFold?: InputMaybe<Scalars['String']['input']>;
  suffixGT?: InputMaybe<Scalars['String']['input']>;
  suffixGTE?: InputMaybe<Scalars['String']['input']>;
  suffixHasPrefix?: InputMaybe<Scalars['String']['input']>;
  suffixHasSuffix?: InputMaybe<Scalars['String']['input']>;
  suffixIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suffixIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  suffixLT?: InputMaybe<Scalars['String']['input']>;
  suffixLTE?: InputMaybe<Scalars['String']['input']>;
  suffixNEQ?: InputMaybe<Scalars['String']['input']>;
  suffixNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  suffixNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** svg field predicates */
  svg?: InputMaybe<Scalars['String']['input']>;
  svgContains?: InputMaybe<Scalars['String']['input']>;
  svgContainsFold?: InputMaybe<Scalars['String']['input']>;
  svgEqualFold?: InputMaybe<Scalars['String']['input']>;
  svgGT?: InputMaybe<Scalars['String']['input']>;
  svgGTE?: InputMaybe<Scalars['String']['input']>;
  svgHasPrefix?: InputMaybe<Scalars['String']['input']>;
  svgHasSuffix?: InputMaybe<Scalars['String']['input']>;
  svgIn?: InputMaybe<Array<Scalars['String']['input']>>;
  svgIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  svgLT?: InputMaybe<Scalars['String']['input']>;
  svgLTE?: InputMaybe<Scalars['String']['input']>;
  svgNEQ?: InputMaybe<Scalars['String']['input']>;
  svgNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  svgNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** tier field predicates */
  tier?: InputMaybe<ItemItemTier>;
  tierIn?: InputMaybe<Array<ItemItemTier>>;
  tierIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  tierNEQ?: InputMaybe<ItemItemTier>;
  tierNotIn?: InputMaybe<Array<ItemItemTier>>;
  tierNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<ItemItemType>;
  typeIn?: InputMaybe<Array<ItemItemType>>;
  typeNEQ?: InputMaybe<ItemItemType>;
  typeNotIn?: InputMaybe<Array<ItemItemType>>;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID']['output'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type Position = {
  __typename?: 'Position';
  currentMap: Scalars['String']['output'];
  x: Scalars['Float']['output'];
  y: Scalars['Float']['output'];
};

export type Query = {
  __typename?: 'Query';
  bodyParts: BodyPartConnection;
  dopes: DopeConnection;
  hustlers: HustlerConnection;
  items: ItemConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  search: SearchConnection;
  walletItems: WalletItemsConnection;
  wallets: WalletConnection;
};


export type QueryBodyPartsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BodyPartWhereInput>;
};


export type QueryDopesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DopeOrder>;
  where?: InputMaybe<DopeWhereInput>;
};


export type QueryHustlersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<HustlerOrder>;
  where?: InputMaybe<HustlerWhereInput>;
};


export type QueryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ItemOrder>;
  where?: InputMaybe<ItemWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID']['input'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']['input']>;
};


export type QuerySearchArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<SearchOrder>;
  query: Scalars['String']['input'];
  where?: InputMaybe<SearchWhereInput>;
};


export type QueryWalletItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<WalletItemsWhereInput>;
};


export type QueryWalletsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<WalletOrder>;
  where?: InputMaybe<WalletWhereInput>;
};

export type RlEs = {
  __typename?: 'RLEs';
  female: Scalars['String']['output'];
  male: Scalars['String']['output'];
};

export type Search = Node & {
  __typename?: 'Search';
  banned: Scalars['Boolean']['output'];
  claimed: Scalars['Boolean']['output'];
  dope?: Maybe<Dope>;
  greatness?: Maybe<Scalars['Int']['output']>;
  hustler?: Maybe<Hustler>;
  id: Scalars['ID']['output'];
  item?: Maybe<Item>;
  opened: Scalars['Boolean']['output'];
  salePrice?: Maybe<Scalars['Float']['output']>;
  type: SearchSearchType;
};

/** A connection to a list of items. */
export type SearchConnection = {
  __typename?: 'SearchConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SearchEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type SearchEdge = {
  __typename?: 'SearchEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Search>;
};

/** Ordering options for Search connections */
export type SearchOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Searches. */
  field: SearchOrderField;
};

/** Properties by which Search connections can be ordered. */
export enum SearchOrderField {
  Greatness = 'GREATNESS',
  SalePrice = 'SALE_PRICE'
}

export type SearchResult = Dope | Hustler | Item;

/** SearchSearchType is enum for the field type */
export enum SearchSearchType {
  Dope = 'DOPE',
  Hustler = 'HUSTLER',
  Item = 'ITEM'
}

/**
 * SearchWhereInput is used for filtering Search objects.
 * Input was generated by ent.
 */
export type SearchWhereInput = {
  and?: InputMaybe<Array<SearchWhereInput>>;
  /** banned field predicates */
  banned?: InputMaybe<Scalars['Boolean']['input']>;
  bannedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** claimed field predicates */
  claimed?: InputMaybe<Scalars['Boolean']['input']>;
  claimedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  /** greatness field predicates */
  greatness?: InputMaybe<Scalars['Int']['input']>;
  greatnessGT?: InputMaybe<Scalars['Int']['input']>;
  greatnessGTE?: InputMaybe<Scalars['Int']['input']>;
  greatnessIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  greatnessIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  greatnessLT?: InputMaybe<Scalars['Int']['input']>;
  greatnessLTE?: InputMaybe<Scalars['Int']['input']>;
  greatnessNEQ?: InputMaybe<Scalars['Int']['input']>;
  greatnessNotIn?: InputMaybe<Array<Scalars['Int']['input']>>;
  greatnessNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** dope edge predicates */
  hasDope?: InputMaybe<Scalars['Boolean']['input']>;
  hasDopeWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustler edge predicates */
  hasHustler?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlerWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<SearchWhereInput>;
  /** opened field predicates */
  opened?: InputMaybe<Scalars['Boolean']['input']>;
  openedNEQ?: InputMaybe<Scalars['Boolean']['input']>;
  or?: InputMaybe<Array<SearchWhereInput>>;
  /** sale_price field predicates */
  salePrice?: InputMaybe<Scalars['Float']['input']>;
  salePriceGT?: InputMaybe<Scalars['Float']['input']>;
  salePriceGTE?: InputMaybe<Scalars['Float']['input']>;
  salePriceIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  salePriceIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  salePriceLT?: InputMaybe<Scalars['Float']['input']>;
  salePriceLTE?: InputMaybe<Scalars['Float']['input']>;
  salePriceNEQ?: InputMaybe<Scalars['Float']['input']>;
  salePriceNotIn?: InputMaybe<Array<Scalars['Float']['input']>>;
  salePriceNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** type field predicates */
  type?: InputMaybe<SearchSearchType>;
  typeIn?: InputMaybe<Array<SearchSearchType>>;
  typeNEQ?: InputMaybe<SearchSearchType>;
  typeNotIn?: InputMaybe<Array<SearchSearchType>>;
};

export type Sprites = {
  __typename?: 'Sprites';
  Female?: Maybe<Scalars['String']['output']>;
  Male?: Maybe<Scalars['String']['output']>;
};

export type SyncState = Node & {
  __typename?: 'SyncState';
  blockTime?: Maybe<Scalars['Time']['output']>;
  contractName?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  lastSyncedAt?: Maybe<Scalars['Time']['output']>;
  startBlock: Scalars['Long']['output'];
};

/**
 * SyncStateWhereInput is used for filtering SyncState objects.
 * Input was generated by ent.
 */
export type SyncStateWhereInput = {
  and?: InputMaybe<Array<SyncStateWhereInput>>;
  /** block_time field predicates */
  blockTime?: InputMaybe<Scalars['Time']['input']>;
  blockTimeGT?: InputMaybe<Scalars['Time']['input']>;
  blockTimeGTE?: InputMaybe<Scalars['Time']['input']>;
  blockTimeIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  blockTimeIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  blockTimeLT?: InputMaybe<Scalars['Time']['input']>;
  blockTimeLTE?: InputMaybe<Scalars['Time']['input']>;
  blockTimeNEQ?: InputMaybe<Scalars['Time']['input']>;
  blockTimeNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  blockTimeNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** contract_name field predicates */
  contractName?: InputMaybe<Scalars['String']['input']>;
  contractNameContains?: InputMaybe<Scalars['String']['input']>;
  contractNameContainsFold?: InputMaybe<Scalars['String']['input']>;
  contractNameEqualFold?: InputMaybe<Scalars['String']['input']>;
  contractNameGT?: InputMaybe<Scalars['String']['input']>;
  contractNameGTE?: InputMaybe<Scalars['String']['input']>;
  contractNameHasPrefix?: InputMaybe<Scalars['String']['input']>;
  contractNameHasSuffix?: InputMaybe<Scalars['String']['input']>;
  contractNameIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contractNameIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  contractNameLT?: InputMaybe<Scalars['String']['input']>;
  contractNameLTE?: InputMaybe<Scalars['String']['input']>;
  contractNameNEQ?: InputMaybe<Scalars['String']['input']>;
  contractNameNotIn?: InputMaybe<Array<Scalars['String']['input']>>;
  contractNameNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_synced_at field predicates */
  lastSyncedAt?: InputMaybe<Scalars['Time']['input']>;
  lastSyncedAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastSyncedAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastSyncedAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSyncedAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastSyncedAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastSyncedAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastSyncedAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastSyncedAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSyncedAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<SyncStateWhereInput>;
  or?: InputMaybe<Array<SyncStateWhereInput>>;
  /** start_block field predicates */
  startBlock?: InputMaybe<Scalars['Long']['input']>;
  startBlockGT?: InputMaybe<Scalars['Long']['input']>;
  startBlockGTE?: InputMaybe<Scalars['Long']['input']>;
  startBlockIn?: InputMaybe<Array<Scalars['Long']['input']>>;
  startBlockLT?: InputMaybe<Scalars['Long']['input']>;
  startBlockLTE?: InputMaybe<Scalars['Long']['input']>;
  startBlockNEQ?: InputMaybe<Scalars['Long']['input']>;
  startBlockNotIn?: InputMaybe<Array<Scalars['Long']['input']>>;
};

export type Wallet = Node & {
  __typename?: 'Wallet';
  createdAt: Scalars['Time']['output'];
  dopes?: Maybe<Array<Dope>>;
  hustlers?: Maybe<Array<Hustler>>;
  id: Scalars['ID']['output'];
  items?: Maybe<Array<WalletItems>>;
  lastSetPaperBalanceAt?: Maybe<Scalars['Time']['output']>;
  paper: Scalars['BigInt']['output'];
};

/** A connection to a list of items. */
export type WalletConnection = {
  __typename?: 'WalletConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WalletEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type WalletEdge = {
  __typename?: 'WalletEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<Wallet>;
};

export type WalletItems = Node & {
  __typename?: 'WalletItems';
  balance: Scalars['BigInt']['output'];
  id: Scalars['ID']['output'];
  item?: Maybe<Item>;
  wallet?: Maybe<Wallet>;
};

/** A connection to a list of items. */
export type WalletItemsConnection = {
  __typename?: 'WalletItemsConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WalletItemsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int']['output'];
};

/** An edge in a connection. */
export type WalletItemsEdge = {
  __typename?: 'WalletItemsEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor']['output'];
  /** The item at the end of the edge. */
  node?: Maybe<WalletItems>;
};

/**
 * WalletItemsWhereInput is used for filtering WalletItems objects.
 * Input was generated by ent.
 */
export type WalletItemsWhereInput = {
  and?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** balance field predicates */
  balance?: InputMaybe<Scalars['BigInt']['input']>;
  balanceGT?: InputMaybe<Scalars['BigInt']['input']>;
  balanceGTE?: InputMaybe<Scalars['BigInt']['input']>;
  balanceIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  balanceLT?: InputMaybe<Scalars['BigInt']['input']>;
  balanceLTE?: InputMaybe<Scalars['BigInt']['input']>;
  balanceNEQ?: InputMaybe<Scalars['BigInt']['input']>;
  balanceNotIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** item edge predicates */
  hasItem?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemWith?: InputMaybe<Array<ItemWhereInput>>;
  /** wallet edge predicates */
  hasWallet?: InputMaybe<Scalars['Boolean']['input']>;
  hasWalletWith?: InputMaybe<Array<WalletWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  not?: InputMaybe<WalletItemsWhereInput>;
  or?: InputMaybe<Array<WalletItemsWhereInput>>;
};

/** Ordering options for Wallet connections */
export type WalletOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Wallets. */
  field: WalletOrderField;
};

/** Properties by which Wallet connections can be ordered. */
export enum WalletOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * WalletWhereInput is used for filtering Wallet objects.
 * Input was generated by ent.
 */
export type WalletWhereInput = {
  and?: InputMaybe<Array<WalletWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']['input']>;
  createdAtGT?: InputMaybe<Scalars['Time']['input']>;
  createdAtGTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  createdAtLT?: InputMaybe<Scalars['Time']['input']>;
  createdAtLTE?: InputMaybe<Scalars['Time']['input']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  /** dopes edge predicates */
  hasDopes?: InputMaybe<Scalars['Boolean']['input']>;
  hasDopesWith?: InputMaybe<Array<DopeWhereInput>>;
  /** hustlers edge predicates */
  hasHustlers?: InputMaybe<Scalars['Boolean']['input']>;
  hasHustlersWith?: InputMaybe<Array<HustlerWhereInput>>;
  /** items edge predicates */
  hasItems?: InputMaybe<Scalars['Boolean']['input']>;
  hasItemsWith?: InputMaybe<Array<WalletItemsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']['input']>;
  idContainsFold?: InputMaybe<Scalars['ID']['input']>;
  idEqualFold?: InputMaybe<Scalars['ID']['input']>;
  idGT?: InputMaybe<Scalars['ID']['input']>;
  idGTE?: InputMaybe<Scalars['ID']['input']>;
  idIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  idLT?: InputMaybe<Scalars['ID']['input']>;
  idLTE?: InputMaybe<Scalars['ID']['input']>;
  idNEQ?: InputMaybe<Scalars['ID']['input']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']['input']>>;
  /** last_set_paper_balance_at field predicates */
  lastSetPaperBalanceAt?: InputMaybe<Scalars['Time']['input']>;
  lastSetPaperBalanceAtGT?: InputMaybe<Scalars['Time']['input']>;
  lastSetPaperBalanceAtGTE?: InputMaybe<Scalars['Time']['input']>;
  lastSetPaperBalanceAtIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSetPaperBalanceAtIsNil?: InputMaybe<Scalars['Boolean']['input']>;
  lastSetPaperBalanceAtLT?: InputMaybe<Scalars['Time']['input']>;
  lastSetPaperBalanceAtLTE?: InputMaybe<Scalars['Time']['input']>;
  lastSetPaperBalanceAtNEQ?: InputMaybe<Scalars['Time']['input']>;
  lastSetPaperBalanceAtNotIn?: InputMaybe<Array<Scalars['Time']['input']>>;
  lastSetPaperBalanceAtNotNil?: InputMaybe<Scalars['Boolean']['input']>;
  not?: InputMaybe<WalletWhereInput>;
  or?: InputMaybe<Array<WalletWhereInput>>;
  /** paper field predicates */
  paper?: InputMaybe<Scalars['BigInt']['input']>;
  paperGT?: InputMaybe<Scalars['BigInt']['input']>;
  paperGTE?: InputMaybe<Scalars['BigInt']['input']>;
  paperIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  paperLT?: InputMaybe<Scalars['BigInt']['input']>;
  paperLTE?: InputMaybe<Scalars['BigInt']['input']>;
  paperNEQ?: InputMaybe<Scalars['BigInt']['input']>;
  paperNotIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

export type DrugQueryVariables = Exact<{
  id?: InputMaybe<Scalars['ID']['input']>;
}>;


export type DrugQuery = { __typename?: 'Query', items: { __typename?: 'ItemConnection', totalCount: number, edges?: Array<{ __typename?: 'ItemEdge', node?: { __typename?: 'Item', id: string, name: string, rles?: { __typename?: 'RLEs', male: string } | null, base?: { __typename?: 'Item', rles?: { __typename?: 'RLEs', male: string } | null } | null } | null } | null> | null } };

export type DrugsQueryVariables = Exact<{ [key: string]: never; }>;


export type DrugsQuery = { __typename?: 'Query', items: { __typename?: 'ItemConnection', totalCount: number, edges?: Array<{ __typename?: 'ItemEdge', node?: { __typename?: 'Item', id: string, name: string, rles?: { __typename?: 'RLEs', male: string } | null, base?: { __typename?: 'Item', rles?: { __typename?: 'RLEs', male: string } | null } | null } | null } | null> | null } };

export type AllHustlersQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<HustlerOrder>;
  where?: InputMaybe<HustlerWhereInput>;
}>;


export type AllHustlersQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'HustlerEdge', cursor: any, node?: { __typename?: 'Hustler', id: string, name?: string | null, type: HustlerHustlerType, title?: string | null, color?: string | null, background?: string | null, age: any, svg?: string | null, sex: HustlerHustlerSex } | null } | null> | null } };

export type AllItemsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<ItemOrder>;
  where?: InputMaybe<ItemWhereInput>;
}>;


export type AllItemsQuery = { __typename?: 'Query', items: { __typename?: 'ItemConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'ItemEdge', node?: { __typename?: 'Item', name: string, id: string, fullname: string, greatness?: number | null, svg?: string | null, base?: { __typename?: 'Item', svg?: string | null } | null } | null } | null> | null } };

export type BodyPartsQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  where?: InputMaybe<BodyPartWhereInput>;
}>;


export type BodyPartsQuery = { __typename?: 'Query', bodyParts: { __typename?: 'BodyPartConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'BodyPartEdge', cursor: any, node?: { __typename?: 'BodyPart', id: string, type: BodyPartBodyPartType, sex: BodyPartBodyPartSex, rle: string } | null } | null> | null } };

export type DopeListingQueryVariables = Exact<{
  where?: InputMaybe<DopeWhereInput>;
}>;


export type DopeListingQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, bestAskPriceEth?: number | null } | null } | null> | null } };

export type DopesQueryVariables = Exact<{
  after?: InputMaybe<Scalars['Cursor']['input']>;
  first?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<DopeOrder>;
  where?: InputMaybe<DopeWhereInput>;
}>;


export type DopesQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, claimed: boolean, opened: boolean, score?: number | null, rank?: number | null, bestAskPriceEth?: number | null, items?: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemItemType, name: string, namePrefix?: string | null, nameSuffix?: string | null, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null }> | null } | null } | null> | null } };

export type HustlerQueryVariables = Exact<{
  where?: InputMaybe<HustlerWhereInput>;
}>;


export type HustlerQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', totalCount: number, edges?: Array<{ __typename?: 'HustlerEdge', node?: { __typename?: 'Hustler', id: string, title?: string | null, name?: string | null, type: HustlerHustlerType, color?: string | null, background?: string | null, age: any, sex: HustlerHustlerSex, svg?: string | null, viewbox: Array<number>, order: Array<number>, neck?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, ring?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, accessory?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, body?: { __typename?: 'BodyPart', id: string, rle: string } | null, hair?: { __typename?: 'BodyPart', id: string, rle: string } | null, beard?: { __typename?: 'BodyPart', id: string, rle: string } | null, drug?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, hand?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, weapon?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, clothes?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, vehicle?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, waist?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null, foot?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string, svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null, base?: { __typename?: 'Item', svg?: string | null, rles?: { __typename?: 'RLEs', male: string, female: string } | null } | null } | null } | null } | null> | null } };

export type HustlersWalletQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type HustlersWalletQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers?: Array<{ __typename?: 'Hustler', id: string, title?: string | null, name?: string | null, type: HustlerHustlerType, color?: string | null, background?: string | null, age: any, svg?: string | null }> | null } | null } | null> | null } };

export type ItemQueryVariables = Exact<{
  where?: InputMaybe<ItemWhereInput>;
}>;


export type ItemQuery = { __typename?: 'Query', items: { __typename?: 'ItemConnection', edges?: Array<{ __typename?: 'ItemEdge', node?: { __typename?: 'Item', id: string, fullname: string, svg?: string | null, base?: { __typename?: 'Item', svg?: string | null } | null } | null } | null> | null } };

export type ProfileDopesQueryVariables = Exact<{
  where?: InputMaybe<DopeWhereInput>;
  orderBy?: InputMaybe<DopeOrder>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type ProfileDopesQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, edges?: Array<{ __typename?: 'DopeEdge', node?: { __typename?: 'Dope', id: string, rank?: number | null, score?: number | null, claimed: boolean, opened: boolean, bestAskPriceEth?: number | null, items?: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemItemType, name: string, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, suffix?: string | null }> | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null, hasNextPage: boolean } } };

export type ProfileHustlersQueryVariables = Exact<{
  where?: InputMaybe<HustlerWhereInput>;
  orderBy?: InputMaybe<HustlerOrder>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type ProfileHustlersQuery = { __typename?: 'Query', hustlers: { __typename?: 'HustlerConnection', totalCount: number, edges?: Array<{ __typename?: 'HustlerEdge', node?: { __typename?: 'Hustler', id: string, name?: string | null, svg?: string | null, title?: string | null, type: HustlerHustlerType, bestAskPriceEth?: number | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null, hasNextPage: boolean } } };

export type ProfileGearQueryVariables = Exact<{
  where?: InputMaybe<WalletItemsWhereInput>;
  first?: InputMaybe<Scalars['Int']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type ProfileGearQuery = { __typename?: 'Query', walletItems: { __typename?: 'WalletItemsConnection', totalCount: number, edges?: Array<{ __typename?: 'WalletItemsEdge', node?: { __typename?: 'WalletItems', id: string, balance: any, item?: { __typename?: 'Item', bestAskPriceEth?: number | null, id: string, count?: number | null, fullname: string, name: string, svg?: string | null, suffix?: string | null, type: ItemItemType, base?: { __typename?: 'Item', svg?: string | null } | null } | null } | null } | null> | null, pageInfo: { __typename?: 'PageInfo', endCursor?: any | null, hasNextPage: boolean } } };

export type RenderDopeQueryVariables = Exact<{
  where?: InputMaybe<DopeWhereInput>;
}>;


export type RenderDopeQuery = { __typename?: 'Query', dopes: { __typename?: 'DopeConnection', totalCount: number, edges?: Array<{ __typename?: 'DopeEdge', cursor: any, node?: { __typename?: 'Dope', id: string, items?: Array<{ __typename?: 'Item', id: string, type: ItemItemType, rles?: { __typename?: 'RLEs', female: string, male: string } | null, base?: { __typename?: 'Item', id: string, rles?: { __typename?: 'RLEs', female: string, male: string } | null } | null }> | null } | null } | null> | null } };

export type SearchQueryVariables = Exact<{
  query: Scalars['String']['input'];
  where?: InputMaybe<SearchWhereInput>;
  orderBy?: InputMaybe<SearchOrder>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  after?: InputMaybe<Scalars['Cursor']['input']>;
}>;


export type SearchQuery = { __typename?: 'Query', search: { __typename?: 'SearchConnection', totalCount: number, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null }, edges?: Array<{ __typename?: 'SearchEdge', node?: { __typename?: 'Search', dope?: { __typename: 'Dope', id: string, claimed: boolean, opened: boolean, score?: number | null, rank?: number | null, bestAskPriceEth?: number | null, items?: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemItemType, name: string, namePrefix?: string | null, nameSuffix?: string | null, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null }> | null } | null, hustler?: { __typename: 'Hustler', id: string, bestAskPriceEth?: number | null, title?: string | null, name?: string | null, type: HustlerHustlerType, color?: string | null, background?: string | null, age: any, sex: HustlerHustlerSex, svg?: string | null, neck?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, ring?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, accessory?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, body?: { __typename?: 'BodyPart', id: string, sex: BodyPartBodyPartSex, type: BodyPartBodyPartType, rle: string } | null, hair?: { __typename?: 'BodyPart', id: string, sex: BodyPartBodyPartSex, type: BodyPartBodyPartType, rle: string } | null, beard?: { __typename?: 'BodyPart', id: string, sex: BodyPartBodyPartSex, type: BodyPartBodyPartType, rle: string } | null, drug?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, hand?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, weapon?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, clothes?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, vehicle?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, waist?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null, foot?: { __typename?: 'Item', id: string, type: ItemItemType, name: string, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null, fullname: string } | null } | null, item?: { __typename: 'Item', bestAskPriceEth?: number | null, id: string, fullname: string, name: string, svg?: string | null, type: ItemItemType, suffix?: string | null } | null } | null } | null> | null } };

export type WalletQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type WalletQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers?: Array<{ __typename?: 'Hustler', id: string, title?: string | null, name?: string | null }> | null, items?: Array<{ __typename?: 'WalletItems', id: string, balance: any, item?: { __typename?: 'Item', id: string, name: string } | null }> | null, dopes?: Array<{ __typename?: 'Dope', id: string, claimed: boolean, opened: boolean, score?: number | null, rank?: number | null, items?: Array<{ __typename?: 'Item', id: string, fullname: string, type: ItemItemType, name: string, namePrefix?: string | null, nameSuffix?: string | null, suffix?: string | null, augmented?: boolean | null, tier?: ItemItemTier | null, greatness?: number | null, count?: number | null }> | null }> | null } | null } | null> | null } };

export type WalletCheckQueryVariables = Exact<{
  where?: InputMaybe<WalletWhereInput>;
}>;


export type WalletCheckQuery = { __typename?: 'Query', wallets: { __typename?: 'WalletConnection', edges?: Array<{ __typename?: 'WalletEdge', node?: { __typename?: 'Wallet', id: string, paper: any, hustlers?: Array<{ __typename?: 'Hustler', id: string }> | null, items?: Array<{ __typename?: 'WalletItems', id: string }> | null, dopes?: Array<{ __typename?: 'Dope', id: string }> | null } | null } | null> | null } };



export const DrugDocument = `
    query Drug($id: ID) {
  items(where: {type: DRUGS, hasBase: false, id: $id}) {
    totalCount
    edges {
      node {
        id
        name
        rles {
          male
        }
        base {
          rles {
            male
          }
        }
      }
    }
  }
}
    `;

export const useDrugQuery = <
      TData = DrugQuery,
      TError = unknown
    >(
      variables?: DrugQueryVariables,
      options?: Omit<UseQueryOptions<DrugQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<DrugQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<DrugQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['Drug'] : ['Drug', variables],
    queryFn: useFetchData<DrugQuery, DrugQueryVariables>(DrugDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteDrugQuery = <
      TData = InfiniteData<DrugQuery>,
      TError = unknown
    >(
      variables: DrugQueryVariables,
      options: Omit<UseInfiniteQueryOptions<DrugQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<DrugQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<DrugQuery, DrugQueryVariables>(DrugDocument)
    return useInfiniteQuery<DrugQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['Drug.infinite'] : ['Drug.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const DrugsDocument = `
    query Drugs {
  items(where: {type: DRUGS, hasBase: false}) {
    totalCount
    edges {
      node {
        id
        name
        rles {
          male
        }
        base {
          rles {
            male
          }
        }
      }
    }
  }
}
    `;

export const useDrugsQuery = <
      TData = DrugsQuery,
      TError = unknown
    >(
      variables?: DrugsQueryVariables,
      options?: Omit<UseQueryOptions<DrugsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<DrugsQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<DrugsQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['Drugs'] : ['Drugs', variables],
    queryFn: useFetchData<DrugsQuery, DrugsQueryVariables>(DrugsDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteDrugsQuery = <
      TData = InfiniteData<DrugsQuery>,
      TError = unknown
    >(
      variables: DrugsQueryVariables,
      options: Omit<UseInfiniteQueryOptions<DrugsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<DrugsQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<DrugsQuery, DrugsQueryVariables>(DrugsDocument)
    return useInfiniteQuery<DrugsQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['Drugs.infinite'] : ['Drugs.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const AllHustlersDocument = `
    query AllHustlers($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: HustlerOrder, $where: HustlerWhereInput) {
  hustlers(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        name
        type
        title
        color
        background
        age
        svg
        sex
      }
    }
  }
}
    `;

export const useAllHustlersQuery = <
      TData = AllHustlersQuery,
      TError = unknown
    >(
      variables?: AllHustlersQueryVariables,
      options?: Omit<UseQueryOptions<AllHustlersQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<AllHustlersQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<AllHustlersQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['AllHustlers'] : ['AllHustlers', variables],
    queryFn: useFetchData<AllHustlersQuery, AllHustlersQueryVariables>(AllHustlersDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteAllHustlersQuery = <
      TData = InfiniteData<AllHustlersQuery>,
      TError = unknown
    >(
      variables: AllHustlersQueryVariables,
      options: Omit<UseInfiniteQueryOptions<AllHustlersQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<AllHustlersQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<AllHustlersQuery, AllHustlersQueryVariables>(AllHustlersDocument)
    return useInfiniteQuery<AllHustlersQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['AllHustlers.infinite'] : ['AllHustlers.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const AllItemsDocument = `
    query AllItems($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: ItemOrder, $where: ItemWhereInput) {
  items(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        name
        id
        fullname
        greatness
        svg
        base {
          svg
        }
      }
    }
  }
}
    `;

export const useAllItemsQuery = <
      TData = AllItemsQuery,
      TError = unknown
    >(
      variables?: AllItemsQueryVariables,
      options?: Omit<UseQueryOptions<AllItemsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<AllItemsQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<AllItemsQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['AllItems'] : ['AllItems', variables],
    queryFn: useFetchData<AllItemsQuery, AllItemsQueryVariables>(AllItemsDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteAllItemsQuery = <
      TData = InfiniteData<AllItemsQuery>,
      TError = unknown
    >(
      variables: AllItemsQueryVariables,
      options: Omit<UseInfiniteQueryOptions<AllItemsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<AllItemsQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<AllItemsQuery, AllItemsQueryVariables>(AllItemsDocument)
    return useInfiniteQuery<AllItemsQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['AllItems.infinite'] : ['AllItems.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const BodyPartsDocument = `
    query BodyParts($after: Cursor, $first: Int, $before: Cursor, $last: Int, $where: BodyPartWhereInput) {
  bodyParts(
    after: $after
    first: $first
    before: $before
    last: $last
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        type
        sex
        rle
      }
    }
  }
}
    `;

export const useBodyPartsQuery = <
      TData = BodyPartsQuery,
      TError = unknown
    >(
      variables?: BodyPartsQueryVariables,
      options?: Omit<UseQueryOptions<BodyPartsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<BodyPartsQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<BodyPartsQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['BodyParts'] : ['BodyParts', variables],
    queryFn: useFetchData<BodyPartsQuery, BodyPartsQueryVariables>(BodyPartsDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteBodyPartsQuery = <
      TData = InfiniteData<BodyPartsQuery>,
      TError = unknown
    >(
      variables: BodyPartsQueryVariables,
      options: Omit<UseInfiniteQueryOptions<BodyPartsQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<BodyPartsQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<BodyPartsQuery, BodyPartsQueryVariables>(BodyPartsDocument)
    return useInfiniteQuery<BodyPartsQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['BodyParts.infinite'] : ['BodyParts.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const DopeListingDocument = `
    query DopeListing($where: DopeWhereInput) {
  dopes(where: {bestAskPriceEthGT: 0}) {
    totalCount
    edges {
      cursor
      node {
        id
        bestAskPriceEth
      }
    }
  }
}
    `;

export const useDopeListingQuery = <
      TData = DopeListingQuery,
      TError = unknown
    >(
      variables?: DopeListingQueryVariables,
      options?: Omit<UseQueryOptions<DopeListingQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<DopeListingQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<DopeListingQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['DopeListing'] : ['DopeListing', variables],
    queryFn: useFetchData<DopeListingQuery, DopeListingQueryVariables>(DopeListingDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteDopeListingQuery = <
      TData = InfiniteData<DopeListingQuery>,
      TError = unknown
    >(
      variables: DopeListingQueryVariables,
      options: Omit<UseInfiniteQueryOptions<DopeListingQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<DopeListingQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<DopeListingQuery, DopeListingQueryVariables>(DopeListingDocument)
    return useInfiniteQuery<DopeListingQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['DopeListing.infinite'] : ['DopeListing.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const DopesDocument = `
    query Dopes($after: Cursor, $first: Int, $before: Cursor, $last: Int, $orderBy: DopeOrder, $where: DopeWhereInput) {
  dopes(
    after: $after
    first: $first
    before: $before
    last: $last
    orderBy: $orderBy
    where: $where
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      cursor
      node {
        id
        claimed
        opened
        score
        rank
        bestAskPriceEth
        items {
          id
          fullname
          type
          name
          namePrefix
          nameSuffix
          suffix
          augmented
          tier
          greatness
          count
        }
      }
    }
  }
}
    `;

export const useDopesQuery = <
      TData = DopesQuery,
      TError = unknown
    >(
      variables?: DopesQueryVariables,
      options?: Omit<UseQueryOptions<DopesQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<DopesQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<DopesQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['Dopes'] : ['Dopes', variables],
    queryFn: useFetchData<DopesQuery, DopesQueryVariables>(DopesDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteDopesQuery = <
      TData = InfiniteData<DopesQuery>,
      TError = unknown
    >(
      variables: DopesQueryVariables,
      options: Omit<UseInfiniteQueryOptions<DopesQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<DopesQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<DopesQuery, DopesQueryVariables>(DopesDocument)
    return useInfiniteQuery<DopesQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['Dopes.infinite'] : ['Dopes.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const HustlerDocument = `
    query Hustler($where: HustlerWhereInput) {
  hustlers(where: $where) {
    totalCount
    edges {
      node {
        id
        title
        name
        type
        title
        color
        background
        age
        sex
        svg
        viewbox
        order
        neck {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        ring {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        accessory {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        body {
          id
          rle
        }
        hair {
          id
          rle
        }
        beard {
          id
          rle
        }
        drug {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        hand {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        weapon {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        clothes {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        vehicle {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        waist {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
        foot {
          id
          type
          name
          suffix
          augmented
          tier
          greatness
          count
          fullname
          svg
          rles {
            male
            female
          }
          base {
            svg
            rles {
              male
              female
            }
          }
        }
      }
    }
  }
}
    `;

export const useHustlerQuery = <
      TData = HustlerQuery,
      TError = unknown
    >(
      variables?: HustlerQueryVariables,
      options?: Omit<UseQueryOptions<HustlerQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<HustlerQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<HustlerQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['Hustler'] : ['Hustler', variables],
    queryFn: useFetchData<HustlerQuery, HustlerQueryVariables>(HustlerDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteHustlerQuery = <
      TData = InfiniteData<HustlerQuery>,
      TError = unknown
    >(
      variables: HustlerQueryVariables,
      options: Omit<UseInfiniteQueryOptions<HustlerQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<HustlerQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<HustlerQuery, HustlerQueryVariables>(HustlerDocument)
    return useInfiniteQuery<HustlerQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['Hustler.infinite'] : ['Hustler.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const HustlersWalletDocument = `
    query HustlersWallet($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
          title
          name
          type
          color
          background
          age
          svg
        }
      }
    }
  }
}
    `;

export const useHustlersWalletQuery = <
      TData = HustlersWalletQuery,
      TError = unknown
    >(
      variables?: HustlersWalletQueryVariables,
      options?: Omit<UseQueryOptions<HustlersWalletQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<HustlersWalletQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<HustlersWalletQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['HustlersWallet'] : ['HustlersWallet', variables],
    queryFn: useFetchData<HustlersWalletQuery, HustlersWalletQueryVariables>(HustlersWalletDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteHustlersWalletQuery = <
      TData = InfiniteData<HustlersWalletQuery>,
      TError = unknown
    >(
      variables: HustlersWalletQueryVariables,
      options: Omit<UseInfiniteQueryOptions<HustlersWalletQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<HustlersWalletQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<HustlersWalletQuery, HustlersWalletQueryVariables>(HustlersWalletDocument)
    return useInfiniteQuery<HustlersWalletQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['HustlersWallet.infinite'] : ['HustlersWallet.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const ItemDocument = `
    query Item($where: ItemWhereInput) {
  items(where: $where) {
    edges {
      node {
        id
        fullname
        svg
        base {
          svg
        }
      }
    }
  }
}
    `;

export const useItemQuery = <
      TData = ItemQuery,
      TError = unknown
    >(
      variables?: ItemQueryVariables,
      options?: Omit<UseQueryOptions<ItemQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<ItemQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<ItemQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['Item'] : ['Item', variables],
    queryFn: useFetchData<ItemQuery, ItemQueryVariables>(ItemDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteItemQuery = <
      TData = InfiniteData<ItemQuery>,
      TError = unknown
    >(
      variables: ItemQueryVariables,
      options: Omit<UseInfiniteQueryOptions<ItemQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<ItemQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<ItemQuery, ItemQueryVariables>(ItemDocument)
    return useInfiniteQuery<ItemQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['Item.infinite'] : ['Item.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const ProfileDopesDocument = `
    query ProfileDopes($where: DopeWhereInput, $orderBy: DopeOrder, $first: Int, $after: Cursor) {
  dopes(where: $where, first: $first, after: $after, orderBy: $orderBy) {
    totalCount
    edges {
      node {
        id
        id
        rank
        score
        claimed
        opened
        bestAskPriceEth
        items {
          id
          fullname
          type
          name
          tier
          greatness
          count
          suffix
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    `;

export const useProfileDopesQuery = <
      TData = ProfileDopesQuery,
      TError = unknown
    >(
      variables?: ProfileDopesQueryVariables,
      options?: Omit<UseQueryOptions<ProfileDopesQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<ProfileDopesQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<ProfileDopesQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['ProfileDopes'] : ['ProfileDopes', variables],
    queryFn: useFetchData<ProfileDopesQuery, ProfileDopesQueryVariables>(ProfileDopesDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteProfileDopesQuery = <
      TData = InfiniteData<ProfileDopesQuery>,
      TError = unknown
    >(
      variables: ProfileDopesQueryVariables,
      options: Omit<UseInfiniteQueryOptions<ProfileDopesQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<ProfileDopesQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<ProfileDopesQuery, ProfileDopesQueryVariables>(ProfileDopesDocument)
    return useInfiniteQuery<ProfileDopesQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['ProfileDopes.infinite'] : ['ProfileDopes.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const ProfileHustlersDocument = `
    query ProfileHustlers($where: HustlerWhereInput, $orderBy: HustlerOrder, $first: Int, $after: Cursor) {
  hustlers(where: $where, first: $first, after: $after, orderBy: $orderBy) {
    totalCount
    edges {
      node {
        id
        name
        svg
        title
        type
        bestAskPriceEth
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    `;

export const useProfileHustlersQuery = <
      TData = ProfileHustlersQuery,
      TError = unknown
    >(
      variables?: ProfileHustlersQueryVariables,
      options?: Omit<UseQueryOptions<ProfileHustlersQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<ProfileHustlersQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<ProfileHustlersQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['ProfileHustlers'] : ['ProfileHustlers', variables],
    queryFn: useFetchData<ProfileHustlersQuery, ProfileHustlersQueryVariables>(ProfileHustlersDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteProfileHustlersQuery = <
      TData = InfiniteData<ProfileHustlersQuery>,
      TError = unknown
    >(
      variables: ProfileHustlersQueryVariables,
      options: Omit<UseInfiniteQueryOptions<ProfileHustlersQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<ProfileHustlersQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<ProfileHustlersQuery, ProfileHustlersQueryVariables>(ProfileHustlersDocument)
    return useInfiniteQuery<ProfileHustlersQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['ProfileHustlers.infinite'] : ['ProfileHustlers.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const ProfileGearDocument = `
    query ProfileGear($where: WalletItemsWhereInput, $first: Int, $after: Cursor) {
  walletItems(where: $where, first: $first, after: $after) {
    totalCount
    edges {
      node {
        id
        balance
        item {
          bestAskPriceEth
          id
          count
          fullname
          name
          svg
          suffix
          type
          base {
            svg
          }
        }
      }
    }
    pageInfo {
      endCursor
      hasNextPage
    }
  }
}
    `;

export const useProfileGearQuery = <
      TData = ProfileGearQuery,
      TError = unknown
    >(
      variables?: ProfileGearQueryVariables,
      options?: Omit<UseQueryOptions<ProfileGearQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<ProfileGearQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<ProfileGearQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['ProfileGear'] : ['ProfileGear', variables],
    queryFn: useFetchData<ProfileGearQuery, ProfileGearQueryVariables>(ProfileGearDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteProfileGearQuery = <
      TData = InfiniteData<ProfileGearQuery>,
      TError = unknown
    >(
      variables: ProfileGearQueryVariables,
      options: Omit<UseInfiniteQueryOptions<ProfileGearQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<ProfileGearQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<ProfileGearQuery, ProfileGearQueryVariables>(ProfileGearDocument)
    return useInfiniteQuery<ProfileGearQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['ProfileGear.infinite'] : ['ProfileGear.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const RenderDopeDocument = `
    query RenderDope($where: DopeWhereInput) {
  dopes(where: $where) {
    totalCount
    edges {
      cursor
      node {
        id
        items {
          id
          type
          rles {
            female
            male
          }
          base {
            id
            rles {
              female
              male
            }
          }
        }
      }
    }
  }
}
    `;

export const useRenderDopeQuery = <
      TData = RenderDopeQuery,
      TError = unknown
    >(
      variables?: RenderDopeQueryVariables,
      options?: Omit<UseQueryOptions<RenderDopeQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<RenderDopeQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<RenderDopeQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['RenderDope'] : ['RenderDope', variables],
    queryFn: useFetchData<RenderDopeQuery, RenderDopeQueryVariables>(RenderDopeDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteRenderDopeQuery = <
      TData = InfiniteData<RenderDopeQuery>,
      TError = unknown
    >(
      variables: RenderDopeQueryVariables,
      options: Omit<UseInfiniteQueryOptions<RenderDopeQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<RenderDopeQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<RenderDopeQuery, RenderDopeQueryVariables>(RenderDopeDocument)
    return useInfiniteQuery<RenderDopeQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['RenderDope.infinite'] : ['RenderDope.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const SearchDocument = `
    query Search($query: String!, $where: SearchWhereInput, $orderBy: SearchOrder, $first: Int, $last: Int, $before: Cursor, $after: Cursor) {
  search(
    query: $query
    where: $where
    orderBy: $orderBy
    first: $first
    last: $last
    before: $before
    after: $after
  ) {
    totalCount
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    edges {
      node {
        dope {
          __typename
          id
          claimed
          opened
          score
          rank
          bestAskPriceEth
          items {
            id
            fullname
            type
            name
            namePrefix
            nameSuffix
            suffix
            augmented
            tier
            greatness
            count
          }
        }
        hustler {
          __typename
          id
          bestAskPriceEth
          title
          name
          type
          title
          color
          background
          age
          sex
          svg
          neck {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          ring {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          accessory {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          body {
            id
            sex
            type
            rle
          }
          hair {
            id
            sex
            type
            rle
          }
          beard {
            id
            sex
            type
            rle
          }
          drug {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          hand {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          weapon {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          clothes {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          vehicle {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          waist {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
          foot {
            id
            type
            name
            suffix
            augmented
            tier
            greatness
            count
            fullname
          }
        }
        item {
          __typename
          bestAskPriceEth
          id
          fullname
          name
          svg
          type
          suffix
        }
      }
    }
  }
}
    `;

export const useSearchQuery = <
      TData = SearchQuery,
      TError = unknown
    >(
      variables: SearchQueryVariables,
      options?: Omit<UseQueryOptions<SearchQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<SearchQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<SearchQuery, TError, TData>(
      {
    queryKey: ['Search', variables],
    queryFn: useFetchData<SearchQuery, SearchQueryVariables>(SearchDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteSearchQuery = <
      TData = InfiniteData<SearchQuery>,
      TError = unknown
    >(
      variables: SearchQueryVariables,
      options: Omit<UseInfiniteQueryOptions<SearchQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<SearchQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<SearchQuery, SearchQueryVariables>(SearchDocument)
    return useInfiniteQuery<SearchQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? ['Search.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const WalletDocument = `
    query Wallet($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
          title
          name
        }
        items {
          id
          balance
          item {
            id
            name
          }
        }
        dopes {
          id
          claimed
          opened
          score
          rank
          items {
            id
            fullname
            type
            name
            namePrefix
            nameSuffix
            suffix
            augmented
            tier
            greatness
            count
          }
        }
      }
    }
  }
}
    `;

export const useWalletQuery = <
      TData = WalletQuery,
      TError = unknown
    >(
      variables?: WalletQueryVariables,
      options?: Omit<UseQueryOptions<WalletQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<WalletQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<WalletQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['Wallet'] : ['Wallet', variables],
    queryFn: useFetchData<WalletQuery, WalletQueryVariables>(WalletDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteWalletQuery = <
      TData = InfiniteData<WalletQuery>,
      TError = unknown
    >(
      variables: WalletQueryVariables,
      options: Omit<UseInfiniteQueryOptions<WalletQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<WalletQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<WalletQuery, WalletQueryVariables>(WalletDocument)
    return useInfiniteQuery<WalletQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['Wallet.infinite'] : ['Wallet.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};

export const WalletCheckDocument = `
    query WalletCheck($where: WalletWhereInput) {
  wallets(where: $where) {
    edges {
      node {
        id
        paper
        hustlers {
          id
        }
        items {
          id
        }
        dopes {
          id
        }
      }
    }
  }
}
    `;

export const useWalletCheckQuery = <
      TData = WalletCheckQuery,
      TError = unknown
    >(
      variables?: WalletCheckQueryVariables,
      options?: Omit<UseQueryOptions<WalletCheckQuery, TError, TData>, 'queryKey'> & { queryKey?: UseQueryOptions<WalletCheckQuery, TError, TData>['queryKey'] }
    ) => {
    
    return useQuery<WalletCheckQuery, TError, TData>(
      {
    queryKey: variables === undefined ? ['WalletCheck'] : ['WalletCheck', variables],
    queryFn: useFetchData<WalletCheckQuery, WalletCheckQueryVariables>(WalletCheckDocument).bind(null, variables),
    ...options
  }
    )};

export const useInfiniteWalletCheckQuery = <
      TData = InfiniteData<WalletCheckQuery>,
      TError = unknown
    >(
      variables: WalletCheckQueryVariables,
      options: Omit<UseInfiniteQueryOptions<WalletCheckQuery, TError, TData>, 'queryKey'> & { queryKey?: UseInfiniteQueryOptions<WalletCheckQuery, TError, TData>['queryKey'] }
    ) => {
    const query = useFetchData<WalletCheckQuery, WalletCheckQueryVariables>(WalletCheckDocument)
    return useInfiniteQuery<WalletCheckQuery, TError, TData>(
      (() => {
    const { queryKey: optionsQueryKey, ...restOptions } = options;
    return {
      queryKey: optionsQueryKey ?? variables === undefined ? ['WalletCheck.infinite'] : ['WalletCheck.infinite', variables],
      queryFn: (metaData) => query({...variables, ...(metaData.pageParam ?? {})}),
      ...restOptions
    }
  })()
    )};
