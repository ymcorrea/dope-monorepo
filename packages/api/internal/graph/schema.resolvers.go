package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"fmt"
	"strings"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/predicate"
)

// Fullname is the resolver for the fullname field.
func (r *itemResolver) Fullname(ctx context.Context, obj *ent.Item) (string, error) {
	fullname := obj.Name

	if obj.NameSuffix != "" {
		fullname = fmt.Sprintf("%s %s", obj.NameSuffix, fullname)
	}

	if obj.NamePrefix != "" {
		fullname = fmt.Sprintf("%s %s", obj.NamePrefix, fullname)
	}

	if obj.Suffix != "" {
		fullname = fmt.Sprintf("%s %s", fullname, obj.Suffix)
	}

	if obj.Augmented {
		fullname = fmt.Sprintf("%s +1", fullname)
	}

	return fullname, nil
}

// Search is the resolver for the search field.
func (r *queryResolver) Search(ctx context.Context, query string, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.SearchOrder, where *ent.SearchWhereInput) (*ent.SearchConnection, error) {
	var tsquery string

	q := r.client.Search.Query()

	if query != "" {
		parts := strings.Split(query, " ")
		for i, part := range parts {
			tsquery += part + ":*"

			if i != len(parts)-1 {
				tsquery += " & "
			}
		}

		// For text query across item types
		q = q.Where(func(s *sql.Selector) {
			s.From(sql.Table("search_index"))
			s.Where(sql.P(func(b *sql.Builder) {
				b.WriteString(fmt.Sprintf("tsv_document @@ to_tsquery('english', '%s')", tsquery))
			}))
		})
	}

	return q.
		WithDope(func(q *ent.DopeQuery) {
			var predicates []predicate.Dope
			for _, p := range where.HasDopeWith {
				predicates = append(predicates, p.Predicates...)
			}
			if len(predicates) > 0 {
				q.Where(dope.And(predicates...))
			}
		}).
		// Ensure where inputs on item type work for marketplace filtering
		WithItem(func(q *ent.ItemQuery) {
			var predicates []predicate.Item
			for _, p := range where.HasItemWith {
				predicates = append(predicates, p.Predicates...)
			}
			if len(predicates) > 0 {
				q.Where(item.And(predicates...))
			}
		}).
		// And hustlers for id filtering
		WithHustler(func(q *ent.HustlerQuery) {
			var predicates []predicate.Hustler
			for _, p := range where.HasHustlerWith {
				predicates = append(predicates, p.Predicates...)
			}
			if len(predicates) > 0 {
				q.Where(hustler.And(predicates...))
			}
		}).
		Paginate(
			ctx, after, first, before, last, ent.WithSearchOrder(orderBy), ent.WithSearchFilter(where.Filter))
}
