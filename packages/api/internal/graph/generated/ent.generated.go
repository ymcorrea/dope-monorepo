// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/search"
	"github.com/dopedao/dope-monorepo/packages/api/internal/graph/model"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

type EventResolver interface {
	Address(ctx context.Context, obj *ent.Event) (string, error)

	Hash(ctx context.Context, obj *ent.Event) (*model.Hash, error)
}
type GameHustlerResolver interface {
	LastPosition(ctx context.Context, obj *ent.GameHustler) (*model.Position, error)
}
type GameHustlerRelationResolver interface {
	Text(ctx context.Context, obj *ent.GameHustlerRelation) (int, error)
}
type ItemResolver interface {
	Sprite(ctx context.Context, obj *ent.Item) (*model.Sprites, error)

	Fullname(ctx context.Context, obj *ent.Item) (string, error)
}
type QueryResolver interface {
	Node(ctx context.Context, id string) (ent.Noder, error)
	Nodes(ctx context.Context, ids []string) ([]ent.Noder, error)
	BodyParts(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *ent.BodyPartWhereInput) (*ent.BodyPartConnection, error)
	Dopes(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.DopeOrder, where *ent.DopeWhereInput) (*ent.DopeConnection, error)
	Hustlers(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.HustlerOrder, where *ent.HustlerWhereInput) (*ent.HustlerConnection, error)
	Items(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ItemOrder, where *ent.ItemWhereInput) (*ent.ItemConnection, error)
	Wallets(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.WalletOrder, where *ent.WalletWhereInput) (*ent.WalletConnection, error)
	WalletItems(ctx context.Context, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *ent.WalletItemsWhereInput) (*ent.WalletItemsConnection, error)
	Search(ctx context.Context, query string, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.SearchOrder, where *ent.SearchWhereInput) (*ent.SearchConnection, error)
}

type GameHustlerRelationWhereInputResolver interface {
	Text(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextNeq(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextIn(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data []int) error
	TextNotIn(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data []int) error
	TextGt(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextGte(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextLt(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
	TextLte(ctx context.Context, obj *ent.GameHustlerRelationWhereInput, data *int) error
}

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bodyParts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.BodyPartWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_dopes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.DopeOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalODopeOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.DopeWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalODopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_hustlers_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.HustlerOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOHustlerOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.HustlerWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_items_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.ItemOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOItemOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.ItemWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

func (ec *executionContext) field_Query_node_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNID2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_nodes_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["ids"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ids"))
		arg0, err = ec.unmarshalNID2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["ids"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_search_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["query"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("query"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["query"] = arg0
	var arg1 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg1, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg2
	var arg3 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg3, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg3
	var arg4 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg4, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg4
	var arg5 *ent.SearchOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg5, err = ec.unmarshalOSearchOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg5
	var arg6 *ent.SearchWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg6, err = ec.unmarshalOSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg6
	return args, nil
}

func (ec *executionContext) field_Query_walletItems_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.WalletItemsWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg4, err = ec.unmarshalOWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg4
	return args, nil
}

func (ec *executionContext) field_Query_wallets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *entgql.Cursor[string]
	if tmp, ok := rawArgs["after"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("after"))
		arg0, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["after"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["first"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("first"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["first"] = arg1
	var arg2 *entgql.Cursor[string]
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		arg2, err = ec.unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["before"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["last"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("last"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["last"] = arg3
	var arg4 *ent.WalletOrder
	if tmp, ok := rawArgs["orderBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderBy"))
		arg4, err = ec.unmarshalOWalletOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrder(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["orderBy"] = arg4
	var arg5 *ent.WalletWhereInput
	if tmp, ok := rawArgs["where"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("where"))
		arg5, err = ec.unmarshalOWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["where"] = arg5
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _BodyPart_id(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_type(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bodypart.Type)
	fc.Result = res
	return ec.marshalNBodyPartBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BodyPartBodyPartType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_sex(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_sex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bodypart.Sex)
	fc.Result = res
	return ec.marshalNBodyPartBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_sex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BodyPartBodyPartSex does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_rle(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_rle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_rle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_sprite(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_sprite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sprite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_sprite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_hustlerBodies(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_hustlerBodies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerBodies(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_hustlerBodies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_hustlerHairs(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_hustlerHairs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerHairs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_hustlerHairs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPart_hustlerBeards(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPart) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPart_hustlerBeards(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerBeards(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPart_hustlerBeards(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPart",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPartConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPartConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPartConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.BodyPartEdge)
	fc.Result = res
	return ec.marshalOBodyPartEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPartConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPartConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_BodyPartEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_BodyPartEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPartEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPartConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPartConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPartConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPartConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPartConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPartConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPartConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPartConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPartConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPartConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPartEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPartEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPartEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPartEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPartEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			case "sprite":
				return ec.fieldContext_BodyPart_sprite(ctx, field)
			case "hustlerBodies":
				return ec.fieldContext_BodyPart_hustlerBodies(ctx, field)
			case "hustlerHairs":
				return ec.fieldContext_BodyPart_hustlerHairs(ctx, field)
			case "hustlerBeards":
				return ec.fieldContext_BodyPart_hustlerBeards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BodyPartEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.BodyPartEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BodyPartEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BodyPartEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BodyPartEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_id(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_claimed(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_claimed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Claimed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_claimed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_lastCheckedPaperClaim(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_lastCheckedPaperClaim(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCheckedPaperClaim, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_lastCheckedPaperClaim(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_opened(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_opened(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Opened, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_opened(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_lastCheckedGearClaim(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_lastCheckedGearClaim(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCheckedGearClaim, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_lastCheckedGearClaim(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_score(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_score(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Score, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_score(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_rank(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_rank(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rank, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_rank(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_order(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_order(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_bestAskPriceEth(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_bestAskPriceEth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BestAskPriceEth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_bestAskPriceEth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_wallet(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_wallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallet(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_wallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "paper":
				return ec.fieldContext_Wallet_paper(ctx, field)
			case "lastSetPaperBalanceAt":
				return ec.fieldContext_Wallet_lastSetPaperBalanceAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Wallet_createdAt(ctx, field)
			case "dopes":
				return ec.fieldContext_Wallet_dopes(ctx, field)
			case "items":
				return ec.fieldContext_Wallet_items(ctx, field)
			case "hustlers":
				return ec.fieldContext_Wallet_hustlers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_items(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dope_index(ctx context.Context, field graphql.CollectedField, obj *ent.Dope) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dope_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Search)
	fc.Result = res
	return ec.marshalOSearch2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dope_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dope",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Search_id(ctx, field)
			case "type":
				return ec.fieldContext_Search_type(ctx, field)
			case "greatness":
				return ec.fieldContext_Search_greatness(ctx, field)
			case "claimed":
				return ec.fieldContext_Search_claimed(ctx, field)
			case "opened":
				return ec.fieldContext_Search_opened(ctx, field)
			case "banned":
				return ec.fieldContext_Search_banned(ctx, field)
			case "salePrice":
				return ec.fieldContext_Search_salePrice(ctx, field)
			case "dope":
				return ec.fieldContext_Search_dope(ctx, field)
			case "item":
				return ec.fieldContext_Search_item(ctx, field)
			case "hustler":
				return ec.fieldContext_Search_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Search", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.DopeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.DopeEdge)
	fc.Result = res
	return ec.marshalODopeEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_DopeEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_DopeEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DopeEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.DopeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.DopeConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.DopeEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Dope)
	fc.Result = res
	return ec.marshalODope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Dope_id(ctx, field)
			case "claimed":
				return ec.fieldContext_Dope_claimed(ctx, field)
			case "lastCheckedPaperClaim":
				return ec.fieldContext_Dope_lastCheckedPaperClaim(ctx, field)
			case "opened":
				return ec.fieldContext_Dope_opened(ctx, field)
			case "lastCheckedGearClaim":
				return ec.fieldContext_Dope_lastCheckedGearClaim(ctx, field)
			case "score":
				return ec.fieldContext_Dope_score(ctx, field)
			case "rank":
				return ec.fieldContext_Dope_rank(ctx, field)
			case "order":
				return ec.fieldContext_Dope_order(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Dope_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Dope_wallet(ctx, field)
			case "items":
				return ec.fieldContext_Dope_items(ctx, field)
			case "index":
				return ec.fieldContext_Dope_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dope", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DopeEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.DopeEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DopeEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DopeEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DopeEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_id(ctx context.Context, field graphql.CollectedField, obj *ent.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_address(ctx context.Context, field graphql.CollectedField, obj *ent.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_address(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Address(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNAddress2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_address(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Address does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_index(ctx context.Context, field graphql.CollectedField, obj *ent.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_hash(ctx context.Context, field graphql.CollectedField, obj *ent.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_hash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Event().Hash(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Hash)
	fc.Result = res
	return ec.marshalNHash2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐHash(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_hash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "value":
				return ec.fieldContext_Hash_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hash", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Event_updatedAt(ctx context.Context, field graphql.CollectedField, obj *ent.Event) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Event_updatedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UpdatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Event_updatedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Event",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustler_id(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustler_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustler_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustler_lastPosition(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustler_lastPosition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GameHustler().LastPosition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.Position)
	fc.Result = res
	return ec.marshalNPosition2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐPosition(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustler_lastPosition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "currentMap":
				return ec.fieldContext_Position_currentMap(ctx, field)
			case "x":
				return ec.fieldContext_Position_x(ctx, field)
			case "y":
				return ec.fieldContext_Position_y(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Position", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustler_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustler_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustler_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustler_relations(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustler_relations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Relations(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GameHustlerRelation)
	fc.Result = res
	return ec.marshalOGameHustlerRelation2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustler_relations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameHustlerRelation_id(ctx, field)
			case "citizen":
				return ec.fieldContext_GameHustlerRelation_citizen(ctx, field)
			case "conversation":
				return ec.fieldContext_GameHustlerRelation_conversation(ctx, field)
			case "text":
				return ec.fieldContext_GameHustlerRelation_text(ctx, field)
			case "hustler":
				return ec.fieldContext_GameHustlerRelation_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameHustlerRelation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustler_items(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustler_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GameHustlerItem)
	fc.Result = res
	return ec.marshalOGameHustlerItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustler_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameHustlerItem_id(ctx, field)
			case "item":
				return ec.fieldContext_GameHustlerItem_item(ctx, field)
			case "hustler":
				return ec.fieldContext_GameHustlerItem_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameHustlerItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustler_quests(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustler_quests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quests(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.GameHustlerQuest)
	fc.Result = res
	return ec.marshalOGameHustlerQuest2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustler_quests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameHustlerQuest_id(ctx, field)
			case "quest":
				return ec.fieldContext_GameHustlerQuest_quest(ctx, field)
			case "completed":
				return ec.fieldContext_GameHustlerQuest_completed(ctx, field)
			case "hustler":
				return ec.fieldContext_GameHustlerQuest_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameHustlerQuest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerItem_id(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerItem_item(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerItem_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerItem_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerItem_hustler(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerItem_hustler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hustler(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GameHustler)
	fc.Result = res
	return ec.marshalOGameHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerItem_hustler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameHustler_id(ctx, field)
			case "lastPosition":
				return ec.fieldContext_GameHustler_lastPosition(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameHustler_createdAt(ctx, field)
			case "relations":
				return ec.fieldContext_GameHustler_relations(ctx, field)
			case "items":
				return ec.fieldContext_GameHustler_items(ctx, field)
			case "quests":
				return ec.fieldContext_GameHustler_quests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameHustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerQuest_id(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerQuest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerQuest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerQuest_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerQuest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerQuest_quest(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerQuest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerQuest_quest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Quest, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerQuest_quest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerQuest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerQuest_completed(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerQuest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerQuest_completed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Completed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerQuest_completed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerQuest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerQuest_hustler(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerQuest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerQuest_hustler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hustler(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GameHustler)
	fc.Result = res
	return ec.marshalOGameHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerQuest_hustler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerQuest",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameHustler_id(ctx, field)
			case "lastPosition":
				return ec.fieldContext_GameHustler_lastPosition(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameHustler_createdAt(ctx, field)
			case "relations":
				return ec.fieldContext_GameHustler_relations(ctx, field)
			case "items":
				return ec.fieldContext_GameHustler_items(ctx, field)
			case "quests":
				return ec.fieldContext_GameHustler_quests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameHustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerRelation_id(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerRelation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerRelation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerRelation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerRelation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerRelation_citizen(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerRelation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerRelation_citizen(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Citizen, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerRelation_citizen(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerRelation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerRelation_conversation(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerRelation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerRelation_conversation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Conversation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerRelation_conversation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerRelation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerRelation_text(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerRelation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerRelation_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.GameHustlerRelation().Text(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerRelation_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerRelation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GameHustlerRelation_hustler(ctx context.Context, field graphql.CollectedField, obj *ent.GameHustlerRelation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GameHustlerRelation_hustler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hustler(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.GameHustler)
	fc.Result = res
	return ec.marshalOGameHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GameHustlerRelation_hustler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GameHustlerRelation",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GameHustler_id(ctx, field)
			case "lastPosition":
				return ec.fieldContext_GameHustler_lastPosition(ctx, field)
			case "createdAt":
				return ec.fieldContext_GameHustler_createdAt(ctx, field)
			case "relations":
				return ec.fieldContext_GameHustler_relations(ctx, field)
			case "items":
				return ec.fieldContext_GameHustler_items(ctx, field)
			case "quests":
				return ec.fieldContext_GameHustler_quests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GameHustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_id(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_type(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(hustler.Type)
	fc.Result = res
	return ec.marshalNHustlerHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HustlerHustlerType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_name(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_title(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_title(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Title, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_title(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_color(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_color(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Color, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_color(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_background(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_background(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Background, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_background(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_age(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_age(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Age, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_age(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_sex(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_sex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Sex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(hustler.Sex)
	fc.Result = res
	return ec.marshalNHustlerHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_sex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HustlerHustlerSex does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_viewbox(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_viewbox(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Viewbox, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_viewbox(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_order(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_order(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_svg(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_svg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Svg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_svg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_bestAskPriceEth(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BestAskPriceEth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_bestAskPriceEth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_wallet(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_wallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallet(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_wallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "paper":
				return ec.fieldContext_Wallet_paper(ctx, field)
			case "lastSetPaperBalanceAt":
				return ec.fieldContext_Wallet_lastSetPaperBalanceAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Wallet_createdAt(ctx, field)
			case "dopes":
				return ec.fieldContext_Wallet_dopes(ctx, field)
			case "items":
				return ec.fieldContext_Wallet_items(ctx, field)
			case "hustlers":
				return ec.fieldContext_Wallet_hustlers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_weapon(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_weapon(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Weapon(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_weapon(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_clothes(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_clothes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Clothes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_clothes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_vehicle(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_vehicle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vehicle(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_vehicle(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_waist(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_waist(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Waist(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_waist(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_foot(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_foot(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Foot(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_foot(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_hand(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_hand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hand(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_hand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_drug(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_drug(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Drug(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_drug(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_neck(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_neck(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Neck(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_neck(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_ring(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_ring(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ring(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_ring(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_accessory(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_accessory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Accessory(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_accessory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_body(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_body(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Body(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_body(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			case "sprite":
				return ec.fieldContext_BodyPart_sprite(ctx, field)
			case "hustlerBodies":
				return ec.fieldContext_BodyPart_hustlerBodies(ctx, field)
			case "hustlerHairs":
				return ec.fieldContext_BodyPart_hustlerHairs(ctx, field)
			case "hustlerBeards":
				return ec.fieldContext_BodyPart_hustlerBeards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_hair(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_hair(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hair(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_hair(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			case "sprite":
				return ec.fieldContext_BodyPart_sprite(ctx, field)
			case "hustlerBodies":
				return ec.fieldContext_BodyPart_hustlerBodies(ctx, field)
			case "hustlerHairs":
				return ec.fieldContext_BodyPart_hustlerHairs(ctx, field)
			case "hustlerBeards":
				return ec.fieldContext_BodyPart_hustlerBeards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_beard(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_beard(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Beard(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPart)
	fc.Result = res
	return ec.marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_beard(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_BodyPart_id(ctx, field)
			case "type":
				return ec.fieldContext_BodyPart_type(ctx, field)
			case "sex":
				return ec.fieldContext_BodyPart_sex(ctx, field)
			case "rle":
				return ec.fieldContext_BodyPart_rle(ctx, field)
			case "sprite":
				return ec.fieldContext_BodyPart_sprite(ctx, field)
			case "hustlerBodies":
				return ec.fieldContext_BodyPart_hustlerBodies(ctx, field)
			case "hustlerHairs":
				return ec.fieldContext_BodyPart_hustlerHairs(ctx, field)
			case "hustlerBeards":
				return ec.fieldContext_BodyPart_hustlerBeards(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPart", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Hustler_index(ctx context.Context, field graphql.CollectedField, obj *ent.Hustler) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Hustler_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Search)
	fc.Result = res
	return ec.marshalOSearch2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Hustler_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Hustler",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Search_id(ctx, field)
			case "type":
				return ec.fieldContext_Search_type(ctx, field)
			case "greatness":
				return ec.fieldContext_Search_greatness(ctx, field)
			case "claimed":
				return ec.fieldContext_Search_claimed(ctx, field)
			case "opened":
				return ec.fieldContext_Search_opened(ctx, field)
			case "banned":
				return ec.fieldContext_Search_banned(ctx, field)
			case "salePrice":
				return ec.fieldContext_Search_salePrice(ctx, field)
			case "dope":
				return ec.fieldContext_Search_dope(ctx, field)
			case "item":
				return ec.fieldContext_Search_item(ctx, field)
			case "hustler":
				return ec.fieldContext_Search_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Search", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.HustlerEdge)
	fc.Result = res
	return ec.marshalOHustlerEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_HustlerEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_HustlerEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HustlerEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HustlerEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.HustlerEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HustlerEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HustlerEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HustlerEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_id(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_type(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(item.Type)
	fc.Result = res
	return ec.marshalNItemItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_namePrefix(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_namePrefix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NamePrefix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_namePrefix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_nameSuffix(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_nameSuffix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NameSuffix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_nameSuffix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_name(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_suffix(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_suffix(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Suffix, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_suffix(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_augmented(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_augmented(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Augmented, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_augmented(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_count(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_tier(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_tier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(item.Tier)
	fc.Result = res
	return ec.marshalOItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_tier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ItemItemTier does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_greatness(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_greatness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Greatness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_greatness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_rles(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_rles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Rles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(schema.RLEs)
	fc.Result = res
	return ec.marshalORLEs2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐRLEs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_rles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "female":
				return ec.fieldContext_RLEs_female(ctx, field)
			case "male":
				return ec.fieldContext_RLEs_male(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RLEs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_svg(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_svg(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Svg, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_svg(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_sprite(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_sprite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Item().Sprite(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.Sprites)
	fc.Result = res
	return ec.marshalOSprites2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋgraphᚋmodelᚐSprites(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_sprite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "Female":
				return ec.fieldContext_Sprites_Female(ctx, field)
			case "Male":
				return ec.fieldContext_Sprites_Male(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Sprites", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_bestAskPriceEth(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_bestAskPriceEth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BestAskPriceEth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_bestAskPriceEth(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_wallets(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallets(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletItems)
	fc.Result = res
	return ec.marshalOWalletItems2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_wallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WalletItems_id(ctx, field)
			case "balance":
				return ec.fieldContext_WalletItems_balance(ctx, field)
			case "wallet":
				return ec.fieldContext_WalletItems_wallet(ctx, field)
			case "item":
				return ec.fieldContext_WalletItems_item(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItems", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_dopes(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_dopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dopes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Dope)
	fc.Result = res
	return ec.marshalODope2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_dopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Dope_id(ctx, field)
			case "claimed":
				return ec.fieldContext_Dope_claimed(ctx, field)
			case "lastCheckedPaperClaim":
				return ec.fieldContext_Dope_lastCheckedPaperClaim(ctx, field)
			case "opened":
				return ec.fieldContext_Dope_opened(ctx, field)
			case "lastCheckedGearClaim":
				return ec.fieldContext_Dope_lastCheckedGearClaim(ctx, field)
			case "score":
				return ec.fieldContext_Dope_score(ctx, field)
			case "rank":
				return ec.fieldContext_Dope_rank(ctx, field)
			case "order":
				return ec.fieldContext_Dope_order(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Dope_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Dope_wallet(ctx, field)
			case "items":
				return ec.fieldContext_Dope_items(ctx, field)
			case "index":
				return ec.fieldContext_Dope_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dope", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerWeapons(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerWeapons(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerWeapons(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerWeapons(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerClothes(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerClothes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerClothes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerClothes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerVehicles(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerVehicles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerVehicles(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerVehicles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerWaists(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerWaists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerWaists(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerWaists(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerFeet(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerFeet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerFeet(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerFeet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerHands(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerHands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerHands(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerHands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerDrugs(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerDrugs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerDrugs(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerDrugs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerNecks(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerNecks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerNecks(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerNecks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerRings(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerRings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerRings(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerRings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_hustlerAccessories(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_hustlerAccessories(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HustlerAccessories(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_hustlerAccessories(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_base(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_base(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Base(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_base(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_derivative(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_derivative(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Derivative(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_derivative(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_index(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_index(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Index(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Search)
	fc.Result = res
	return ec.marshalOSearch2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_index(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Search_id(ctx, field)
			case "type":
				return ec.fieldContext_Search_type(ctx, field)
			case "greatness":
				return ec.fieldContext_Search_greatness(ctx, field)
			case "claimed":
				return ec.fieldContext_Search_claimed(ctx, field)
			case "opened":
				return ec.fieldContext_Search_opened(ctx, field)
			case "banned":
				return ec.fieldContext_Search_banned(ctx, field)
			case "salePrice":
				return ec.fieldContext_Search_salePrice(ctx, field)
			case "dope":
				return ec.fieldContext_Search_dope(ctx, field)
			case "item":
				return ec.fieldContext_Search_item(ctx, field)
			case "hustler":
				return ec.fieldContext_Search_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Search", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Item_fullname(ctx context.Context, field graphql.CollectedField, obj *ent.Item) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Item_fullname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Item().Fullname(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Item_fullname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Item",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.ItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.ItemEdge)
	fc.Result = res
	return ec.marshalOItemEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_ItemEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_ItemEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.ItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.ItemConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.ItemEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ItemEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.ItemEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ItemEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ItemEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ItemEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasNextPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPreviousPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_hasPreviousPage(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_startCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_startCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[string])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_startCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PageInfo_endCursor(ctx context.Context, field graphql.CollectedField, obj *entgql.PageInfo[string]) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PageInfo_endCursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndCursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*entgql.Cursor[string])
	fc.Result = res
	return ec.marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PageInfo_endCursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PageInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_node(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Node(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(ent.Noder)
	fc.Result = res
	return ec.marshalONode2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_node_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_nodes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_nodes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Nodes(rctx, fc.Args["ids"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]ent.Noder)
	fc.Result = res
	return ec.marshalNNode2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_nodes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("FieldContext.Child cannot be called on type INTERFACE")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_nodes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_bodyParts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bodyParts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BodyParts(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*ent.BodyPartWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.BodyPartConnection)
	fc.Result = res
	return ec.marshalNBodyPartConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bodyParts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_BodyPartConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_BodyPartConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_BodyPartConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BodyPartConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bodyParts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_dopes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_dopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Dopes(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.DopeOrder), fc.Args["where"].(*ent.DopeWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.DopeConnection)
	fc.Result = res
	return ec.marshalNDopeConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_dopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_DopeConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_DopeConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_DopeConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DopeConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_dopes_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hustlers(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hustlers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hustlers(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.HustlerOrder), fc.Args["where"].(*ent.HustlerWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.HustlerConnection)
	fc.Result = res
	return ec.marshalNHustlerConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hustlers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_HustlerConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_HustlerConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_HustlerConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HustlerConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hustlers_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_items(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Items(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.ItemOrder), fc.Args["where"].(*ent.ItemWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.ItemConnection)
	fc.Result = res
	return ec.marshalNItemConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_ItemConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_ItemConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_ItemConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ItemConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_items_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_wallets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_wallets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Wallets(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.WalletOrder), fc.Args["where"].(*ent.WalletWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.WalletConnection)
	fc.Result = res
	return ec.marshalNWalletConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_wallets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_WalletConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_WalletConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_WalletConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_wallets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_walletItems(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_walletItems(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().WalletItems(rctx, fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["where"].(*ent.WalletItemsWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.WalletItemsConnection)
	fc.Result = res
	return ec.marshalNWalletItemsConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_walletItems(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_WalletItemsConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_WalletItemsConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_WalletItemsConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItemsConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_walletItems_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_search(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Search(rctx, fc.Args["query"].(string), fc.Args["after"].(*entgql.Cursor[string]), fc.Args["first"].(*int), fc.Args["before"].(*entgql.Cursor[string]), fc.Args["last"].(*int), fc.Args["orderBy"].(*ent.SearchOrder), fc.Args["where"].(*ent.SearchWhereInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ent.SearchConnection)
	fc.Result = res
	return ec.marshalNSearchConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchConnection(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edges":
				return ec.fieldContext_SearchConnection_edges(ctx, field)
			case "pageInfo":
				return ec.fieldContext_SearchConnection_pageInfo(ctx, field)
			case "totalCount":
				return ec.fieldContext_SearchConnection_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchConnection", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_search_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_id(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_type(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(search.Type)
	fc.Result = res
	return ec.marshalNSearchSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type SearchSearchType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_greatness(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_greatness(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Greatness, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_greatness(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_claimed(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_claimed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Claimed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_claimed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_opened(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_opened(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Opened, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_opened(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_banned(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_banned(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banned, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_banned(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_salePrice(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_salePrice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SalePrice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_salePrice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_dope(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_dope(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dope(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Dope)
	fc.Result = res
	return ec.marshalODope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_dope(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Dope_id(ctx, field)
			case "claimed":
				return ec.fieldContext_Dope_claimed(ctx, field)
			case "lastCheckedPaperClaim":
				return ec.fieldContext_Dope_lastCheckedPaperClaim(ctx, field)
			case "opened":
				return ec.fieldContext_Dope_opened(ctx, field)
			case "lastCheckedGearClaim":
				return ec.fieldContext_Dope_lastCheckedGearClaim(ctx, field)
			case "score":
				return ec.fieldContext_Dope_score(ctx, field)
			case "rank":
				return ec.fieldContext_Dope_rank(ctx, field)
			case "order":
				return ec.fieldContext_Dope_order(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Dope_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Dope_wallet(ctx, field)
			case "items":
				return ec.fieldContext_Dope_items(ctx, field)
			case "index":
				return ec.fieldContext_Dope_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dope", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_item(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Search_hustler(ctx context.Context, field graphql.CollectedField, obj *ent.Search) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Search_hustler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hustler(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Search_hustler(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Search",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.SearchConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.SearchEdge)
	fc.Result = res
	return ec.marshalOSearchEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_SearchEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_SearchEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.SearchConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.SearchConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.SearchEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Search)
	fc.Result = res
	return ec.marshalOSearch2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Search_id(ctx, field)
			case "type":
				return ec.fieldContext_Search_type(ctx, field)
			case "greatness":
				return ec.fieldContext_Search_greatness(ctx, field)
			case "claimed":
				return ec.fieldContext_Search_claimed(ctx, field)
			case "opened":
				return ec.fieldContext_Search_opened(ctx, field)
			case "banned":
				return ec.fieldContext_Search_banned(ctx, field)
			case "salePrice":
				return ec.fieldContext_Search_salePrice(ctx, field)
			case "dope":
				return ec.fieldContext_Search_dope(ctx, field)
			case "item":
				return ec.fieldContext_Search_item(ctx, field)
			case "hustler":
				return ec.fieldContext_Search_hustler(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Search", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.SearchEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncState_id(ctx context.Context, field graphql.CollectedField, obj *ent.SyncState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncState_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncState_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncState_contractName(ctx context.Context, field graphql.CollectedField, obj *ent.SyncState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncState_contractName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContractName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncState_contractName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncState_startBlock(ctx context.Context, field graphql.CollectedField, obj *ent.SyncState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncState_startBlock(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartBlock, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(uint64)
	fc.Result = res
	return ec.marshalNLong2uint64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncState_startBlock(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Long does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncState_blockTime(ctx context.Context, field graphql.CollectedField, obj *ent.SyncState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncState_blockTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncState_blockTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SyncState_lastSyncedAt(ctx context.Context, field graphql.CollectedField, obj *ent.SyncState) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SyncState_lastSyncedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSyncedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SyncState_lastSyncedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SyncState",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_id(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_paper(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_paper(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Paper, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(schema.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_paper(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_lastSetPaperBalanceAt(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_lastSetPaperBalanceAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastSetPaperBalanceAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_lastSetPaperBalanceAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_createdAt(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_createdAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_createdAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_dopes(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_dopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Dopes(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Dope)
	fc.Result = res
	return ec.marshalODope2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_dopes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Dope_id(ctx, field)
			case "claimed":
				return ec.fieldContext_Dope_claimed(ctx, field)
			case "lastCheckedPaperClaim":
				return ec.fieldContext_Dope_lastCheckedPaperClaim(ctx, field)
			case "opened":
				return ec.fieldContext_Dope_opened(ctx, field)
			case "lastCheckedGearClaim":
				return ec.fieldContext_Dope_lastCheckedGearClaim(ctx, field)
			case "score":
				return ec.fieldContext_Dope_score(ctx, field)
			case "rank":
				return ec.fieldContext_Dope_rank(ctx, field)
			case "order":
				return ec.fieldContext_Dope_order(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Dope_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Dope_wallet(ctx, field)
			case "items":
				return ec.fieldContext_Dope_items(ctx, field)
			case "index":
				return ec.fieldContext_Dope_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dope", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_items(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_items(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Items(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletItems)
	fc.Result = res
	return ec.marshalOWalletItems2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_items(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WalletItems_id(ctx, field)
			case "balance":
				return ec.fieldContext_WalletItems_balance(ctx, field)
			case "wallet":
				return ec.fieldContext_WalletItems_wallet(ctx, field)
			case "item":
				return ec.fieldContext_WalletItems_item(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItems", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Wallet_hustlers(ctx context.Context, field graphql.CollectedField, obj *ent.Wallet) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Wallet_hustlers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hustlers(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.Hustler)
	fc.Result = res
	return ec.marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Wallet_hustlers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Wallet",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Hustler_id(ctx, field)
			case "type":
				return ec.fieldContext_Hustler_type(ctx, field)
			case "name":
				return ec.fieldContext_Hustler_name(ctx, field)
			case "title":
				return ec.fieldContext_Hustler_title(ctx, field)
			case "color":
				return ec.fieldContext_Hustler_color(ctx, field)
			case "background":
				return ec.fieldContext_Hustler_background(ctx, field)
			case "age":
				return ec.fieldContext_Hustler_age(ctx, field)
			case "sex":
				return ec.fieldContext_Hustler_sex(ctx, field)
			case "viewbox":
				return ec.fieldContext_Hustler_viewbox(ctx, field)
			case "order":
				return ec.fieldContext_Hustler_order(ctx, field)
			case "svg":
				return ec.fieldContext_Hustler_svg(ctx, field)
			case "createdAt":
				return ec.fieldContext_Hustler_createdAt(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Hustler_bestAskPriceEth(ctx, field)
			case "wallet":
				return ec.fieldContext_Hustler_wallet(ctx, field)
			case "weapon":
				return ec.fieldContext_Hustler_weapon(ctx, field)
			case "clothes":
				return ec.fieldContext_Hustler_clothes(ctx, field)
			case "vehicle":
				return ec.fieldContext_Hustler_vehicle(ctx, field)
			case "waist":
				return ec.fieldContext_Hustler_waist(ctx, field)
			case "foot":
				return ec.fieldContext_Hustler_foot(ctx, field)
			case "hand":
				return ec.fieldContext_Hustler_hand(ctx, field)
			case "drug":
				return ec.fieldContext_Hustler_drug(ctx, field)
			case "neck":
				return ec.fieldContext_Hustler_neck(ctx, field)
			case "ring":
				return ec.fieldContext_Hustler_ring(ctx, field)
			case "accessory":
				return ec.fieldContext_Hustler_accessory(ctx, field)
			case "body":
				return ec.fieldContext_Hustler_body(ctx, field)
			case "hair":
				return ec.fieldContext_Hustler_hair(ctx, field)
			case "beard":
				return ec.fieldContext_Hustler_beard(ctx, field)
			case "index":
				return ec.fieldContext_Hustler_index(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Hustler", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.WalletConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletEdge)
	fc.Result = res
	return ec.marshalOWalletEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_WalletEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_WalletEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.WalletConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.WalletConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.WalletEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "paper":
				return ec.fieldContext_Wallet_paper(ctx, field)
			case "lastSetPaperBalanceAt":
				return ec.fieldContext_Wallet_lastSetPaperBalanceAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Wallet_createdAt(ctx, field)
			case "dopes":
				return ec.fieldContext_Wallet_dopes(ctx, field)
			case "items":
				return ec.fieldContext_Wallet_items(ctx, field)
			case "hustlers":
				return ec.fieldContext_Wallet_hustlers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.WalletEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_id(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_balance(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_balance(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Balance, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(schema.BigInt)
	fc.Result = res
	return ec.marshalNBigInt2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_balance(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BigInt does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_wallet(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_wallet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Wallet(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Wallet)
	fc.Result = res
	return ec.marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_wallet(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Wallet_id(ctx, field)
			case "paper":
				return ec.fieldContext_Wallet_paper(ctx, field)
			case "lastSetPaperBalanceAt":
				return ec.fieldContext_Wallet_lastSetPaperBalanceAt(ctx, field)
			case "createdAt":
				return ec.fieldContext_Wallet_createdAt(ctx, field)
			case "dopes":
				return ec.fieldContext_Wallet_dopes(ctx, field)
			case "items":
				return ec.fieldContext_Wallet_items(ctx, field)
			case "hustlers":
				return ec.fieldContext_Wallet_hustlers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Wallet", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItems_item(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItems) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItems_item(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Item(ctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.Item)
	fc.Result = res
	return ec.marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItems_item(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItems",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Item_id(ctx, field)
			case "type":
				return ec.fieldContext_Item_type(ctx, field)
			case "namePrefix":
				return ec.fieldContext_Item_namePrefix(ctx, field)
			case "nameSuffix":
				return ec.fieldContext_Item_nameSuffix(ctx, field)
			case "name":
				return ec.fieldContext_Item_name(ctx, field)
			case "suffix":
				return ec.fieldContext_Item_suffix(ctx, field)
			case "augmented":
				return ec.fieldContext_Item_augmented(ctx, field)
			case "count":
				return ec.fieldContext_Item_count(ctx, field)
			case "tier":
				return ec.fieldContext_Item_tier(ctx, field)
			case "greatness":
				return ec.fieldContext_Item_greatness(ctx, field)
			case "rles":
				return ec.fieldContext_Item_rles(ctx, field)
			case "svg":
				return ec.fieldContext_Item_svg(ctx, field)
			case "sprite":
				return ec.fieldContext_Item_sprite(ctx, field)
			case "bestAskPriceEth":
				return ec.fieldContext_Item_bestAskPriceEth(ctx, field)
			case "wallets":
				return ec.fieldContext_Item_wallets(ctx, field)
			case "dopes":
				return ec.fieldContext_Item_dopes(ctx, field)
			case "hustlerWeapons":
				return ec.fieldContext_Item_hustlerWeapons(ctx, field)
			case "hustlerClothes":
				return ec.fieldContext_Item_hustlerClothes(ctx, field)
			case "hustlerVehicles":
				return ec.fieldContext_Item_hustlerVehicles(ctx, field)
			case "hustlerWaists":
				return ec.fieldContext_Item_hustlerWaists(ctx, field)
			case "hustlerFeet":
				return ec.fieldContext_Item_hustlerFeet(ctx, field)
			case "hustlerHands":
				return ec.fieldContext_Item_hustlerHands(ctx, field)
			case "hustlerDrugs":
				return ec.fieldContext_Item_hustlerDrugs(ctx, field)
			case "hustlerNecks":
				return ec.fieldContext_Item_hustlerNecks(ctx, field)
			case "hustlerRings":
				return ec.fieldContext_Item_hustlerRings(ctx, field)
			case "hustlerAccessories":
				return ec.fieldContext_Item_hustlerAccessories(ctx, field)
			case "base":
				return ec.fieldContext_Item_base(ctx, field)
			case "derivative":
				return ec.fieldContext_Item_derivative(ctx, field)
			case "index":
				return ec.fieldContext_Item_index(ctx, field)
			case "fullname":
				return ec.fieldContext_Item_fullname(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Item", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsConnection_edges(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsConnection_edges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*ent.WalletItemsEdge)
	fc.Result = res
	return ec.marshalOWalletItemsEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsConnection_edges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "node":
				return ec.fieldContext_WalletItemsEdge_node(ctx, field)
			case "cursor":
				return ec.fieldContext_WalletItemsEdge_cursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItemsEdge", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsConnection_pageInfo(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsConnection_pageInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PageInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.PageInfo[string])
	fc.Result = res
	return ec.marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsConnection_pageInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasNextPage":
				return ec.fieldContext_PageInfo_hasNextPage(ctx, field)
			case "hasPreviousPage":
				return ec.fieldContext_PageInfo_hasPreviousPage(ctx, field)
			case "startCursor":
				return ec.fieldContext_PageInfo_startCursor(ctx, field)
			case "endCursor":
				return ec.fieldContext_PageInfo_endCursor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PageInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsConnection_totalCount(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsConnection) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsConnection_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsConnection_totalCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsConnection",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsEdge_node(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsEdge_node(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Node, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*ent.WalletItems)
	fc.Result = res
	return ec.marshalOWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsEdge_node(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WalletItems_id(ctx, field)
			case "balance":
				return ec.fieldContext_WalletItems_balance(ctx, field)
			case "wallet":
				return ec.fieldContext_WalletItems_wallet(ctx, field)
			case "item":
				return ec.fieldContext_WalletItems_item(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WalletItems", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WalletItemsEdge_cursor(ctx context.Context, field graphql.CollectedField, obj *ent.WalletItemsEdge) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WalletItemsEdge_cursor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cursor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(entgql.Cursor[string])
	fc.Result = res
	return ec.marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WalletItemsEdge_cursor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WalletItemsEdge",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Cursor does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBodyPartWhereInput(ctx context.Context, obj interface{}) (ent.BodyPartWhereInput, error) {
	var it ent.BodyPartWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "sex", "sexNEQ", "sexIn", "sexNotIn", "rle", "rleNEQ", "rleIn", "rleNotIn", "rleGT", "rleGTE", "rleLT", "rleLTE", "rleContains", "rleHasPrefix", "rleHasSuffix", "rleEqualFold", "rleContainsFold", "sprite", "spriteNEQ", "spriteIn", "spriteNotIn", "spriteGT", "spriteGTE", "spriteLT", "spriteLTE", "spriteContains", "spriteHasPrefix", "spriteHasSuffix", "spriteIsNil", "spriteNotNil", "spriteEqualFold", "spriteContainsFold", "hasHustlerBodies", "hasHustlerBodiesWith", "hasHustlerHairs", "hasHustlerHairsWith", "hasHustlerBeards", "hasHustlerBeardsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOBodyPartBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOBodyPartBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOBodyPartBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOBodyPartBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "sex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sex"))
			data, err := ec.unmarshalOBodyPartBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sex = data
		case "sexNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNEQ"))
			data, err := ec.unmarshalOBodyPartBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
			it.SexNEQ = data
		case "sexIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexIn"))
			data, err := ec.unmarshalOBodyPartBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SexIn = data
		case "sexNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNotIn"))
			data, err := ec.unmarshalOBodyPartBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SexNotIn = data
		case "rle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rle"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rle = data
		case "rleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleNEQ = data
		case "rleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleIn = data
		case "rleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleNotIn = data
		case "rleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleGT = data
		case "rleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleGTE = data
		case "rleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleLT = data
		case "rleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleLTE = data
		case "rleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleContains = data
		case "rleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleHasPrefix = data
		case "rleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleHasSuffix = data
		case "rleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleEqualFold = data
		case "rleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rleContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RleContainsFold = data
		case "sprite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sprite"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sprite = data
		case "spriteNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteNEQ = data
		case "spriteIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteIn = data
		case "spriteNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteNotIn = data
		case "spriteGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteGT = data
		case "spriteGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteGTE = data
		case "spriteLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteLT = data
		case "spriteLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteLTE = data
		case "spriteContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteContains = data
		case "spriteHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteHasPrefix = data
		case "spriteHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteHasSuffix = data
		case "spriteIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteIsNil = data
		case "spriteNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteNotNil = data
		case "spriteEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteEqualFold = data
		case "spriteContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spriteContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpriteContainsFold = data
		case "hasHustlerBodies":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBodies"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerBodies = data
		case "hasHustlerBodiesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBodiesWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerBodiesWith = data
		case "hasHustlerHairs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHairs"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerHairs = data
		case "hasHustlerHairsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHairsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerHairsWith = data
		case "hasHustlerBeards":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBeards"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerBeards = data
		case "hasHustlerBeardsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerBeardsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerBeardsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDopeOrder(ctx context.Context, obj interface{}) (ent.DopeOrder, error) {
	var it ent.DopeOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNDopeOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDopeWhereInput(ctx context.Context, obj interface{}) (ent.DopeWhereInput, error) {
	var it ent.DopeWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "claimed", "claimedNEQ", "lastCheckedPaperClaim", "lastCheckedPaperClaimNEQ", "lastCheckedPaperClaimIn", "lastCheckedPaperClaimNotIn", "lastCheckedPaperClaimGT", "lastCheckedPaperClaimGTE", "lastCheckedPaperClaimLT", "lastCheckedPaperClaimLTE", "lastCheckedPaperClaimIsNil", "lastCheckedPaperClaimNotNil", "opened", "openedNEQ", "lastCheckedGearClaim", "lastCheckedGearClaimNEQ", "lastCheckedGearClaimIn", "lastCheckedGearClaimNotIn", "lastCheckedGearClaimGT", "lastCheckedGearClaimGTE", "lastCheckedGearClaimLT", "lastCheckedGearClaimLTE", "lastCheckedGearClaimIsNil", "lastCheckedGearClaimNotNil", "score", "scoreNEQ", "scoreIn", "scoreNotIn", "scoreGT", "scoreGTE", "scoreLT", "scoreLTE", "scoreIsNil", "scoreNotNil", "rank", "rankNEQ", "rankIn", "rankNotIn", "rankGT", "rankGTE", "rankLT", "rankLTE", "rankIsNil", "rankNotNil", "order", "orderNEQ", "orderIn", "orderNotIn", "orderGT", "orderGTE", "orderLT", "orderLTE", "bestAskPriceEth", "bestAskPriceEthNEQ", "bestAskPriceEthIn", "bestAskPriceEthNotIn", "bestAskPriceEthGT", "bestAskPriceEthGTE", "bestAskPriceEthLT", "bestAskPriceEthLTE", "bestAskPriceEthIsNil", "bestAskPriceEthNotNil", "hasWallet", "hasWalletWith", "hasItems", "hasItemsWith", "hasIndex", "hasIndexWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalODopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "claimed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimed"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Claimed = data
		case "claimedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimedNEQ = data
		case "lastCheckedPaperClaim":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaim"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaim = data
		case "lastCheckedPaperClaimNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimNEQ = data
		case "lastCheckedPaperClaimIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimIn = data
		case "lastCheckedPaperClaimNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimNotIn = data
		case "lastCheckedPaperClaimGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimGT = data
		case "lastCheckedPaperClaimGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimGTE = data
		case "lastCheckedPaperClaimLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimLT = data
		case "lastCheckedPaperClaimLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimLTE = data
		case "lastCheckedPaperClaimIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimIsNil = data
		case "lastCheckedPaperClaimNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedPaperClaimNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedPaperClaimNotNil = data
		case "opened":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opened"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Opened = data
		case "openedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedNEQ = data
		case "lastCheckedGearClaim":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaim"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaim = data
		case "lastCheckedGearClaimNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimNEQ = data
		case "lastCheckedGearClaimIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimIn = data
		case "lastCheckedGearClaimNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimNotIn = data
		case "lastCheckedGearClaimGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimGT = data
		case "lastCheckedGearClaimGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimGTE = data
		case "lastCheckedGearClaimLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimLT = data
		case "lastCheckedGearClaimLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimLTE = data
		case "lastCheckedGearClaimIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimIsNil = data
		case "lastCheckedGearClaimNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastCheckedGearClaimNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastCheckedGearClaimNotNil = data
		case "score":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("score"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Score = data
		case "scoreNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreNEQ = data
		case "scoreIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreIn = data
		case "scoreNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreNotIn = data
		case "scoreGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreGT = data
		case "scoreGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreGTE = data
		case "scoreLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreLT = data
		case "scoreLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreLTE = data
		case "scoreIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreIsNil = data
		case "scoreNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scoreNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ScoreNotNil = data
		case "rank":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rank"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Rank = data
		case "rankNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankNEQ = data
		case "rankIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankIn = data
		case "rankNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankNotIn = data
		case "rankGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankGT = data
		case "rankGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankGTE = data
		case "rankLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankLT = data
		case "rankLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankLTE = data
		case "rankIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankIsNil = data
		case "rankNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rankNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RankNotNil = data
		case "order":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("order"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Order = data
		case "orderNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNEQ = data
		case "orderIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderIn = data
		case "orderNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderNotIn = data
		case "orderGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGT = data
		case "orderGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderGTE = data
		case "orderLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLT = data
		case "orderLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("orderLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.OrderLTE = data
		case "bestAskPriceEth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEth"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEth = data
		case "bestAskPriceEthNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNEQ"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNEQ = data
		case "bestAskPriceEthIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthIn = data
		case "bestAskPriceEthNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNotIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNotIn = data
		case "bestAskPriceEthGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthGT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthGT = data
		case "bestAskPriceEthGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthGTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthGTE = data
		case "bestAskPriceEthLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthLT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthLT = data
		case "bestAskPriceEthLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthLTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthLTE = data
		case "bestAskPriceEthIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthIsNil = data
		case "bestAskPriceEthNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNotNil = data
		case "hasWallet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallet"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWallet = data
		case "hasWalletWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletWith"))
			data, err := ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWalletWith = data
		case "hasItems":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItems"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItems = data
		case "hasItemsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemsWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItemsWith = data
		case "hasIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndex"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIndex = data
		case "hasIndexWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndexWith"))
			data, err := ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIndexWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEventWhereInput(ctx context.Context, obj interface{}) (ent.EventWhereInput, error) {
	var it ent.EventWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "index", "indexNEQ", "indexIn", "indexNotIn", "indexGT", "indexGTE", "indexLT", "indexLTE", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "updatedAt", "updatedAtNEQ", "updatedAtIn", "updatedAtNotIn", "updatedAtGT", "updatedAtGTE", "updatedAtLT", "updatedAtLTE"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOEventWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOEventWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "index":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("index"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Index = data
		case "indexNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexNEQ"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexNEQ = data
		case "indexIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexIn"))
			data, err := ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexIn = data
		case "indexNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexNotIn"))
			data, err := ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexNotIn = data
		case "indexGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGT"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexGT = data
		case "indexGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexGTE"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexGTE = data
		case "indexLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexLT"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexLT = data
		case "indexLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("indexLTE"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.IndexLTE = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "updatedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAt = data
		case "updatedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNEQ = data
		case "updatedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtIn = data
		case "updatedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtNotIn = data
		case "updatedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGT = data
		case "updatedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtGTE = data
		case "updatedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLT = data
		case "updatedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updatedAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.UpdatedAtLTE = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerItemWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerItemWhereInput, error) {
	var it ent.GameHustlerItemWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "item", "itemNEQ", "itemIn", "itemNotIn", "itemGT", "itemGTE", "itemLT", "itemLTE", "itemContains", "itemHasPrefix", "itemHasSuffix", "itemEqualFold", "itemContainsFold", "hasHustler", "hasHustlerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "item":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("item"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Item = data
		case "itemNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemNEQ = data
		case "itemIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemIn = data
		case "itemNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemNotIn = data
		case "itemGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemGT = data
		case "itemGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemGTE = data
		case "itemLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemLT = data
		case "itemLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemLTE = data
		case "itemContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemContains = data
		case "itemHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemHasPrefix = data
		case "itemHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemHasSuffix = data
		case "itemEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemEqualFold = data
		case "itemContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("itemContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ItemContainsFold = data
		case "hasHustler":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustler = data
		case "hasHustlerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			data, err := ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerOrder(ctx context.Context, obj interface{}) (ent.GameHustlerOrder, error) {
	var it ent.GameHustlerOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNGameHustlerOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerQuestWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerQuestWhereInput, error) {
	var it ent.GameHustlerQuestWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "quest", "questNEQ", "questIn", "questNotIn", "questGT", "questGTE", "questLT", "questLTE", "questContains", "questHasPrefix", "questHasSuffix", "questEqualFold", "questContainsFold", "completed", "completedNEQ", "hasHustler", "hasHustlerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "quest":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("quest"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Quest = data
		case "questNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestNEQ = data
		case "questIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestIn = data
		case "questNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestNotIn = data
		case "questGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestGT = data
		case "questGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestGTE = data
		case "questLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestLT = data
		case "questLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestLTE = data
		case "questContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestContains = data
		case "questHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestHasPrefix = data
		case "questHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestHasSuffix = data
		case "questEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestEqualFold = data
		case "questContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("questContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.QuestContainsFold = data
		case "completed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completed"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Completed = data
		case "completedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("completedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CompletedNEQ = data
		case "hasHustler":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustler = data
		case "hasHustlerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			data, err := ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerRelationWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerRelationWhereInput, error) {
	var it ent.GameHustlerRelationWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "citizen", "citizenNEQ", "citizenIn", "citizenNotIn", "citizenGT", "citizenGTE", "citizenLT", "citizenLTE", "citizenContains", "citizenHasPrefix", "citizenHasSuffix", "citizenEqualFold", "citizenContainsFold", "conversation", "conversationNEQ", "conversationIn", "conversationNotIn", "conversationGT", "conversationGTE", "conversationLT", "conversationLTE", "conversationContains", "conversationHasPrefix", "conversationHasSuffix", "conversationEqualFold", "conversationContainsFold", "text", "textNEQ", "textIn", "textNotIn", "textGT", "textGTE", "textLT", "textLTE", "hasHustler", "hasHustlerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "citizen":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizen"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Citizen = data
		case "citizenNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenNEQ = data
		case "citizenIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenIn = data
		case "citizenNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenNotIn = data
		case "citizenGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenGT = data
		case "citizenGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenGTE = data
		case "citizenLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenLT = data
		case "citizenLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenLTE = data
		case "citizenContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenContains = data
		case "citizenHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenHasPrefix = data
		case "citizenHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenHasSuffix = data
		case "citizenEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenEqualFold = data
		case "citizenContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("citizenContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CitizenContainsFold = data
		case "conversation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversation"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Conversation = data
		case "conversationNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationNEQ = data
		case "conversationIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationIn = data
		case "conversationNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationNotIn = data
		case "conversationGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationGT = data
		case "conversationGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationGTE = data
		case "conversationLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationLT = data
		case "conversationLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationLTE = data
		case "conversationContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationContains = data
		case "conversationHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationHasPrefix = data
		case "conversationHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationHasSuffix = data
		case "conversationEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationEqualFold = data
		case "conversationContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("conversationContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConversationContainsFold = data
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().Text(ctx, &it, data); err != nil {
				return it, err
			}
		case "textNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextNeq(ctx, &it, data); err != nil {
				return it, err
			}
		case "textIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "textNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextNotIn(ctx, &it, data); err != nil {
				return it, err
			}
		case "textGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextGt(ctx, &it, data); err != nil {
				return it, err
			}
		case "textGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextGte(ctx, &it, data); err != nil {
				return it, err
			}
		case "textLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextLt(ctx, &it, data); err != nil {
				return it, err
			}
		case "textLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("textLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.GameHustlerRelationWhereInput().TextLte(ctx, &it, data); err != nil {
				return it, err
			}
		case "hasHustler":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustler = data
		case "hasHustlerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			data, err := ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGameHustlerWhereInput(ctx context.Context, obj interface{}) (ent.GameHustlerWhereInput, error) {
	var it ent.GameHustlerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "hasRelations", "hasRelationsWith", "hasItems", "hasItemsWith", "hasQuests", "hasQuestsWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "hasRelations":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRelations"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRelations = data
		case "hasRelationsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRelationsWith"))
			data, err := ec.unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRelationsWith = data
		case "hasItems":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItems"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItems = data
		case "hasItemsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemsWith"))
			data, err := ec.unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItemsWith = data
		case "hasQuests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasQuests"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasQuests = data
		case "hasQuestsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasQuestsWith"))
			data, err := ec.unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasQuestsWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHustlerOrder(ctx context.Context, obj interface{}) (ent.HustlerOrder, error) {
	var it ent.HustlerOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNHustlerOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHustlerWhereInput(ctx context.Context, obj interface{}) (ent.HustlerWhereInput, error) {
	var it ent.HustlerWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameIsNil", "nameNotNil", "nameEqualFold", "nameContainsFold", "title", "titleNEQ", "titleIn", "titleNotIn", "titleGT", "titleGTE", "titleLT", "titleLTE", "titleContains", "titleHasPrefix", "titleHasSuffix", "titleIsNil", "titleNotNil", "titleEqualFold", "titleContainsFold", "color", "colorNEQ", "colorIn", "colorNotIn", "colorGT", "colorGTE", "colorLT", "colorLTE", "colorContains", "colorHasPrefix", "colorHasSuffix", "colorIsNil", "colorNotNil", "colorEqualFold", "colorContainsFold", "background", "backgroundNEQ", "backgroundIn", "backgroundNotIn", "backgroundGT", "backgroundGTE", "backgroundLT", "backgroundLTE", "backgroundContains", "backgroundHasPrefix", "backgroundHasSuffix", "backgroundIsNil", "backgroundNotNil", "backgroundEqualFold", "backgroundContainsFold", "age", "ageNEQ", "ageIn", "ageNotIn", "ageGT", "ageGTE", "ageLT", "ageLTE", "sex", "sexNEQ", "sexIn", "sexNotIn", "svg", "svgNEQ", "svgIn", "svgNotIn", "svgGT", "svgGTE", "svgLT", "svgLTE", "svgContains", "svgHasPrefix", "svgHasSuffix", "svgIsNil", "svgNotNil", "svgEqualFold", "svgContainsFold", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "bestAskPriceEth", "bestAskPriceEthNEQ", "bestAskPriceEthIn", "bestAskPriceEthNotIn", "bestAskPriceEthGT", "bestAskPriceEthGTE", "bestAskPriceEthLT", "bestAskPriceEthLTE", "bestAskPriceEthIsNil", "bestAskPriceEthNotNil", "hasWallet", "hasWalletWith", "hasWeapon", "hasWeaponWith", "hasClothes", "hasClothesWith", "hasVehicle", "hasVehicleWith", "hasWaist", "hasWaistWith", "hasFoot", "hasFootWith", "hasHand", "hasHandWith", "hasDrug", "hasDrugWith", "hasNeck", "hasNeckWith", "hasRing", "hasRingWith", "hasAccessory", "hasAccessoryWith", "hasBody", "hasBodyWith", "hasHair", "hasHairWith", "hasBeard", "hasBeardWith", "hasIndex", "hasIndexWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOHustlerHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOHustlerHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOHustlerHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOHustlerHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIsNil = data
		case "nameNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotNil = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "title":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("title"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Title = data
		case "titleNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNEQ = data
		case "titleIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIn = data
		case "titleNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotIn = data
		case "titleGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGT = data
		case "titleGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleGTE = data
		case "titleLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLT = data
		case "titleLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleLTE = data
		case "titleContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContains = data
		case "titleHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasPrefix = data
		case "titleHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleHasSuffix = data
		case "titleIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleIsNil = data
		case "titleNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleNotNil = data
		case "titleEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleEqualFold = data
		case "titleContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("titleContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TitleContainsFold = data
		case "color":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("color"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Color = data
		case "colorNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNEQ = data
		case "colorIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorIn = data
		case "colorNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNotIn = data
		case "colorGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorGT = data
		case "colorGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorGTE = data
		case "colorLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorLT = data
		case "colorLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorLTE = data
		case "colorContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorContains = data
		case "colorHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorHasPrefix = data
		case "colorHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorHasSuffix = data
		case "colorIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorIsNil = data
		case "colorNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorNotNil = data
		case "colorEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorEqualFold = data
		case "colorContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("colorContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ColorContainsFold = data
		case "background":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("background"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Background = data
		case "backgroundNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundNEQ = data
		case "backgroundIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundIn = data
		case "backgroundNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundNotIn = data
		case "backgroundGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundGT = data
		case "backgroundGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundGTE = data
		case "backgroundLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundLT = data
		case "backgroundLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundLTE = data
		case "backgroundContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundContains = data
		case "backgroundHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundHasPrefix = data
		case "backgroundHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundHasSuffix = data
		case "backgroundIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundIsNil = data
		case "backgroundNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundNotNil = data
		case "backgroundEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundEqualFold = data
		case "backgroundContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundContainsFold = data
		case "age":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("age"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.Age = data
		case "ageNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageNEQ"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeNEQ = data
		case "ageIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageIn"))
			data, err := ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeIn = data
		case "ageNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageNotIn"))
			data, err := ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeNotIn = data
		case "ageGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageGT"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeGT = data
		case "ageGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageGTE"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeGTE = data
		case "ageLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageLT"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeLT = data
		case "ageLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ageLTE"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgeLTE = data
		case "sex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sex"))
			data, err := ec.unmarshalOHustlerHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sex = data
		case "sexNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNEQ"))
			data, err := ec.unmarshalOHustlerHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, v)
			if err != nil {
				return it, err
			}
			it.SexNEQ = data
		case "sexIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexIn"))
			data, err := ec.unmarshalOHustlerHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SexIn = data
		case "sexNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sexNotIn"))
			data, err := ec.unmarshalOHustlerHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SexNotIn = data
		case "svg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svg"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Svg = data
		case "svgNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgNEQ = data
		case "svgIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgIn = data
		case "svgNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgNotIn = data
		case "svgGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgGT = data
		case "svgGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgGTE = data
		case "svgLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgLT = data
		case "svgLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgLTE = data
		case "svgContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgContains = data
		case "svgHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgHasPrefix = data
		case "svgHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgHasSuffix = data
		case "svgIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgIsNil = data
		case "svgNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgNotNil = data
		case "svgEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgEqualFold = data
		case "svgContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgContainsFold = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "bestAskPriceEth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEth"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEth = data
		case "bestAskPriceEthNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNEQ"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNEQ = data
		case "bestAskPriceEthIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthIn = data
		case "bestAskPriceEthNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNotIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNotIn = data
		case "bestAskPriceEthGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthGT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthGT = data
		case "bestAskPriceEthGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthGTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthGTE = data
		case "bestAskPriceEthLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthLT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthLT = data
		case "bestAskPriceEthLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthLTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthLTE = data
		case "bestAskPriceEthIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthIsNil = data
		case "bestAskPriceEthNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNotNil = data
		case "hasWallet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallet"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWallet = data
		case "hasWalletWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletWith"))
			data, err := ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWalletWith = data
		case "hasWeapon":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeapon"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeapon = data
		case "hasWeaponWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWeaponWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWeaponWith = data
		case "hasClothes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClothes"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClothes = data
		case "hasClothesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasClothesWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasClothesWith = data
		case "hasVehicle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicle"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasVehicle = data
		case "hasVehicleWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasVehicleWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasVehicleWith = data
		case "hasWaist":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWaist"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWaist = data
		case "hasWaistWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWaistWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWaistWith = data
		case "hasFoot":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasFoot"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasFoot = data
		case "hasFootWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasFootWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasFootWith = data
		case "hasHand":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHand"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHand = data
		case "hasHandWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHandWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHandWith = data
		case "hasDrug":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDrug"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDrug = data
		case "hasDrugWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDrugWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDrugWith = data
		case "hasNeck":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNeck"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasNeck = data
		case "hasNeckWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasNeckWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasNeckWith = data
		case "hasRing":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRing"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRing = data
		case "hasRingWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasRingWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasRingWith = data
		case "hasAccessory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccessory"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccessory = data
		case "hasAccessoryWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasAccessoryWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasAccessoryWith = data
		case "hasBody":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBody"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBody = data
		case "hasBodyWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBodyWith"))
			data, err := ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBodyWith = data
		case "hasHair":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHair"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHair = data
		case "hasHairWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHairWith"))
			data, err := ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHairWith = data
		case "hasBeard":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBeard"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBeard = data
		case "hasBeardWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBeardWith"))
			data, err := ec.unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBeardWith = data
		case "hasIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndex"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIndex = data
		case "hasIndexWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndexWith"))
			data, err := ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIndexWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputItemOrder(ctx context.Context, obj interface{}) (ent.ItemOrder, error) {
	var it ent.ItemOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNItemOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputItemWhereInput(ctx context.Context, obj interface{}) (ent.ItemWhereInput, error) {
	var it ent.ItemWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "namePrefix", "namePrefixNEQ", "namePrefixIn", "namePrefixNotIn", "namePrefixGT", "namePrefixGTE", "namePrefixLT", "namePrefixLTE", "namePrefixContains", "namePrefixHasPrefix", "namePrefixHasSuffix", "namePrefixIsNil", "namePrefixNotNil", "namePrefixEqualFold", "namePrefixContainsFold", "nameSuffix", "nameSuffixNEQ", "nameSuffixIn", "nameSuffixNotIn", "nameSuffixGT", "nameSuffixGTE", "nameSuffixLT", "nameSuffixLTE", "nameSuffixContains", "nameSuffixHasPrefix", "nameSuffixHasSuffix", "nameSuffixIsNil", "nameSuffixNotNil", "nameSuffixEqualFold", "nameSuffixContainsFold", "name", "nameNEQ", "nameIn", "nameNotIn", "nameGT", "nameGTE", "nameLT", "nameLTE", "nameContains", "nameHasPrefix", "nameHasSuffix", "nameEqualFold", "nameContainsFold", "suffix", "suffixNEQ", "suffixIn", "suffixNotIn", "suffixGT", "suffixGTE", "suffixLT", "suffixLTE", "suffixContains", "suffixHasPrefix", "suffixHasSuffix", "suffixIsNil", "suffixNotNil", "suffixEqualFold", "suffixContainsFold", "augmented", "augmentedNEQ", "augmentedIsNil", "augmentedNotNil", "count", "countNEQ", "countIn", "countNotIn", "countGT", "countGTE", "countLT", "countLTE", "countIsNil", "countNotNil", "tier", "tierNEQ", "tierIn", "tierNotIn", "tierIsNil", "tierNotNil", "greatness", "greatnessNEQ", "greatnessIn", "greatnessNotIn", "greatnessGT", "greatnessGTE", "greatnessLT", "greatnessLTE", "greatnessIsNil", "greatnessNotNil", "svg", "svgNEQ", "svgIn", "svgNotIn", "svgGT", "svgGTE", "svgLT", "svgLTE", "svgContains", "svgHasPrefix", "svgHasSuffix", "svgIsNil", "svgNotNil", "svgEqualFold", "svgContainsFold", "bestAskPriceEth", "bestAskPriceEthNEQ", "bestAskPriceEthIn", "bestAskPriceEthNotIn", "bestAskPriceEthGT", "bestAskPriceEthGTE", "bestAskPriceEthLT", "bestAskPriceEthLTE", "bestAskPriceEthIsNil", "bestAskPriceEthNotNil", "hasWallets", "hasWalletsWith", "hasDopes", "hasDopesWith", "hasHustlerWeapons", "hasHustlerWeaponsWith", "hasHustlerClothes", "hasHustlerClothesWith", "hasHustlerVehicles", "hasHustlerVehiclesWith", "hasHustlerWaists", "hasHustlerWaistsWith", "hasHustlerFeet", "hasHustlerFeetWith", "hasHustlerHands", "hasHustlerHandsWith", "hasHustlerDrugs", "hasHustlerDrugsWith", "hasHustlerNecks", "hasHustlerNecksWith", "hasHustlerRings", "hasHustlerRingsWith", "hasHustlerAccessories", "hasHustlerAccessoriesWith", "hasBase", "hasBaseWith", "hasDerivative", "hasDerivativeWith", "hasIndex", "hasIndexWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOItemItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOItemItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOItemItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOItemItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "namePrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefix = data
		case "namePrefixNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixNEQ = data
		case "namePrefixIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixIn = data
		case "namePrefixNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixNotIn = data
		case "namePrefixGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixGT = data
		case "namePrefixGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixGTE = data
		case "namePrefixLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixLT = data
		case "namePrefixLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixLTE = data
		case "namePrefixContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixContains = data
		case "namePrefixHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixHasPrefix = data
		case "namePrefixHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixHasSuffix = data
		case "namePrefixIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixIsNil = data
		case "namePrefixNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixNotNil = data
		case "namePrefixEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixEqualFold = data
		case "namePrefixContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namePrefixContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamePrefixContainsFold = data
		case "nameSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffix = data
		case "nameSuffixNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixNEQ = data
		case "nameSuffixIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixIn = data
		case "nameSuffixNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixNotIn = data
		case "nameSuffixGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixGT = data
		case "nameSuffixGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixGTE = data
		case "nameSuffixLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixLT = data
		case "nameSuffixLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixLTE = data
		case "nameSuffixContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixContains = data
		case "nameSuffixHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixHasPrefix = data
		case "nameSuffixHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixHasSuffix = data
		case "nameSuffixIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixIsNil = data
		case "nameSuffixNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixNotNil = data
		case "nameSuffixEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixEqualFold = data
		case "nameSuffixContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameSuffixContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameSuffixContainsFold = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "nameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNEQ = data
		case "nameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameIn = data
		case "nameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameNotIn = data
		case "nameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGT = data
		case "nameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameGTE = data
		case "nameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLT = data
		case "nameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameLTE = data
		case "nameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContains = data
		case "nameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasPrefix = data
		case "nameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameHasSuffix = data
		case "nameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameEqualFold = data
		case "nameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.NameContainsFold = data
		case "suffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Suffix = data
		case "suffixNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixNEQ = data
		case "suffixIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixIn = data
		case "suffixNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixNotIn = data
		case "suffixGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixGT = data
		case "suffixGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixGTE = data
		case "suffixLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixLT = data
		case "suffixLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixLTE = data
		case "suffixContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixContains = data
		case "suffixHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixHasPrefix = data
		case "suffixHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixHasSuffix = data
		case "suffixIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixIsNil = data
		case "suffixNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixNotNil = data
		case "suffixEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixEqualFold = data
		case "suffixContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("suffixContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SuffixContainsFold = data
		case "augmented":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmented"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Augmented = data
		case "augmentedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmentedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AugmentedNEQ = data
		case "augmentedIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmentedIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AugmentedIsNil = data
		case "augmentedNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("augmentedNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AugmentedNotNil = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "countNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountNEQ = data
		case "countIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountIn = data
		case "countNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountNotIn = data
		case "countGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountGT = data
		case "countGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountGTE = data
		case "countLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountLT = data
		case "countLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountLTE = data
		case "countIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountIsNil = data
		case "countNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("countNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CountNotNil = data
		case "tier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tier"))
			data, err := ec.unmarshalOItemItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tier = data
		case "tierNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNEQ"))
			data, err := ec.unmarshalOItemItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierNEQ = data
		case "tierIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierIn"))
			data, err := ec.unmarshalOItemItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierIn = data
		case "tierNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNotIn"))
			data, err := ec.unmarshalOItemItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierNotIn = data
		case "tierIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierIsNil = data
		case "tierNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tierNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TierNotNil = data
		case "greatness":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatness"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Greatness = data
		case "greatnessNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessNEQ = data
		case "greatnessIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessIn = data
		case "greatnessNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessNotIn = data
		case "greatnessGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessGT = data
		case "greatnessGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessGTE = data
		case "greatnessLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessLT = data
		case "greatnessLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessLTE = data
		case "greatnessIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessIsNil = data
		case "greatnessNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessNotNil = data
		case "svg":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svg"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Svg = data
		case "svgNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgNEQ = data
		case "svgIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgIn = data
		case "svgNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgNotIn = data
		case "svgGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgGT = data
		case "svgGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgGTE = data
		case "svgLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgLT = data
		case "svgLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgLTE = data
		case "svgContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgContains = data
		case "svgHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgHasPrefix = data
		case "svgHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgHasSuffix = data
		case "svgIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgIsNil = data
		case "svgNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgNotNil = data
		case "svgEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgEqualFold = data
		case "svgContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("svgContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SvgContainsFold = data
		case "bestAskPriceEth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEth"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEth = data
		case "bestAskPriceEthNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNEQ"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNEQ = data
		case "bestAskPriceEthIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthIn = data
		case "bestAskPriceEthNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNotIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNotIn = data
		case "bestAskPriceEthGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthGT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthGT = data
		case "bestAskPriceEthGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthGTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthGTE = data
		case "bestAskPriceEthLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthLT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthLT = data
		case "bestAskPriceEthLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthLTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthLTE = data
		case "bestAskPriceEthIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthIsNil = data
		case "bestAskPriceEthNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bestAskPriceEthNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BestAskPriceEthNotNil = data
		case "hasWallets":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallets"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWallets = data
		case "hasWalletsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletsWith"))
			data, err := ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWalletsWith = data
		case "hasDopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopes"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDopes = data
		case "hasDopesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopesWith"))
			data, err := ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDopesWith = data
		case "hasHustlerWeapons":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWeapons"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWeapons = data
		case "hasHustlerWeaponsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWeaponsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWeaponsWith = data
		case "hasHustlerClothes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerClothes"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerClothes = data
		case "hasHustlerClothesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerClothesWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerClothesWith = data
		case "hasHustlerVehicles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerVehicles"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerVehicles = data
		case "hasHustlerVehiclesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerVehiclesWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerVehiclesWith = data
		case "hasHustlerWaists":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWaists"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWaists = data
		case "hasHustlerWaistsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWaistsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWaistsWith = data
		case "hasHustlerFeet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerFeet"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerFeet = data
		case "hasHustlerFeetWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerFeetWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerFeetWith = data
		case "hasHustlerHands":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHands"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerHands = data
		case "hasHustlerHandsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerHandsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerHandsWith = data
		case "hasHustlerDrugs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerDrugs"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerDrugs = data
		case "hasHustlerDrugsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerDrugsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerDrugsWith = data
		case "hasHustlerNecks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerNecks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerNecks = data
		case "hasHustlerNecksWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerNecksWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerNecksWith = data
		case "hasHustlerRings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerRings"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerRings = data
		case "hasHustlerRingsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerRingsWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerRingsWith = data
		case "hasHustlerAccessories":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerAccessories"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerAccessories = data
		case "hasHustlerAccessoriesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerAccessoriesWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerAccessoriesWith = data
		case "hasBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBase"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBase = data
		case "hasBaseWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasBaseWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasBaseWith = data
		case "hasDerivative":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDerivative"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDerivative = data
		case "hasDerivativeWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDerivativeWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDerivativeWith = data
		case "hasIndex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndex"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIndex = data
		case "hasIndexWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasIndexWith"))
			data, err := ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasIndexWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchOrder(ctx context.Context, obj interface{}) (ent.SearchOrder, error) {
	var it ent.SearchOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNSearchOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSearchWhereInput(ctx context.Context, obj interface{}) (ent.SearchWhereInput, error) {
	var it ent.SearchWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "type", "typeNEQ", "typeIn", "typeNotIn", "greatness", "greatnessNEQ", "greatnessIn", "greatnessNotIn", "greatnessGT", "greatnessGTE", "greatnessLT", "greatnessLTE", "greatnessIsNil", "greatnessNotNil", "claimed", "claimedNEQ", "opened", "openedNEQ", "banned", "bannedNEQ", "salePrice", "salePriceNEQ", "salePriceIn", "salePriceNotIn", "salePriceGT", "salePriceGTE", "salePriceLT", "salePriceLTE", "salePriceIsNil", "salePriceNotNil", "hasDope", "hasDopeWith", "hasItem", "hasItemWith", "hasHustler", "hasHustlerWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalOSearchSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "typeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNEQ"))
			data, err := ec.unmarshalOSearchSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNEQ = data
		case "typeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeIn"))
			data, err := ec.unmarshalOSearchSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeIn = data
		case "typeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("typeNotIn"))
			data, err := ec.unmarshalOSearchSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TypeNotIn = data
		case "greatness":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatness"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Greatness = data
		case "greatnessNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNEQ"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessNEQ = data
		case "greatnessIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessIn = data
		case "greatnessNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotIn"))
			data, err := ec.unmarshalOInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessNotIn = data
		case "greatnessGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessGT = data
		case "greatnessGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessGTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessGTE = data
		case "greatnessLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLT"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessLT = data
		case "greatnessLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessLTE"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessLTE = data
		case "greatnessIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessIsNil = data
		case "greatnessNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("greatnessNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GreatnessNotNil = data
		case "claimed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimed"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Claimed = data
		case "claimedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("claimedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClaimedNEQ = data
		case "opened":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opened"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Opened = data
		case "openedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("openedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OpenedNEQ = data
		case "banned":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banned"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banned = data
		case "bannedNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bannedNEQ"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BannedNEQ = data
		case "salePrice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePrice"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePrice = data
		case "salePriceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceNEQ"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceNEQ = data
		case "salePriceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceIn = data
		case "salePriceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceNotIn"))
			data, err := ec.unmarshalOFloat2ᚕfloat64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceNotIn = data
		case "salePriceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceGT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceGT = data
		case "salePriceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceGTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceGTE = data
		case "salePriceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceLT"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceLT = data
		case "salePriceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceLTE"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceLTE = data
		case "salePriceIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceIsNil = data
		case "salePriceNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("salePriceNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SalePriceNotNil = data
		case "hasDope":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDope"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDope = data
		case "hasDopeWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopeWith"))
			data, err := ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDopeWith = data
		case "hasItem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItem = data
		case "hasItemWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItemWith = data
		case "hasHustler":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustler"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustler = data
		case "hasHustlerWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlerWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlerWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSyncStateWhereInput(ctx context.Context, obj interface{}) (ent.SyncStateWhereInput, error) {
	var it ent.SyncStateWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "contractName", "contractNameNEQ", "contractNameIn", "contractNameNotIn", "contractNameGT", "contractNameGTE", "contractNameLT", "contractNameLTE", "contractNameContains", "contractNameHasPrefix", "contractNameHasSuffix", "contractNameIsNil", "contractNameNotNil", "contractNameEqualFold", "contractNameContainsFold", "startBlock", "startBlockNEQ", "startBlockIn", "startBlockNotIn", "startBlockGT", "startBlockGTE", "startBlockLT", "startBlockLTE", "blockTime", "blockTimeNEQ", "blockTimeIn", "blockTimeNotIn", "blockTimeGT", "blockTimeGTE", "blockTimeLT", "blockTimeLTE", "blockTimeIsNil", "blockTimeNotNil", "lastSyncedAt", "lastSyncedAtNEQ", "lastSyncedAtIn", "lastSyncedAtNotIn", "lastSyncedAtGT", "lastSyncedAtGTE", "lastSyncedAtLT", "lastSyncedAtLTE", "lastSyncedAtIsNil", "lastSyncedAtNotNil"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOSyncStateWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOSyncStateWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "contractName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractName = data
		case "contractNameNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameNEQ"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameNEQ = data
		case "contractNameIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameIn = data
		case "contractNameNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameNotIn"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameNotIn = data
		case "contractNameGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameGT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameGT = data
		case "contractNameGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameGTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameGTE = data
		case "contractNameLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameLT"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameLT = data
		case "contractNameLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameLTE"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameLTE = data
		case "contractNameContains":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameContains"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameContains = data
		case "contractNameHasPrefix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameHasPrefix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameHasPrefix = data
		case "contractNameHasSuffix":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameHasSuffix"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameHasSuffix = data
		case "contractNameIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameIsNil = data
		case "contractNameNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameNotNil = data
		case "contractNameEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameEqualFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameEqualFold = data
		case "contractNameContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("contractNameContainsFold"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContractNameContainsFold = data
		case "startBlock":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlock"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlock = data
		case "startBlockNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockNEQ"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockNEQ = data
		case "startBlockIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockIn"))
			data, err := ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockIn = data
		case "startBlockNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockNotIn"))
			data, err := ec.unmarshalOLong2ᚕuint64ᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockNotIn = data
		case "startBlockGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockGT"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockGT = data
		case "startBlockGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockGTE"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockGTE = data
		case "startBlockLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockLT"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockLT = data
		case "startBlockLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startBlockLTE"))
			data, err := ec.unmarshalOLong2ᚖuint64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartBlockLTE = data
		case "blockTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTime"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTime = data
		case "blockTimeNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeNEQ = data
		case "blockTimeIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeIn = data
		case "blockTimeNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeNotIn = data
		case "blockTimeGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeGT = data
		case "blockTimeGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeGTE = data
		case "blockTimeLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeLT = data
		case "blockTimeLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeLTE = data
		case "blockTimeIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeIsNil = data
		case "blockTimeNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("blockTimeNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BlockTimeNotNil = data
		case "lastSyncedAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAt = data
		case "lastSyncedAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtNEQ = data
		case "lastSyncedAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtIn = data
		case "lastSyncedAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtNotIn = data
		case "lastSyncedAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtGT = data
		case "lastSyncedAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtGTE = data
		case "lastSyncedAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtLT = data
		case "lastSyncedAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtLTE = data
		case "lastSyncedAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtIsNil = data
		case "lastSyncedAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSyncedAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSyncedAtNotNil = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletItemsWhereInput(ctx context.Context, obj interface{}) (ent.WalletItemsWhereInput, error) {
	var it ent.WalletItemsWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "balance", "balanceNEQ", "balanceIn", "balanceNotIn", "balanceGT", "balanceGTE", "balanceLT", "balanceLTE", "hasWallet", "hasWalletWith", "hasItem", "hasItemWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "balance":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balance"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.Balance = data
		case "balanceNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNEQ"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceNEQ = data
		case "balanceIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceIn"))
			data, err := ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceIn = data
		case "balanceNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceNotIn"))
			data, err := ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceNotIn = data
		case "balanceGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGT"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceGT = data
		case "balanceGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceGTE"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceGTE = data
		case "balanceLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLT"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceLT = data
		case "balanceLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("balanceLTE"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.BalanceLTE = data
		case "hasWallet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWallet"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWallet = data
		case "hasWalletWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasWalletWith"))
			data, err := ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasWalletWith = data
		case "hasItem":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItem"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItem = data
		case "hasItemWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemWith"))
			data, err := ec.unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItemWith = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletOrder(ctx context.Context, obj interface{}) (ent.WalletOrder, error) {
	var it ent.WalletOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["direction"]; !present {
		asMap["direction"] = "ASC"
	}

	fieldsInOrder := [...]string{"direction", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "field":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNWalletOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrderField(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWalletWhereInput(ctx context.Context, obj interface{}) (ent.WalletWhereInput, error) {
	var it ent.WalletWhereInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"not", "and", "or", "id", "idNEQ", "idIn", "idNotIn", "idGT", "idGTE", "idLT", "idLTE", "idEqualFold", "idContainsFold", "paper", "paperNEQ", "paperIn", "paperNotIn", "paperGT", "paperGTE", "paperLT", "paperLTE", "lastSetPaperBalanceAt", "lastSetPaperBalanceAtNEQ", "lastSetPaperBalanceAtIn", "lastSetPaperBalanceAtNotIn", "lastSetPaperBalanceAtGT", "lastSetPaperBalanceAtGTE", "lastSetPaperBalanceAtLT", "lastSetPaperBalanceAtLTE", "lastSetPaperBalanceAtIsNil", "lastSetPaperBalanceAtNotNil", "createdAt", "createdAtNEQ", "createdAtIn", "createdAtNotIn", "createdAtGT", "createdAtGTE", "createdAtLT", "createdAtLTE", "hasDopes", "hasDopesWith", "hasItems", "hasItemsWith", "hasHustlers", "hasHustlersWith"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "not":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("not"))
			data, err := ec.unmarshalOWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.Not = data
		case "and":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("and"))
			data, err := ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.And = data
		case "or":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("or"))
			data, err := ec.unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Or = data
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "idNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNEQ"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNEQ = data
		case "idIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDIn = data
		case "idNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idNotIn"))
			data, err := ec.unmarshalOID2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDNotIn = data
		case "idGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGT = data
		case "idGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idGTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDGTE = data
		case "idLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLT"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLT = data
		case "idLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idLTE"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDLTE = data
		case "idEqualFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idEqualFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDEqualFold = data
		case "idContainsFold":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("idContainsFold"))
			data, err := ec.unmarshalOID2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IDContainsFold = data
		case "paper":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paper"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.Paper = data
		case "paperNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperNEQ"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperNEQ = data
		case "paperIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperIn"))
			data, err := ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperIn = data
		case "paperNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperNotIn"))
			data, err := ec.unmarshalOBigInt2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigIntᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperNotIn = data
		case "paperGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperGT"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperGT = data
		case "paperGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperGTE"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperGTE = data
		case "paperLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperLT"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperLT = data
		case "paperLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("paperLTE"))
			data, err := ec.unmarshalOBigInt2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋschemaᚐBigInt(ctx, v)
			if err != nil {
				return it, err
			}
			it.PaperLTE = data
		case "lastSetPaperBalanceAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAt = data
		case "lastSetPaperBalanceAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtNEQ = data
		case "lastSetPaperBalanceAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtIn = data
		case "lastSetPaperBalanceAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtNotIn = data
		case "lastSetPaperBalanceAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtGT = data
		case "lastSetPaperBalanceAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtGTE = data
		case "lastSetPaperBalanceAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtLT = data
		case "lastSetPaperBalanceAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtLTE = data
		case "lastSetPaperBalanceAtIsNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtIsNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtIsNil = data
		case "lastSetPaperBalanceAtNotNil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastSetPaperBalanceAtNotNil"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastSetPaperBalanceAtNotNil = data
		case "createdAt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAt"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAt = data
		case "createdAtNEQ":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNEQ"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNEQ = data
		case "createdAtIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtIn = data
		case "createdAtNotIn":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtNotIn"))
			data, err := ec.unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtNotIn = data
		case "createdAtGT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGT = data
		case "createdAtGTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtGTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtGTE = data
		case "createdAtLT":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLT"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLT = data
		case "createdAtLTE":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("createdAtLTE"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.CreatedAtLTE = data
		case "hasDopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopes"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDopes = data
		case "hasDopesWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasDopesWith"))
			data, err := ec.unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasDopesWith = data
		case "hasItems":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItems"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItems = data
		case "hasItemsWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasItemsWith"))
			data, err := ec.unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasItemsWith = data
		case "hasHustlers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlers"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlers = data
		case "hasHustlersWith":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasHustlersWith"))
			data, err := ec.unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasHustlersWith = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

func (ec *executionContext) _Node(ctx context.Context, sel ast.SelectionSet, obj ent.Noder) graphql.Marshaler {
	switch obj := (obj).(type) {
	case nil:
		return graphql.Null
	case *ent.BodyPart:
		if obj == nil {
			return graphql.Null
		}
		return ec._BodyPart(ctx, sel, obj)
	case *ent.Dope:
		if obj == nil {
			return graphql.Null
		}
		return ec._Dope(ctx, sel, obj)
	case *ent.Event:
		if obj == nil {
			return graphql.Null
		}
		return ec._Event(ctx, sel, obj)
	case *ent.GameHustler:
		if obj == nil {
			return graphql.Null
		}
		return ec._GameHustler(ctx, sel, obj)
	case *ent.GameHustlerItem:
		if obj == nil {
			return graphql.Null
		}
		return ec._GameHustlerItem(ctx, sel, obj)
	case *ent.GameHustlerQuest:
		if obj == nil {
			return graphql.Null
		}
		return ec._GameHustlerQuest(ctx, sel, obj)
	case *ent.GameHustlerRelation:
		if obj == nil {
			return graphql.Null
		}
		return ec._GameHustlerRelation(ctx, sel, obj)
	case *ent.Hustler:
		if obj == nil {
			return graphql.Null
		}
		return ec._Hustler(ctx, sel, obj)
	case *ent.Item:
		if obj == nil {
			return graphql.Null
		}
		return ec._Item(ctx, sel, obj)
	case *ent.Search:
		if obj == nil {
			return graphql.Null
		}
		return ec._Search(ctx, sel, obj)
	case *ent.SyncState:
		if obj == nil {
			return graphql.Null
		}
		return ec._SyncState(ctx, sel, obj)
	case *ent.Wallet:
		if obj == nil {
			return graphql.Null
		}
		return ec._Wallet(ctx, sel, obj)
	case *ent.WalletItems:
		if obj == nil {
			return graphql.Null
		}
		return ec._WalletItems(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var bodyPartImplementors = []string{"BodyPart", "Node"}

func (ec *executionContext) _BodyPart(ctx context.Context, sel ast.SelectionSet, obj *ent.BodyPart) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bodyPartImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BodyPart")
		case "id":
			out.Values[i] = ec._BodyPart_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._BodyPart_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sex":
			out.Values[i] = ec._BodyPart_sex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "rle":
			out.Values[i] = ec._BodyPart_rle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sprite":
			out.Values[i] = ec._BodyPart_sprite(ctx, field, obj)
		case "hustlerBodies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BodyPart_hustlerBodies(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerHairs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BodyPart_hustlerHairs(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerBeards":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._BodyPart_hustlerBeards(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bodyPartConnectionImplementors = []string{"BodyPartConnection"}

func (ec *executionContext) _BodyPartConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.BodyPartConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bodyPartConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BodyPartConnection")
		case "edges":
			out.Values[i] = ec._BodyPartConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._BodyPartConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._BodyPartConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bodyPartEdgeImplementors = []string{"BodyPartEdge"}

func (ec *executionContext) _BodyPartEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.BodyPartEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bodyPartEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BodyPartEdge")
		case "node":
			out.Values[i] = ec._BodyPartEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._BodyPartEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dopeImplementors = []string{"Dope", "SearchResult", "Node"}

func (ec *executionContext) _Dope(ctx context.Context, sel ast.SelectionSet, obj *ent.Dope) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dopeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dope")
		case "id":
			out.Values[i] = ec._Dope_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "claimed":
			out.Values[i] = ec._Dope_claimed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastCheckedPaperClaim":
			out.Values[i] = ec._Dope_lastCheckedPaperClaim(ctx, field, obj)
		case "opened":
			out.Values[i] = ec._Dope_opened(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastCheckedGearClaim":
			out.Values[i] = ec._Dope_lastCheckedGearClaim(ctx, field, obj)
		case "score":
			out.Values[i] = ec._Dope_score(ctx, field, obj)
		case "rank":
			out.Values[i] = ec._Dope_rank(ctx, field, obj)
		case "order":
			out.Values[i] = ec._Dope_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bestAskPriceEth":
			out.Values[i] = ec._Dope_bestAskPriceEth(ctx, field, obj)
		case "wallet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dope_wallet(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "items":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dope_items(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "index":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Dope_index(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dopeConnectionImplementors = []string{"DopeConnection"}

func (ec *executionContext) _DopeConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.DopeConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dopeConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DopeConnection")
		case "edges":
			out.Values[i] = ec._DopeConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._DopeConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._DopeConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dopeEdgeImplementors = []string{"DopeEdge"}

func (ec *executionContext) _DopeEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.DopeEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dopeEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DopeEdge")
		case "node":
			out.Values[i] = ec._DopeEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._DopeEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eventImplementors = []string{"Event", "Node"}

func (ec *executionContext) _Event(ctx context.Context, sel ast.SelectionSet, obj *ent.Event) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Event")
		case "id":
			out.Values[i] = ec._Event_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "address":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_address(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "index":
			out.Values[i] = ec._Event_index(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hash":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Event_hash(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._Event_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updatedAt":
			out.Values[i] = ec._Event_updatedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameHustlerImplementors = []string{"GameHustler", "Node"}

func (ec *executionContext) _GameHustler(ctx context.Context, sel ast.SelectionSet, obj *ent.GameHustler) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameHustlerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameHustler")
		case "id":
			out.Values[i] = ec._GameHustler_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastPosition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustler_lastPosition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createdAt":
			out.Values[i] = ec._GameHustler_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "relations":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustler_relations(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "items":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustler_items(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "quests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustler_quests(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameHustlerItemImplementors = []string{"GameHustlerItem", "Node"}

func (ec *executionContext) _GameHustlerItem(ctx context.Context, sel ast.SelectionSet, obj *ent.GameHustlerItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameHustlerItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameHustlerItem")
		case "id":
			out.Values[i] = ec._GameHustlerItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "item":
			out.Values[i] = ec._GameHustlerItem_item(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hustler":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustlerItem_hustler(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameHustlerQuestImplementors = []string{"GameHustlerQuest", "Node"}

func (ec *executionContext) _GameHustlerQuest(ctx context.Context, sel ast.SelectionSet, obj *ent.GameHustlerQuest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameHustlerQuestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameHustlerQuest")
		case "id":
			out.Values[i] = ec._GameHustlerQuest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "quest":
			out.Values[i] = ec._GameHustlerQuest_quest(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "completed":
			out.Values[i] = ec._GameHustlerQuest_completed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hustler":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustlerQuest_hustler(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gameHustlerRelationImplementors = []string{"GameHustlerRelation", "Node"}

func (ec *executionContext) _GameHustlerRelation(ctx context.Context, sel ast.SelectionSet, obj *ent.GameHustlerRelation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gameHustlerRelationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GameHustlerRelation")
		case "id":
			out.Values[i] = ec._GameHustlerRelation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "citizen":
			out.Values[i] = ec._GameHustlerRelation_citizen(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "conversation":
			out.Values[i] = ec._GameHustlerRelation_conversation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "text":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustlerRelation_text(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustler":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._GameHustlerRelation_hustler(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hustlerImplementors = []string{"Hustler", "SearchResult", "Node"}

func (ec *executionContext) _Hustler(ctx context.Context, sel ast.SelectionSet, obj *ent.Hustler) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hustlerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Hustler")
		case "id":
			out.Values[i] = ec._Hustler_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Hustler_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Hustler_name(ctx, field, obj)
		case "title":
			out.Values[i] = ec._Hustler_title(ctx, field, obj)
		case "color":
			out.Values[i] = ec._Hustler_color(ctx, field, obj)
		case "background":
			out.Values[i] = ec._Hustler_background(ctx, field, obj)
		case "age":
			out.Values[i] = ec._Hustler_age(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sex":
			out.Values[i] = ec._Hustler_sex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "viewbox":
			out.Values[i] = ec._Hustler_viewbox(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Hustler_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "svg":
			out.Values[i] = ec._Hustler_svg(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Hustler_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "bestAskPriceEth":
			out.Values[i] = ec._Hustler_bestAskPriceEth(ctx, field, obj)
		case "wallet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_wallet(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "weapon":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_weapon(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "clothes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_clothes(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vehicle":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_vehicle(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "waist":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_waist(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "foot":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_foot(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hand":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_hand(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "drug":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_drug(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "neck":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_neck(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ring":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_ring(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "accessory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_accessory(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "body":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_body(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hair":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_hair(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "beard":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_beard(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "index":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Hustler_index(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hustlerConnectionImplementors = []string{"HustlerConnection"}

func (ec *executionContext) _HustlerConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.HustlerConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hustlerConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HustlerConnection")
		case "edges":
			out.Values[i] = ec._HustlerConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._HustlerConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._HustlerConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hustlerEdgeImplementors = []string{"HustlerEdge"}

func (ec *executionContext) _HustlerEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.HustlerEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hustlerEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HustlerEdge")
		case "node":
			out.Values[i] = ec._HustlerEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._HustlerEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemImplementors = []string{"Item", "SearchResult", "Node"}

func (ec *executionContext) _Item(ctx context.Context, sel ast.SelectionSet, obj *ent.Item) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Item")
		case "id":
			out.Values[i] = ec._Item_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Item_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "namePrefix":
			out.Values[i] = ec._Item_namePrefix(ctx, field, obj)
		case "nameSuffix":
			out.Values[i] = ec._Item_nameSuffix(ctx, field, obj)
		case "name":
			out.Values[i] = ec._Item_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "suffix":
			out.Values[i] = ec._Item_suffix(ctx, field, obj)
		case "augmented":
			out.Values[i] = ec._Item_augmented(ctx, field, obj)
		case "count":
			out.Values[i] = ec._Item_count(ctx, field, obj)
		case "tier":
			out.Values[i] = ec._Item_tier(ctx, field, obj)
		case "greatness":
			out.Values[i] = ec._Item_greatness(ctx, field, obj)
		case "rles":
			out.Values[i] = ec._Item_rles(ctx, field, obj)
		case "svg":
			out.Values[i] = ec._Item_svg(ctx, field, obj)
		case "sprite":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_sprite(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bestAskPriceEth":
			out.Values[i] = ec._Item_bestAskPriceEth(ctx, field, obj)
		case "wallets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_wallets(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "dopes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_dopes(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerWeapons":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerWeapons(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerClothes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerClothes(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerVehicles":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerVehicles(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerWaists":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerWaists(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerFeet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerFeet(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerHands":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerHands(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerDrugs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerDrugs(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerNecks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerNecks(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerRings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerRings(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlerAccessories":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_hustlerAccessories(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "base":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_base(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "derivative":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_derivative(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "index":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_index(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "fullname":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Item_fullname(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemConnectionImplementors = []string{"ItemConnection"}

func (ec *executionContext) _ItemConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.ItemConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemConnection")
		case "edges":
			out.Values[i] = ec._ItemConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._ItemConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ItemConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var itemEdgeImplementors = []string{"ItemEdge"}

func (ec *executionContext) _ItemEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.ItemEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, itemEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ItemEdge")
		case "node":
			out.Values[i] = ec._ItemEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._ItemEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var pageInfoImplementors = []string{"PageInfo"}

func (ec *executionContext) _PageInfo(ctx context.Context, sel ast.SelectionSet, obj *entgql.PageInfo[string]) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, pageInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PageInfo")
		case "hasNextPage":
			out.Values[i] = ec._PageInfo_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPreviousPage":
			out.Values[i] = ec._PageInfo_hasPreviousPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startCursor":
			out.Values[i] = ec._PageInfo_startCursor(ctx, field, obj)
		case "endCursor":
			out.Values[i] = ec._PageInfo_endCursor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "node":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_node(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "nodes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_nodes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "bodyParts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bodyParts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "dopes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_dopes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hustlers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hustlers(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "items":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_items(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "wallets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_wallets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "walletItems":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_walletItems(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "search":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_search(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchImplementors = []string{"Search", "Node"}

func (ec *executionContext) _Search(ctx context.Context, sel ast.SelectionSet, obj *ent.Search) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Search")
		case "id":
			out.Values[i] = ec._Search_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Search_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "greatness":
			out.Values[i] = ec._Search_greatness(ctx, field, obj)
		case "claimed":
			out.Values[i] = ec._Search_claimed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "opened":
			out.Values[i] = ec._Search_opened(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "banned":
			out.Values[i] = ec._Search_banned(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "salePrice":
			out.Values[i] = ec._Search_salePrice(ctx, field, obj)
		case "dope":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Search_dope(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "item":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Search_item(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustler":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Search_hustler(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchConnectionImplementors = []string{"SearchConnection"}

func (ec *executionContext) _SearchConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.SearchConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchConnection")
		case "edges":
			out.Values[i] = ec._SearchConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._SearchConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._SearchConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchEdgeImplementors = []string{"SearchEdge"}

func (ec *executionContext) _SearchEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.SearchEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchEdge")
		case "node":
			out.Values[i] = ec._SearchEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._SearchEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var syncStateImplementors = []string{"SyncState", "Node"}

func (ec *executionContext) _SyncState(ctx context.Context, sel ast.SelectionSet, obj *ent.SyncState) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, syncStateImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SyncState")
		case "id":
			out.Values[i] = ec._SyncState_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "contractName":
			out.Values[i] = ec._SyncState_contractName(ctx, field, obj)
		case "startBlock":
			out.Values[i] = ec._SyncState_startBlock(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "blockTime":
			out.Values[i] = ec._SyncState_blockTime(ctx, field, obj)
		case "lastSyncedAt":
			out.Values[i] = ec._SyncState_lastSyncedAt(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletImplementors = []string{"Wallet", "Node"}

func (ec *executionContext) _Wallet(ctx context.Context, sel ast.SelectionSet, obj *ent.Wallet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Wallet")
		case "id":
			out.Values[i] = ec._Wallet_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "paper":
			out.Values[i] = ec._Wallet_paper(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastSetPaperBalanceAt":
			out.Values[i] = ec._Wallet_lastSetPaperBalanceAt(ctx, field, obj)
		case "createdAt":
			out.Values[i] = ec._Wallet_createdAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dopes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_dopes(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "items":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_items(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hustlers":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Wallet_hustlers(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletConnectionImplementors = []string{"WalletConnection"}

func (ec *executionContext) _WalletConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletConnection")
		case "edges":
			out.Values[i] = ec._WalletConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._WalletConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._WalletConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletEdgeImplementors = []string{"WalletEdge"}

func (ec *executionContext) _WalletEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletEdge")
		case "node":
			out.Values[i] = ec._WalletEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._WalletEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletItemsImplementors = []string{"WalletItems", "Node"}

func (ec *executionContext) _WalletItems(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletItems) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletItemsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletItems")
		case "id":
			out.Values[i] = ec._WalletItems_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "balance":
			out.Values[i] = ec._WalletItems_balance(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "wallet":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WalletItems_wallet(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "item":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._WalletItems_item(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletItemsConnectionImplementors = []string{"WalletItemsConnection"}

func (ec *executionContext) _WalletItemsConnection(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletItemsConnection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletItemsConnectionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletItemsConnection")
		case "edges":
			out.Values[i] = ec._WalletItemsConnection_edges(ctx, field, obj)
		case "pageInfo":
			out.Values[i] = ec._WalletItemsConnection_pageInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._WalletItemsConnection_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var walletItemsEdgeImplementors = []string{"WalletItemsEdge"}

func (ec *executionContext) _WalletItemsEdge(ctx context.Context, sel ast.SelectionSet, obj *ent.WalletItemsEdge) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, walletItemsEdgeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WalletItemsEdge")
		case "node":
			out.Values[i] = ec._WalletItemsEdge_node(ctx, field, obj)
		case "cursor":
			out.Values[i] = ec._WalletItemsEdge_cursor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBodyPartBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, v interface{}) (bodypart.Sex, error) {
	var res bodypart.Sex
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBodyPartBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, sel ast.SelectionSet, v bodypart.Sex) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNBodyPartBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, v interface{}) (bodypart.Type, error) {
	var res bodypart.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBodyPartBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, sel ast.SelectionSet, v bodypart.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNBodyPartConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartConnection(ctx context.Context, sel ast.SelectionSet, v ent.BodyPartConnection) graphql.Marshaler {
	return ec._BodyPartConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNBodyPartConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartConnection(ctx context.Context, sel ast.SelectionSet, v *ent.BodyPartConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BodyPartConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx context.Context, v interface{}) (*ent.BodyPartWhereInput, error) {
	res, err := ec.unmarshalInputBodyPartWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (entgql.Cursor[string], error) {
	var res entgql.Cursor[string]
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCursor2entgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v entgql.Cursor[string]) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx context.Context, sel ast.SelectionSet, v *ent.Dope) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dope(ctx, sel, v)
}

func (ec *executionContext) marshalNDopeConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeConnection(ctx context.Context, sel ast.SelectionSet, v ent.DopeConnection) graphql.Marshaler {
	return ec._DopeConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNDopeConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeConnection(ctx context.Context, sel ast.SelectionSet, v *ent.DopeConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DopeConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDopeOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrderField(ctx context.Context, v interface{}) (*ent.DopeOrderField, error) {
	var res = new(ent.DopeOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDopeOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.DopeOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNDopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx context.Context, v interface{}) (*ent.DopeWhereInput, error) {
	res, err := ec.unmarshalInputDopeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx context.Context, v interface{}) (*ent.EventWhereInput, error) {
	res, err := ec.unmarshalInputEventWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGameHustlerItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItem(ctx context.Context, sel ast.SelectionSet, v *ent.GameHustlerItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameHustlerItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerItemWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGameHustlerOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerOrderField(ctx context.Context, v interface{}) (*ent.GameHustlerOrderField, error) {
	var res = new(ent.GameHustlerOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGameHustlerOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.GameHustlerOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalNGameHustlerQuest2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuest(ctx context.Context, sel ast.SelectionSet, v *ent.GameHustlerQuest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameHustlerQuest(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerQuestWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerQuestWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGameHustlerRelation2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelation(ctx context.Context, sel ast.SelectionSet, v *ent.GameHustlerRelation) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GameHustlerRelation(ctx, sel, v)
}

func (ec *executionContext) unmarshalNGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerRelationWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerRelationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerWhereInput, error) {
	res, err := ec.unmarshalInputGameHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx context.Context, sel ast.SelectionSet, v *ent.Hustler) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Hustler(ctx, sel, v)
}

func (ec *executionContext) marshalNHustlerConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerConnection(ctx context.Context, sel ast.SelectionSet, v ent.HustlerConnection) graphql.Marshaler {
	return ec._HustlerConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNHustlerConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerConnection(ctx context.Context, sel ast.SelectionSet, v *ent.HustlerConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HustlerConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHustlerHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, v interface{}) (hustler.Sex, error) {
	var res hustler.Sex
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustlerHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, sel ast.SelectionSet, v hustler.Sex) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHustlerHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, v interface{}) (hustler.Type, error) {
	var res hustler.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustlerHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, sel ast.SelectionSet, v hustler.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNHustlerOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrderField(ctx context.Context, v interface{}) (*ent.HustlerOrderField, error) {
	var res = new(ent.HustlerOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHustlerOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.HustlerOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx context.Context, v interface{}) (*ent.HustlerWhereInput, error) {
	res, err := ec.unmarshalInputHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx context.Context, sel ast.SelectionSet, v *ent.Item) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) marshalNItemConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemConnection(ctx context.Context, sel ast.SelectionSet, v ent.ItemConnection) graphql.Marshaler {
	return ec._ItemConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNItemConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemConnection(ctx context.Context, sel ast.SelectionSet, v *ent.ItemConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ItemConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, v interface{}) (item.Tier, error) {
	var res item.Tier
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, sel ast.SelectionSet, v item.Tier) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, v interface{}) (item.Type, error) {
	var res item.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, sel ast.SelectionSet, v item.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNItemOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrderField(ctx context.Context, v interface{}) (*ent.ItemOrderField, error) {
	var res = new(ent.ItemOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNItemOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.ItemOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx context.Context, v interface{}) (*ent.ItemWhereInput, error) {
	res, err := ec.unmarshalInputItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNode2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v []ent.Noder) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalONode2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, v interface{}) (entgql.OrderDirection, error) {
	var res entgql.OrderDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOrderDirection2entgoᚗioᚋcontribᚋentgqlᚐOrderDirection(ctx context.Context, sel ast.SelectionSet, v entgql.OrderDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPageInfo2entgoᚗioᚋcontribᚋentgqlᚐPageInfo(ctx context.Context, sel ast.SelectionSet, v entgql.PageInfo[string]) graphql.Marshaler {
	return ec._PageInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchConnection(ctx context.Context, sel ast.SelectionSet, v ent.SearchConnection) graphql.Marshaler {
	return ec._SearchConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNSearchConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchConnection(ctx context.Context, sel ast.SelectionSet, v *ent.SearchConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SearchConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSearchOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrderField(ctx context.Context, v interface{}) (*ent.SearchOrderField, error) {
	var res = new(ent.SearchOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.SearchOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNSearchSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, v interface{}) (search.Type, error) {
	var res search.Type
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSearchSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, sel ast.SelectionSet, v search.Type) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx context.Context, v interface{}) (*ent.SearchWhereInput, error) {
	res, err := ec.unmarshalInputSearchWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx context.Context, v interface{}) (*ent.SyncStateWhereInput, error) {
	res, err := ec.unmarshalInputSyncStateWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNWalletConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletConnection(ctx context.Context, sel ast.SelectionSet, v ent.WalletConnection) graphql.Marshaler {
	return ec._WalletConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWalletConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletConnection(ctx context.Context, sel ast.SelectionSet, v *ent.WalletConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletConnection(ctx, sel, v)
}

func (ec *executionContext) marshalNWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItems) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletItems(ctx, sel, v)
}

func (ec *executionContext) marshalNWalletItemsConnection2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsConnection(ctx context.Context, sel ast.SelectionSet, v ent.WalletItemsConnection) graphql.Marshaler {
	return ec._WalletItemsConnection(ctx, sel, &v)
}

func (ec *executionContext) marshalNWalletItemsConnection2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsConnection(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItemsConnection) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WalletItemsConnection(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx context.Context, v interface{}) (*ent.WalletItemsWhereInput, error) {
	res, err := ec.unmarshalInputWalletItemsWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWalletOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrderField(ctx context.Context, v interface{}) (*ent.WalletOrderField, error) {
	var res = new(ent.WalletOrderField)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWalletOrderField2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrderField(ctx context.Context, sel ast.SelectionSet, v *ent.WalletOrderField) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalNWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx context.Context, v interface{}) (*ent.WalletWhereInput, error) {
	res, err := ec.unmarshalInputWalletWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBodyPart2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPart(ctx context.Context, sel ast.SelectionSet, v *ent.BodyPart) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BodyPart(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBodyPartBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx context.Context, v interface{}) ([]bodypart.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]bodypart.Sex, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyPartBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBodyPartBodyPartSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSexᚄ(ctx context.Context, sel ast.SelectionSet, v []bodypart.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBodyPartBodyPartSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBodyPartBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, v interface{}) (*bodypart.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(bodypart.Sex)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBodyPartBodyPartSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐSex(ctx context.Context, sel ast.SelectionSet, v *bodypart.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOBodyPartBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx context.Context, v interface{}) ([]bodypart.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]bodypart.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyPartBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOBodyPartBodyPartType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []bodypart.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBodyPartBodyPartType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOBodyPartBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, v interface{}) (*bodypart.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(bodypart.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBodyPartBodyPartType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋbodypartᚐType(ctx context.Context, sel ast.SelectionSet, v *bodypart.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalOBodyPartEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.BodyPartEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBodyPartEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBodyPartEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartEdge(ctx context.Context, sel ast.SelectionSet, v *ent.BodyPartEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BodyPartEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBodyPartWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.BodyPartWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.BodyPartWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBodyPartWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐBodyPartWhereInput(ctx context.Context, v interface{}) (*ent.BodyPartWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBodyPartWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, v interface{}) (*entgql.Cursor[string], error) {
	if v == nil {
		return nil, nil
	}
	var res = new(entgql.Cursor[string])
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOCursor2ᚖentgoᚗioᚋcontribᚋentgqlᚐCursor(ctx context.Context, sel ast.SelectionSet, v *entgql.Cursor[string]) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) marshalODope2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Dope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODope2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDope(ctx context.Context, sel ast.SelectionSet, v *ent.Dope) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Dope(ctx, sel, v)
}

func (ec *executionContext) marshalODopeEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.DopeEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODopeEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalODopeEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeEdge(ctx context.Context, sel ast.SelectionSet, v *ent.DopeEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DopeEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalODopeOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeOrder(ctx context.Context, v interface{}) (*ent.DopeOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDopeOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalODopeWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.DopeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.DopeWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalODopeWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐDopeWhereInput(ctx context.Context, v interface{}) (*ent.DopeWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputDopeWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOEventWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.EventWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.EventWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOEventWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐEventWhereInput(ctx context.Context, v interface{}) (*ent.EventWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEventWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGameHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustler(ctx context.Context, sel ast.SelectionSet, v *ent.GameHustler) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GameHustler(ctx, sel, v)
}

func (ec *executionContext) marshalOGameHustlerItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.GameHustlerItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGameHustlerItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGameHustlerItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerItemWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerItemWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGameHustlerQuest2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.GameHustlerQuest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGameHustlerQuest2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGameHustlerQuestWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerQuestWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerQuestWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerQuestWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerQuestWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerQuestWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerQuestWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGameHustlerRelation2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.GameHustlerRelation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGameHustlerRelation2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelation(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOGameHustlerRelationWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerRelationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerRelationWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerRelationWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerRelationWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerRelationWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerRelationWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGameHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.GameHustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.GameHustlerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOGameHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐGameHustlerWhereInput(ctx context.Context, v interface{}) (*ent.GameHustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGameHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHustler2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Hustler) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOHustler2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustler(ctx context.Context, sel ast.SelectionSet, v *ent.Hustler) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Hustler(ctx, sel, v)
}

func (ec *executionContext) marshalOHustlerEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.HustlerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOHustlerEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOHustlerEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerEdge(ctx context.Context, sel ast.SelectionSet, v *ent.HustlerEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HustlerEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHustlerHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx context.Context, v interface{}) ([]hustler.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]hustler.Sex, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHustlerHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHustlerHustlerSex2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSexᚄ(ctx context.Context, sel ast.SelectionSet, v []hustler.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHustlerHustlerSex2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHustlerHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, v interface{}) (*hustler.Sex, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(hustler.Sex)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHustlerHustlerSex2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐSex(ctx context.Context, sel ast.SelectionSet, v *hustler.Sex) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOHustlerHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx context.Context, v interface{}) ([]hustler.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]hustler.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHustlerHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHustlerHustlerType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []hustler.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHustlerHustlerType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOHustlerHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, v interface{}) (*hustler.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(hustler.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHustlerHustlerType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋhustlerᚐType(ctx context.Context, sel ast.SelectionSet, v *hustler.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOHustlerOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerOrder(ctx context.Context, v interface{}) (*ent.HustlerOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHustlerOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHustlerWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.HustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.HustlerWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOHustlerWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐHustlerWhereInput(ctx context.Context, v interface{}) (*ent.HustlerWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHustlerWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItem2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOItem2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItem(ctx context.Context, sel ast.SelectionSet, v *ent.Item) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Item(ctx, sel, v)
}

func (ec *executionContext) marshalOItemEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.ItemEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOItemEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOItemEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemEdge(ctx context.Context, sel ast.SelectionSet, v *ent.ItemEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ItemEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, v interface{}) (item.Tier, error) {
	var res item.Tier
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, sel ast.SelectionSet, v item.Tier) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalOItemItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx context.Context, v interface{}) ([]item.Tier, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]item.Tier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOItemItemTier2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTierᚄ(ctx context.Context, sel ast.SelectionSet, v []item.Tier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemItemTier2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOItemItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, v interface{}) (*item.Tier, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(item.Tier)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemItemTier2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTier(ctx context.Context, sel ast.SelectionSet, v *item.Tier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx context.Context, v interface{}) ([]item.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]item.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNItemItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOItemItemType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []item.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNItemItemType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOItemItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, v interface{}) (*item.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(item.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOItemItemType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋitemᚐType(ctx context.Context, sel ast.SelectionSet, v *item.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOItemOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemOrder(ctx context.Context, v interface{}) (*ent.ItemOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputItemOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOItemWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.ItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.ItemWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOItemWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐItemWhereInput(ctx context.Context, v interface{}) (*ent.ItemWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputItemWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONode2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐNoder(ctx context.Context, sel ast.SelectionSet, v ent.Noder) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Node(ctx, sel, v)
}

func (ec *executionContext) marshalOSearch2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearch(ctx context.Context, sel ast.SelectionSet, v *ent.Search) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Search(ctx, sel, v)
}

func (ec *executionContext) marshalOSearchEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.SearchEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOSearchEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOSearchEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchEdge(ctx context.Context, sel ast.SelectionSet, v *ent.SearchEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSearchOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchOrder(ctx context.Context, v interface{}) (*ent.SearchOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSearchSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx context.Context, v interface{}) ([]search.Type, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]search.Type, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSearchSearchType2ᚕgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []search.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSearchSearchType2githubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOSearchSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, v interface{}) (*search.Type, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(search.Type)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchSearchType2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚋsearchᚐType(ctx context.Context, sel ast.SelectionSet, v *search.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSearchWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.SearchWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SearchWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSearchWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSearchWhereInput(ctx context.Context, v interface{}) (*ent.SearchWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSearchWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSyncStateWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.SyncStateWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.SyncStateWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOSyncStateWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐSyncStateWhereInput(ctx context.Context, v interface{}) (*ent.SyncStateWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSyncStateWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, v interface{}) ([]time.Time, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]time.Time, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTime2timeᚐTime(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTime2ᚕtimeᚐTimeᚄ(ctx context.Context, sel ast.SelectionSet, v []time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNTime2timeᚐTime(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOWallet2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWallet(ctx context.Context, sel ast.SelectionSet, v *ent.Wallet) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Wallet(ctx, sel, v)
}

func (ec *executionContext) marshalOWalletEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.WalletEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWalletEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOWalletEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletEdge(ctx context.Context, sel ast.SelectionSet, v *ent.WalletEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WalletEdge(ctx, sel, v)
}

func (ec *executionContext) marshalOWalletItems2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsᚄ(ctx context.Context, sel ast.SelectionSet, v []*ent.WalletItems) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOWalletItems2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItems(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItems) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WalletItems(ctx, sel, v)
}

func (ec *executionContext) marshalOWalletItemsEdge2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx context.Context, sel ast.SelectionSet, v []*ent.WalletItemsEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWalletItemsEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOWalletItemsEdge2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsEdge(ctx context.Context, sel ast.SelectionSet, v *ent.WalletItemsEdge) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WalletItemsEdge(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWalletItemsWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WalletItemsWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WalletItemsWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWalletItemsWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletItemsWhereInput(ctx context.Context, v interface{}) (*ent.WalletItemsWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletItemsWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWalletOrder2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletOrder(ctx context.Context, v interface{}) (*ent.WalletOrder, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWalletWhereInput2ᚕᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInputᚄ(ctx context.Context, v interface{}) ([]*ent.WalletWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*ent.WalletWhereInput, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOWalletWhereInput2ᚖgithubᚗcomᚋdopedaoᚋdopeᚑmonorepoᚋpackagesᚋapiᚋinternalᚋentᚐWalletWhereInput(ctx context.Context, v interface{}) (*ent.WalletWhereInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWalletWhereInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

// endregion ***************************** type.gotpl *****************************
