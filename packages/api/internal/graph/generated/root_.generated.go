// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Event() EventResolver
	GameHustler() GameHustlerResolver
	GameHustlerRelation() GameHustlerRelationResolver
	Item() ItemResolver
	Query() QueryResolver
	GameHustlerRelationWhereInput() GameHustlerRelationWhereInputResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	BodyPart struct {
		HustlerBeards func(childComplexity int) int
		HustlerBodies func(childComplexity int) int
		HustlerHairs  func(childComplexity int) int
		ID            func(childComplexity int) int
		Rle           func(childComplexity int) int
		Sex           func(childComplexity int) int
		Sprite        func(childComplexity int) int
		Type          func(childComplexity int) int
	}

	BodyPartConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	BodyPartEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Dope struct {
		BestAskPriceEth       func(childComplexity int) int
		Claimed               func(childComplexity int) int
		ID                    func(childComplexity int) int
		Index                 func(childComplexity int) int
		Items                 func(childComplexity int) int
		LastCheckedGearClaim  func(childComplexity int) int
		LastCheckedPaperClaim func(childComplexity int) int
		Opened                func(childComplexity int) int
		Order                 func(childComplexity int) int
		Rank                  func(childComplexity int) int
		Score                 func(childComplexity int) int
		Wallet                func(childComplexity int) int
	}

	DopeConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	DopeEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Event struct {
		Address   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		Hash      func(childComplexity int) int
		ID        func(childComplexity int) int
		Index     func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	GameHustler struct {
		CreatedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Items        func(childComplexity int) int
		LastPosition func(childComplexity int) int
		Quests       func(childComplexity int) int
		Relations    func(childComplexity int) int
	}

	GameHustlerItem struct {
		Hustler func(childComplexity int) int
		ID      func(childComplexity int) int
		Item    func(childComplexity int) int
	}

	GameHustlerQuest struct {
		Completed func(childComplexity int) int
		Hustler   func(childComplexity int) int
		ID        func(childComplexity int) int
		Quest     func(childComplexity int) int
	}

	GameHustlerRelation struct {
		Citizen      func(childComplexity int) int
		Conversation func(childComplexity int) int
		Hustler      func(childComplexity int) int
		ID           func(childComplexity int) int
		Text         func(childComplexity int) int
	}

	Hash struct {
		Value func(childComplexity int) int
	}

	Hustler struct {
		Accessory       func(childComplexity int) int
		Age             func(childComplexity int) int
		Background      func(childComplexity int) int
		Beard           func(childComplexity int) int
		BestAskPriceEth func(childComplexity int) int
		Body            func(childComplexity int) int
		Clothes         func(childComplexity int) int
		Color           func(childComplexity int) int
		CreatedAt       func(childComplexity int) int
		Drug            func(childComplexity int) int
		Foot            func(childComplexity int) int
		Hair            func(childComplexity int) int
		Hand            func(childComplexity int) int
		ID              func(childComplexity int) int
		Index           func(childComplexity int) int
		Name            func(childComplexity int) int
		Neck            func(childComplexity int) int
		Order           func(childComplexity int) int
		Ring            func(childComplexity int) int
		Sex             func(childComplexity int) int
		Svg             func(childComplexity int) int
		Title           func(childComplexity int) int
		Type            func(childComplexity int) int
		Vehicle         func(childComplexity int) int
		Viewbox         func(childComplexity int) int
		Waist           func(childComplexity int) int
		Wallet          func(childComplexity int) int
		Weapon          func(childComplexity int) int
	}

	HustlerConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	HustlerEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Item struct {
		Augmented          func(childComplexity int) int
		Base               func(childComplexity int) int
		BestAskPriceEth    func(childComplexity int) int
		Count              func(childComplexity int) int
		Derivative         func(childComplexity int) int
		Dopes              func(childComplexity int) int
		Fullname           func(childComplexity int) int
		Greatness          func(childComplexity int) int
		HustlerAccessories func(childComplexity int) int
		HustlerClothes     func(childComplexity int) int
		HustlerDrugs       func(childComplexity int) int
		HustlerFeet        func(childComplexity int) int
		HustlerHands       func(childComplexity int) int
		HustlerNecks       func(childComplexity int) int
		HustlerRings       func(childComplexity int) int
		HustlerVehicles    func(childComplexity int) int
		HustlerWaists      func(childComplexity int) int
		HustlerWeapons     func(childComplexity int) int
		ID                 func(childComplexity int) int
		Index              func(childComplexity int) int
		Name               func(childComplexity int) int
		NamePrefix         func(childComplexity int) int
		NameSuffix         func(childComplexity int) int
		Rles               func(childComplexity int) int
		Sprite             func(childComplexity int) int
		Suffix             func(childComplexity int) int
		Svg                func(childComplexity int) int
		Tier               func(childComplexity int) int
		Type               func(childComplexity int) int
		Wallets            func(childComplexity int) int
	}

	ItemConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	ItemEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Position struct {
		CurrentMap func(childComplexity int) int
		X          func(childComplexity int) int
		Y          func(childComplexity int) int
	}

	Query struct {
		BodyParts   func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *ent.BodyPartWhereInput) int
		Dopes       func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.DopeOrder, where *ent.DopeWhereInput) int
		Hustlers    func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.HustlerOrder, where *ent.HustlerWhereInput) int
		Items       func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.ItemOrder, where *ent.ItemWhereInput) int
		Node        func(childComplexity int, id string) int
		Nodes       func(childComplexity int, ids []string) int
		Search      func(childComplexity int, query string, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.SearchOrder, where *ent.SearchWhereInput) int
		WalletItems func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, where *ent.WalletItemsWhereInput) int
		Wallets     func(childComplexity int, after *entgql.Cursor[string], first *int, before *entgql.Cursor[string], last *int, orderBy *ent.WalletOrder, where *ent.WalletWhereInput) int
	}

	RLEs struct {
		Female func(childComplexity int) int
		Male   func(childComplexity int) int
	}

	Search struct {
		Banned    func(childComplexity int) int
		Claimed   func(childComplexity int) int
		Dope      func(childComplexity int) int
		Greatness func(childComplexity int) int
		Hustler   func(childComplexity int) int
		ID        func(childComplexity int) int
		Item      func(childComplexity int) int
		Opened    func(childComplexity int) int
		SalePrice func(childComplexity int) int
		Type      func(childComplexity int) int
	}

	SearchConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	SearchEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	Sprites struct {
		Female func(childComplexity int) int
		Male   func(childComplexity int) int
	}

	SyncState struct {
		BlockTime    func(childComplexity int) int
		ContractName func(childComplexity int) int
		ID           func(childComplexity int) int
		LastSyncedAt func(childComplexity int) int
		StartBlock   func(childComplexity int) int
	}

	Wallet struct {
		CreatedAt             func(childComplexity int) int
		Dopes                 func(childComplexity int) int
		Hustlers              func(childComplexity int) int
		ID                    func(childComplexity int) int
		Items                 func(childComplexity int) int
		LastSetPaperBalanceAt func(childComplexity int) int
		Paper                 func(childComplexity int) int
	}

	WalletConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	WalletEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	WalletItems struct {
		Balance func(childComplexity int) int
		ID      func(childComplexity int) int
		Item    func(childComplexity int) int
		Wallet  func(childComplexity int) int
	}

	WalletItemsConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	WalletItemsEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "BodyPart.hustlerBeards":
		if e.complexity.BodyPart.HustlerBeards == nil {
			break
		}

		return e.complexity.BodyPart.HustlerBeards(childComplexity), true

	case "BodyPart.hustlerBodies":
		if e.complexity.BodyPart.HustlerBodies == nil {
			break
		}

		return e.complexity.BodyPart.HustlerBodies(childComplexity), true

	case "BodyPart.hustlerHairs":
		if e.complexity.BodyPart.HustlerHairs == nil {
			break
		}

		return e.complexity.BodyPart.HustlerHairs(childComplexity), true

	case "BodyPart.id":
		if e.complexity.BodyPart.ID == nil {
			break
		}

		return e.complexity.BodyPart.ID(childComplexity), true

	case "BodyPart.rle":
		if e.complexity.BodyPart.Rle == nil {
			break
		}

		return e.complexity.BodyPart.Rle(childComplexity), true

	case "BodyPart.sex":
		if e.complexity.BodyPart.Sex == nil {
			break
		}

		return e.complexity.BodyPart.Sex(childComplexity), true

	case "BodyPart.sprite":
		if e.complexity.BodyPart.Sprite == nil {
			break
		}

		return e.complexity.BodyPart.Sprite(childComplexity), true

	case "BodyPart.type":
		if e.complexity.BodyPart.Type == nil {
			break
		}

		return e.complexity.BodyPart.Type(childComplexity), true

	case "BodyPartConnection.edges":
		if e.complexity.BodyPartConnection.Edges == nil {
			break
		}

		return e.complexity.BodyPartConnection.Edges(childComplexity), true

	case "BodyPartConnection.pageInfo":
		if e.complexity.BodyPartConnection.PageInfo == nil {
			break
		}

		return e.complexity.BodyPartConnection.PageInfo(childComplexity), true

	case "BodyPartConnection.totalCount":
		if e.complexity.BodyPartConnection.TotalCount == nil {
			break
		}

		return e.complexity.BodyPartConnection.TotalCount(childComplexity), true

	case "BodyPartEdge.cursor":
		if e.complexity.BodyPartEdge.Cursor == nil {
			break
		}

		return e.complexity.BodyPartEdge.Cursor(childComplexity), true

	case "BodyPartEdge.node":
		if e.complexity.BodyPartEdge.Node == nil {
			break
		}

		return e.complexity.BodyPartEdge.Node(childComplexity), true

	case "Dope.bestAskPriceEth":
		if e.complexity.Dope.BestAskPriceEth == nil {
			break
		}

		return e.complexity.Dope.BestAskPriceEth(childComplexity), true

	case "Dope.claimed":
		if e.complexity.Dope.Claimed == nil {
			break
		}

		return e.complexity.Dope.Claimed(childComplexity), true

	case "Dope.id":
		if e.complexity.Dope.ID == nil {
			break
		}

		return e.complexity.Dope.ID(childComplexity), true

	case "Dope.index":
		if e.complexity.Dope.Index == nil {
			break
		}

		return e.complexity.Dope.Index(childComplexity), true

	case "Dope.items":
		if e.complexity.Dope.Items == nil {
			break
		}

		return e.complexity.Dope.Items(childComplexity), true

	case "Dope.lastCheckedGearClaim":
		if e.complexity.Dope.LastCheckedGearClaim == nil {
			break
		}

		return e.complexity.Dope.LastCheckedGearClaim(childComplexity), true

	case "Dope.lastCheckedPaperClaim":
		if e.complexity.Dope.LastCheckedPaperClaim == nil {
			break
		}

		return e.complexity.Dope.LastCheckedPaperClaim(childComplexity), true

	case "Dope.opened":
		if e.complexity.Dope.Opened == nil {
			break
		}

		return e.complexity.Dope.Opened(childComplexity), true

	case "Dope.order":
		if e.complexity.Dope.Order == nil {
			break
		}

		return e.complexity.Dope.Order(childComplexity), true

	case "Dope.rank":
		if e.complexity.Dope.Rank == nil {
			break
		}

		return e.complexity.Dope.Rank(childComplexity), true

	case "Dope.score":
		if e.complexity.Dope.Score == nil {
			break
		}

		return e.complexity.Dope.Score(childComplexity), true

	case "Dope.wallet":
		if e.complexity.Dope.Wallet == nil {
			break
		}

		return e.complexity.Dope.Wallet(childComplexity), true

	case "DopeConnection.edges":
		if e.complexity.DopeConnection.Edges == nil {
			break
		}

		return e.complexity.DopeConnection.Edges(childComplexity), true

	case "DopeConnection.pageInfo":
		if e.complexity.DopeConnection.PageInfo == nil {
			break
		}

		return e.complexity.DopeConnection.PageInfo(childComplexity), true

	case "DopeConnection.totalCount":
		if e.complexity.DopeConnection.TotalCount == nil {
			break
		}

		return e.complexity.DopeConnection.TotalCount(childComplexity), true

	case "DopeEdge.cursor":
		if e.complexity.DopeEdge.Cursor == nil {
			break
		}

		return e.complexity.DopeEdge.Cursor(childComplexity), true

	case "DopeEdge.node":
		if e.complexity.DopeEdge.Node == nil {
			break
		}

		return e.complexity.DopeEdge.Node(childComplexity), true

	case "Event.address":
		if e.complexity.Event.Address == nil {
			break
		}

		return e.complexity.Event.Address(childComplexity), true

	case "Event.createdAt":
		if e.complexity.Event.CreatedAt == nil {
			break
		}

		return e.complexity.Event.CreatedAt(childComplexity), true

	case "Event.hash":
		if e.complexity.Event.Hash == nil {
			break
		}

		return e.complexity.Event.Hash(childComplexity), true

	case "Event.id":
		if e.complexity.Event.ID == nil {
			break
		}

		return e.complexity.Event.ID(childComplexity), true

	case "Event.index":
		if e.complexity.Event.Index == nil {
			break
		}

		return e.complexity.Event.Index(childComplexity), true

	case "Event.updatedAt":
		if e.complexity.Event.UpdatedAt == nil {
			break
		}

		return e.complexity.Event.UpdatedAt(childComplexity), true

	case "GameHustler.createdAt":
		if e.complexity.GameHustler.CreatedAt == nil {
			break
		}

		return e.complexity.GameHustler.CreatedAt(childComplexity), true

	case "GameHustler.id":
		if e.complexity.GameHustler.ID == nil {
			break
		}

		return e.complexity.GameHustler.ID(childComplexity), true

	case "GameHustler.items":
		if e.complexity.GameHustler.Items == nil {
			break
		}

		return e.complexity.GameHustler.Items(childComplexity), true

	case "GameHustler.lastPosition":
		if e.complexity.GameHustler.LastPosition == nil {
			break
		}

		return e.complexity.GameHustler.LastPosition(childComplexity), true

	case "GameHustler.quests":
		if e.complexity.GameHustler.Quests == nil {
			break
		}

		return e.complexity.GameHustler.Quests(childComplexity), true

	case "GameHustler.relations":
		if e.complexity.GameHustler.Relations == nil {
			break
		}

		return e.complexity.GameHustler.Relations(childComplexity), true

	case "GameHustlerItem.hustler":
		if e.complexity.GameHustlerItem.Hustler == nil {
			break
		}

		return e.complexity.GameHustlerItem.Hustler(childComplexity), true

	case "GameHustlerItem.id":
		if e.complexity.GameHustlerItem.ID == nil {
			break
		}

		return e.complexity.GameHustlerItem.ID(childComplexity), true

	case "GameHustlerItem.item":
		if e.complexity.GameHustlerItem.Item == nil {
			break
		}

		return e.complexity.GameHustlerItem.Item(childComplexity), true

	case "GameHustlerQuest.completed":
		if e.complexity.GameHustlerQuest.Completed == nil {
			break
		}

		return e.complexity.GameHustlerQuest.Completed(childComplexity), true

	case "GameHustlerQuest.hustler":
		if e.complexity.GameHustlerQuest.Hustler == nil {
			break
		}

		return e.complexity.GameHustlerQuest.Hustler(childComplexity), true

	case "GameHustlerQuest.id":
		if e.complexity.GameHustlerQuest.ID == nil {
			break
		}

		return e.complexity.GameHustlerQuest.ID(childComplexity), true

	case "GameHustlerQuest.quest":
		if e.complexity.GameHustlerQuest.Quest == nil {
			break
		}

		return e.complexity.GameHustlerQuest.Quest(childComplexity), true

	case "GameHustlerRelation.citizen":
		if e.complexity.GameHustlerRelation.Citizen == nil {
			break
		}

		return e.complexity.GameHustlerRelation.Citizen(childComplexity), true

	case "GameHustlerRelation.conversation":
		if e.complexity.GameHustlerRelation.Conversation == nil {
			break
		}

		return e.complexity.GameHustlerRelation.Conversation(childComplexity), true

	case "GameHustlerRelation.hustler":
		if e.complexity.GameHustlerRelation.Hustler == nil {
			break
		}

		return e.complexity.GameHustlerRelation.Hustler(childComplexity), true

	case "GameHustlerRelation.id":
		if e.complexity.GameHustlerRelation.ID == nil {
			break
		}

		return e.complexity.GameHustlerRelation.ID(childComplexity), true

	case "GameHustlerRelation.text":
		if e.complexity.GameHustlerRelation.Text == nil {
			break
		}

		return e.complexity.GameHustlerRelation.Text(childComplexity), true

	case "Hash.value":
		if e.complexity.Hash.Value == nil {
			break
		}

		return e.complexity.Hash.Value(childComplexity), true

	case "Hustler.accessory":
		if e.complexity.Hustler.Accessory == nil {
			break
		}

		return e.complexity.Hustler.Accessory(childComplexity), true

	case "Hustler.age":
		if e.complexity.Hustler.Age == nil {
			break
		}

		return e.complexity.Hustler.Age(childComplexity), true

	case "Hustler.background":
		if e.complexity.Hustler.Background == nil {
			break
		}

		return e.complexity.Hustler.Background(childComplexity), true

	case "Hustler.beard":
		if e.complexity.Hustler.Beard == nil {
			break
		}

		return e.complexity.Hustler.Beard(childComplexity), true

	case "Hustler.bestAskPriceEth":
		if e.complexity.Hustler.BestAskPriceEth == nil {
			break
		}

		return e.complexity.Hustler.BestAskPriceEth(childComplexity), true

	case "Hustler.body":
		if e.complexity.Hustler.Body == nil {
			break
		}

		return e.complexity.Hustler.Body(childComplexity), true

	case "Hustler.clothes":
		if e.complexity.Hustler.Clothes == nil {
			break
		}

		return e.complexity.Hustler.Clothes(childComplexity), true

	case "Hustler.color":
		if e.complexity.Hustler.Color == nil {
			break
		}

		return e.complexity.Hustler.Color(childComplexity), true

	case "Hustler.createdAt":
		if e.complexity.Hustler.CreatedAt == nil {
			break
		}

		return e.complexity.Hustler.CreatedAt(childComplexity), true

	case "Hustler.drug":
		if e.complexity.Hustler.Drug == nil {
			break
		}

		return e.complexity.Hustler.Drug(childComplexity), true

	case "Hustler.foot":
		if e.complexity.Hustler.Foot == nil {
			break
		}

		return e.complexity.Hustler.Foot(childComplexity), true

	case "Hustler.hair":
		if e.complexity.Hustler.Hair == nil {
			break
		}

		return e.complexity.Hustler.Hair(childComplexity), true

	case "Hustler.hand":
		if e.complexity.Hustler.Hand == nil {
			break
		}

		return e.complexity.Hustler.Hand(childComplexity), true

	case "Hustler.id":
		if e.complexity.Hustler.ID == nil {
			break
		}

		return e.complexity.Hustler.ID(childComplexity), true

	case "Hustler.index":
		if e.complexity.Hustler.Index == nil {
			break
		}

		return e.complexity.Hustler.Index(childComplexity), true

	case "Hustler.name":
		if e.complexity.Hustler.Name == nil {
			break
		}

		return e.complexity.Hustler.Name(childComplexity), true

	case "Hustler.neck":
		if e.complexity.Hustler.Neck == nil {
			break
		}

		return e.complexity.Hustler.Neck(childComplexity), true

	case "Hustler.order":
		if e.complexity.Hustler.Order == nil {
			break
		}

		return e.complexity.Hustler.Order(childComplexity), true

	case "Hustler.ring":
		if e.complexity.Hustler.Ring == nil {
			break
		}

		return e.complexity.Hustler.Ring(childComplexity), true

	case "Hustler.sex":
		if e.complexity.Hustler.Sex == nil {
			break
		}

		return e.complexity.Hustler.Sex(childComplexity), true

	case "Hustler.svg":
		if e.complexity.Hustler.Svg == nil {
			break
		}

		return e.complexity.Hustler.Svg(childComplexity), true

	case "Hustler.title":
		if e.complexity.Hustler.Title == nil {
			break
		}

		return e.complexity.Hustler.Title(childComplexity), true

	case "Hustler.type":
		if e.complexity.Hustler.Type == nil {
			break
		}

		return e.complexity.Hustler.Type(childComplexity), true

	case "Hustler.vehicle":
		if e.complexity.Hustler.Vehicle == nil {
			break
		}

		return e.complexity.Hustler.Vehicle(childComplexity), true

	case "Hustler.viewbox":
		if e.complexity.Hustler.Viewbox == nil {
			break
		}

		return e.complexity.Hustler.Viewbox(childComplexity), true

	case "Hustler.waist":
		if e.complexity.Hustler.Waist == nil {
			break
		}

		return e.complexity.Hustler.Waist(childComplexity), true

	case "Hustler.wallet":
		if e.complexity.Hustler.Wallet == nil {
			break
		}

		return e.complexity.Hustler.Wallet(childComplexity), true

	case "Hustler.weapon":
		if e.complexity.Hustler.Weapon == nil {
			break
		}

		return e.complexity.Hustler.Weapon(childComplexity), true

	case "HustlerConnection.edges":
		if e.complexity.HustlerConnection.Edges == nil {
			break
		}

		return e.complexity.HustlerConnection.Edges(childComplexity), true

	case "HustlerConnection.pageInfo":
		if e.complexity.HustlerConnection.PageInfo == nil {
			break
		}

		return e.complexity.HustlerConnection.PageInfo(childComplexity), true

	case "HustlerConnection.totalCount":
		if e.complexity.HustlerConnection.TotalCount == nil {
			break
		}

		return e.complexity.HustlerConnection.TotalCount(childComplexity), true

	case "HustlerEdge.cursor":
		if e.complexity.HustlerEdge.Cursor == nil {
			break
		}

		return e.complexity.HustlerEdge.Cursor(childComplexity), true

	case "HustlerEdge.node":
		if e.complexity.HustlerEdge.Node == nil {
			break
		}

		return e.complexity.HustlerEdge.Node(childComplexity), true

	case "Item.augmented":
		if e.complexity.Item.Augmented == nil {
			break
		}

		return e.complexity.Item.Augmented(childComplexity), true

	case "Item.base":
		if e.complexity.Item.Base == nil {
			break
		}

		return e.complexity.Item.Base(childComplexity), true

	case "Item.bestAskPriceEth":
		if e.complexity.Item.BestAskPriceEth == nil {
			break
		}

		return e.complexity.Item.BestAskPriceEth(childComplexity), true

	case "Item.count":
		if e.complexity.Item.Count == nil {
			break
		}

		return e.complexity.Item.Count(childComplexity), true

	case "Item.derivative":
		if e.complexity.Item.Derivative == nil {
			break
		}

		return e.complexity.Item.Derivative(childComplexity), true

	case "Item.dopes":
		if e.complexity.Item.Dopes == nil {
			break
		}

		return e.complexity.Item.Dopes(childComplexity), true

	case "Item.fullname":
		if e.complexity.Item.Fullname == nil {
			break
		}

		return e.complexity.Item.Fullname(childComplexity), true

	case "Item.greatness":
		if e.complexity.Item.Greatness == nil {
			break
		}

		return e.complexity.Item.Greatness(childComplexity), true

	case "Item.hustlerAccessories":
		if e.complexity.Item.HustlerAccessories == nil {
			break
		}

		return e.complexity.Item.HustlerAccessories(childComplexity), true

	case "Item.hustlerClothes":
		if e.complexity.Item.HustlerClothes == nil {
			break
		}

		return e.complexity.Item.HustlerClothes(childComplexity), true

	case "Item.hustlerDrugs":
		if e.complexity.Item.HustlerDrugs == nil {
			break
		}

		return e.complexity.Item.HustlerDrugs(childComplexity), true

	case "Item.hustlerFeet":
		if e.complexity.Item.HustlerFeet == nil {
			break
		}

		return e.complexity.Item.HustlerFeet(childComplexity), true

	case "Item.hustlerHands":
		if e.complexity.Item.HustlerHands == nil {
			break
		}

		return e.complexity.Item.HustlerHands(childComplexity), true

	case "Item.hustlerNecks":
		if e.complexity.Item.HustlerNecks == nil {
			break
		}

		return e.complexity.Item.HustlerNecks(childComplexity), true

	case "Item.hustlerRings":
		if e.complexity.Item.HustlerRings == nil {
			break
		}

		return e.complexity.Item.HustlerRings(childComplexity), true

	case "Item.hustlerVehicles":
		if e.complexity.Item.HustlerVehicles == nil {
			break
		}

		return e.complexity.Item.HustlerVehicles(childComplexity), true

	case "Item.hustlerWaists":
		if e.complexity.Item.HustlerWaists == nil {
			break
		}

		return e.complexity.Item.HustlerWaists(childComplexity), true

	case "Item.hustlerWeapons":
		if e.complexity.Item.HustlerWeapons == nil {
			break
		}

		return e.complexity.Item.HustlerWeapons(childComplexity), true

	case "Item.id":
		if e.complexity.Item.ID == nil {
			break
		}

		return e.complexity.Item.ID(childComplexity), true

	case "Item.index":
		if e.complexity.Item.Index == nil {
			break
		}

		return e.complexity.Item.Index(childComplexity), true

	case "Item.name":
		if e.complexity.Item.Name == nil {
			break
		}

		return e.complexity.Item.Name(childComplexity), true

	case "Item.namePrefix":
		if e.complexity.Item.NamePrefix == nil {
			break
		}

		return e.complexity.Item.NamePrefix(childComplexity), true

	case "Item.nameSuffix":
		if e.complexity.Item.NameSuffix == nil {
			break
		}

		return e.complexity.Item.NameSuffix(childComplexity), true

	case "Item.rles":
		if e.complexity.Item.Rles == nil {
			break
		}

		return e.complexity.Item.Rles(childComplexity), true

	case "Item.sprite":
		if e.complexity.Item.Sprite == nil {
			break
		}

		return e.complexity.Item.Sprite(childComplexity), true

	case "Item.suffix":
		if e.complexity.Item.Suffix == nil {
			break
		}

		return e.complexity.Item.Suffix(childComplexity), true

	case "Item.svg":
		if e.complexity.Item.Svg == nil {
			break
		}

		return e.complexity.Item.Svg(childComplexity), true

	case "Item.tier":
		if e.complexity.Item.Tier == nil {
			break
		}

		return e.complexity.Item.Tier(childComplexity), true

	case "Item.type":
		if e.complexity.Item.Type == nil {
			break
		}

		return e.complexity.Item.Type(childComplexity), true

	case "Item.wallets":
		if e.complexity.Item.Wallets == nil {
			break
		}

		return e.complexity.Item.Wallets(childComplexity), true

	case "ItemConnection.edges":
		if e.complexity.ItemConnection.Edges == nil {
			break
		}

		return e.complexity.ItemConnection.Edges(childComplexity), true

	case "ItemConnection.pageInfo":
		if e.complexity.ItemConnection.PageInfo == nil {
			break
		}

		return e.complexity.ItemConnection.PageInfo(childComplexity), true

	case "ItemConnection.totalCount":
		if e.complexity.ItemConnection.TotalCount == nil {
			break
		}

		return e.complexity.ItemConnection.TotalCount(childComplexity), true

	case "ItemEdge.cursor":
		if e.complexity.ItemEdge.Cursor == nil {
			break
		}

		return e.complexity.ItemEdge.Cursor(childComplexity), true

	case "ItemEdge.node":
		if e.complexity.ItemEdge.Node == nil {
			break
		}

		return e.complexity.ItemEdge.Node(childComplexity), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Position.currentMap":
		if e.complexity.Position.CurrentMap == nil {
			break
		}

		return e.complexity.Position.CurrentMap(childComplexity), true

	case "Position.x":
		if e.complexity.Position.X == nil {
			break
		}

		return e.complexity.Position.X(childComplexity), true

	case "Position.y":
		if e.complexity.Position.Y == nil {
			break
		}

		return e.complexity.Position.Y(childComplexity), true

	case "Query.bodyParts":
		if e.complexity.Query.BodyParts == nil {
			break
		}

		args, err := ec.field_Query_bodyParts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BodyParts(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*ent.BodyPartWhereInput)), true

	case "Query.dopes":
		if e.complexity.Query.Dopes == nil {
			break
		}

		args, err := ec.field_Query_dopes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Dopes(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.DopeOrder), args["where"].(*ent.DopeWhereInput)), true

	case "Query.hustlers":
		if e.complexity.Query.Hustlers == nil {
			break
		}

		args, err := ec.field_Query_hustlers_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hustlers(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.HustlerOrder), args["where"].(*ent.HustlerWhereInput)), true

	case "Query.items":
		if e.complexity.Query.Items == nil {
			break
		}

		args, err := ec.field_Query_items_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Items(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.ItemOrder), args["where"].(*ent.ItemWhereInput)), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Query.search":
		if e.complexity.Query.Search == nil {
			break
		}

		args, err := ec.field_Query_search_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Search(childComplexity, args["query"].(string), args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.SearchOrder), args["where"].(*ent.SearchWhereInput)), true

	case "Query.walletItems":
		if e.complexity.Query.WalletItems == nil {
			break
		}

		args, err := ec.field_Query_walletItems_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.WalletItems(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["where"].(*ent.WalletItemsWhereInput)), true

	case "Query.wallets":
		if e.complexity.Query.Wallets == nil {
			break
		}

		args, err := ec.field_Query_wallets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Wallets(childComplexity, args["after"].(*entgql.Cursor[string]), args["first"].(*int), args["before"].(*entgql.Cursor[string]), args["last"].(*int), args["orderBy"].(*ent.WalletOrder), args["where"].(*ent.WalletWhereInput)), true

	case "RLEs.female":
		if e.complexity.RLEs.Female == nil {
			break
		}

		return e.complexity.RLEs.Female(childComplexity), true

	case "RLEs.male":
		if e.complexity.RLEs.Male == nil {
			break
		}

		return e.complexity.RLEs.Male(childComplexity), true

	case "Search.banned":
		if e.complexity.Search.Banned == nil {
			break
		}

		return e.complexity.Search.Banned(childComplexity), true

	case "Search.claimed":
		if e.complexity.Search.Claimed == nil {
			break
		}

		return e.complexity.Search.Claimed(childComplexity), true

	case "Search.dope":
		if e.complexity.Search.Dope == nil {
			break
		}

		return e.complexity.Search.Dope(childComplexity), true

	case "Search.greatness":
		if e.complexity.Search.Greatness == nil {
			break
		}

		return e.complexity.Search.Greatness(childComplexity), true

	case "Search.hustler":
		if e.complexity.Search.Hustler == nil {
			break
		}

		return e.complexity.Search.Hustler(childComplexity), true

	case "Search.id":
		if e.complexity.Search.ID == nil {
			break
		}

		return e.complexity.Search.ID(childComplexity), true

	case "Search.item":
		if e.complexity.Search.Item == nil {
			break
		}

		return e.complexity.Search.Item(childComplexity), true

	case "Search.opened":
		if e.complexity.Search.Opened == nil {
			break
		}

		return e.complexity.Search.Opened(childComplexity), true

	case "Search.salePrice":
		if e.complexity.Search.SalePrice == nil {
			break
		}

		return e.complexity.Search.SalePrice(childComplexity), true

	case "Search.type":
		if e.complexity.Search.Type == nil {
			break
		}

		return e.complexity.Search.Type(childComplexity), true

	case "SearchConnection.edges":
		if e.complexity.SearchConnection.Edges == nil {
			break
		}

		return e.complexity.SearchConnection.Edges(childComplexity), true

	case "SearchConnection.pageInfo":
		if e.complexity.SearchConnection.PageInfo == nil {
			break
		}

		return e.complexity.SearchConnection.PageInfo(childComplexity), true

	case "SearchConnection.totalCount":
		if e.complexity.SearchConnection.TotalCount == nil {
			break
		}

		return e.complexity.SearchConnection.TotalCount(childComplexity), true

	case "SearchEdge.cursor":
		if e.complexity.SearchEdge.Cursor == nil {
			break
		}

		return e.complexity.SearchEdge.Cursor(childComplexity), true

	case "SearchEdge.node":
		if e.complexity.SearchEdge.Node == nil {
			break
		}

		return e.complexity.SearchEdge.Node(childComplexity), true

	case "Sprites.Female":
		if e.complexity.Sprites.Female == nil {
			break
		}

		return e.complexity.Sprites.Female(childComplexity), true

	case "Sprites.Male":
		if e.complexity.Sprites.Male == nil {
			break
		}

		return e.complexity.Sprites.Male(childComplexity), true

	case "SyncState.blockTime":
		if e.complexity.SyncState.BlockTime == nil {
			break
		}

		return e.complexity.SyncState.BlockTime(childComplexity), true

	case "SyncState.contractName":
		if e.complexity.SyncState.ContractName == nil {
			break
		}

		return e.complexity.SyncState.ContractName(childComplexity), true

	case "SyncState.id":
		if e.complexity.SyncState.ID == nil {
			break
		}

		return e.complexity.SyncState.ID(childComplexity), true

	case "SyncState.lastSyncedAt":
		if e.complexity.SyncState.LastSyncedAt == nil {
			break
		}

		return e.complexity.SyncState.LastSyncedAt(childComplexity), true

	case "SyncState.startBlock":
		if e.complexity.SyncState.StartBlock == nil {
			break
		}

		return e.complexity.SyncState.StartBlock(childComplexity), true

	case "Wallet.createdAt":
		if e.complexity.Wallet.CreatedAt == nil {
			break
		}

		return e.complexity.Wallet.CreatedAt(childComplexity), true

	case "Wallet.dopes":
		if e.complexity.Wallet.Dopes == nil {
			break
		}

		return e.complexity.Wallet.Dopes(childComplexity), true

	case "Wallet.hustlers":
		if e.complexity.Wallet.Hustlers == nil {
			break
		}

		return e.complexity.Wallet.Hustlers(childComplexity), true

	case "Wallet.id":
		if e.complexity.Wallet.ID == nil {
			break
		}

		return e.complexity.Wallet.ID(childComplexity), true

	case "Wallet.items":
		if e.complexity.Wallet.Items == nil {
			break
		}

		return e.complexity.Wallet.Items(childComplexity), true

	case "Wallet.lastSetPaperBalanceAt":
		if e.complexity.Wallet.LastSetPaperBalanceAt == nil {
			break
		}

		return e.complexity.Wallet.LastSetPaperBalanceAt(childComplexity), true

	case "Wallet.paper":
		if e.complexity.Wallet.Paper == nil {
			break
		}

		return e.complexity.Wallet.Paper(childComplexity), true

	case "WalletConnection.edges":
		if e.complexity.WalletConnection.Edges == nil {
			break
		}

		return e.complexity.WalletConnection.Edges(childComplexity), true

	case "WalletConnection.pageInfo":
		if e.complexity.WalletConnection.PageInfo == nil {
			break
		}

		return e.complexity.WalletConnection.PageInfo(childComplexity), true

	case "WalletConnection.totalCount":
		if e.complexity.WalletConnection.TotalCount == nil {
			break
		}

		return e.complexity.WalletConnection.TotalCount(childComplexity), true

	case "WalletEdge.cursor":
		if e.complexity.WalletEdge.Cursor == nil {
			break
		}

		return e.complexity.WalletEdge.Cursor(childComplexity), true

	case "WalletEdge.node":
		if e.complexity.WalletEdge.Node == nil {
			break
		}

		return e.complexity.WalletEdge.Node(childComplexity), true

	case "WalletItems.balance":
		if e.complexity.WalletItems.Balance == nil {
			break
		}

		return e.complexity.WalletItems.Balance(childComplexity), true

	case "WalletItems.id":
		if e.complexity.WalletItems.ID == nil {
			break
		}

		return e.complexity.WalletItems.ID(childComplexity), true

	case "WalletItems.item":
		if e.complexity.WalletItems.Item == nil {
			break
		}

		return e.complexity.WalletItems.Item(childComplexity), true

	case "WalletItems.wallet":
		if e.complexity.WalletItems.Wallet == nil {
			break
		}

		return e.complexity.WalletItems.Wallet(childComplexity), true

	case "WalletItemsConnection.edges":
		if e.complexity.WalletItemsConnection.Edges == nil {
			break
		}

		return e.complexity.WalletItemsConnection.Edges(childComplexity), true

	case "WalletItemsConnection.pageInfo":
		if e.complexity.WalletItemsConnection.PageInfo == nil {
			break
		}

		return e.complexity.WalletItemsConnection.PageInfo(childComplexity), true

	case "WalletItemsConnection.totalCount":
		if e.complexity.WalletItemsConnection.TotalCount == nil {
			break
		}

		return e.complexity.WalletItemsConnection.TotalCount(childComplexity), true

	case "WalletItemsEdge.cursor":
		if e.complexity.WalletItemsEdge.Cursor == nil {
			break
		}

		return e.complexity.WalletItemsEdge.Cursor(childComplexity), true

	case "WalletItemsEdge.node":
		if e.complexity.WalletItemsEdge.Node == nil {
			break
		}

		return e.complexity.WalletItemsEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBodyPartWhereInput,
		ec.unmarshalInputDopeOrder,
		ec.unmarshalInputDopeWhereInput,
		ec.unmarshalInputEventWhereInput,
		ec.unmarshalInputGameHustlerItemWhereInput,
		ec.unmarshalInputGameHustlerOrder,
		ec.unmarshalInputGameHustlerQuestWhereInput,
		ec.unmarshalInputGameHustlerRelationWhereInput,
		ec.unmarshalInputGameHustlerWhereInput,
		ec.unmarshalInputHustlerOrder,
		ec.unmarshalInputHustlerWhereInput,
		ec.unmarshalInputItemOrder,
		ec.unmarshalInputItemWhereInput,
		ec.unmarshalInputSearchOrder,
		ec.unmarshalInputSearchWhereInput,
		ec.unmarshalInputSyncStateWhereInput,
		ec.unmarshalInputWalletItemsWhereInput,
		ec.unmarshalInputWalletOrder,
		ec.unmarshalInputWalletWhereInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema.graphql", Input: `# This file defines supplementary types that are not autogenerated by ent.

# scalar Type
scalar Sex
# scalar Tier

type Hash {
  value: String!
}

"Timestamp is a RFC3339 string."
scalar Timestamp
"Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal."
scalar Bytes32
"Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal."
scalar Address
"""
Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.
An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.
"""
scalar Bytes
"BigInt is a large integer represented as a string."
scalar BigInt
"Long is a 64 bit unsigned integer."
scalar Long

type Sprites {
  Female: String
  Male: String
}

type RLEs {
  female: String!
  male: String!
}

union SearchResult = Dope | Item | Hustler

# For the MMO

type Position {
  currentMap: String!
  x: Float!
  y: Float!
}

# type GameHustlerQuest implements Node {
#   quest: String!
#   completed: Boolean!
# }

# type GameHustlerItem implements Node {
#   item: String!
#   count: Int!
# }

# type GameHustlerRelation implements Node {

#   citizen: String!
#   conversation: Int!
#   text: Int!
# }

# type GameHustler implements Node {
#   id: ID!
#   hustler: Hustler!
#   lastPosition: Position!
#   relations: [GameHustlerCitizen!]!
#   inventory: [GameHustlerItem!]!
#   quests: [GameHustlerQuest!]!
# }

# All other model resolvers and gql are autogenerated by ent,
# using annotations on the schema. See the last block of
# code on each one in the internal/ent/schema folder.
# This is a custom resolver for Search because I wasn't
# sure how to annotate that we need to receive the "query"
# argument as a string.
#
# When running go generate ./... in the root of the project,
# the entc code generator will generate a blank Search
# resolver. We can then add our own custom resolver there.
extend type Query {
  search(
    query: String!
    after: Cursor
    first: Int
    before: Cursor
    last: Int
    orderBy: SearchOrder
    where: SearchWhereInput
  ): SearchConnection!
}

extend type Item {
  fullname: String!
}
`, BuiltIn: false},
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!]) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
type BodyPart implements Node {
  id: ID!
  type: BodyPartBodyPartType!
  sex: BodyPartBodyPartSex!
  rle: String!
  sprite: String
  hustlerBodies: [Hustler!]
  hustlerHairs: [Hustler!]
  hustlerBeards: [Hustler!]
}
"""
BodyPartBodyPartSex is enum for the field sex
"""
enum BodyPartBodyPartSex @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart.Sex") {
  MALE
  FEMALE
}
"""
BodyPartBodyPartType is enum for the field type
"""
enum BodyPartBodyPartType @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart.Type") {
  BODY
  HAIR
  BEARD
}
"""
A connection to a list of items.
"""
type BodyPartConnection {
  """
  A list of edges.
  """
  edges: [BodyPartEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type BodyPartEdge {
  """
  The item at the end of the edge.
  """
  node: BodyPart
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
BodyPartWhereInput is used for filtering BodyPart objects.
Input was generated by ent.
"""
input BodyPartWhereInput {
  not: BodyPartWhereInput
  and: [BodyPartWhereInput!]
  or: [BodyPartWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  type field predicates
  """
  type: BodyPartBodyPartType
  typeNEQ: BodyPartBodyPartType
  typeIn: [BodyPartBodyPartType!]
  typeNotIn: [BodyPartBodyPartType!]
  """
  sex field predicates
  """
  sex: BodyPartBodyPartSex
  sexNEQ: BodyPartBodyPartSex
  sexIn: [BodyPartBodyPartSex!]
  sexNotIn: [BodyPartBodyPartSex!]
  """
  rle field predicates
  """
  rle: String
  rleNEQ: String
  rleIn: [String!]
  rleNotIn: [String!]
  rleGT: String
  rleGTE: String
  rleLT: String
  rleLTE: String
  rleContains: String
  rleHasPrefix: String
  rleHasSuffix: String
  rleEqualFold: String
  rleContainsFold: String
  """
  sprite field predicates
  """
  sprite: String
  spriteNEQ: String
  spriteIn: [String!]
  spriteNotIn: [String!]
  spriteGT: String
  spriteGTE: String
  spriteLT: String
  spriteLTE: String
  spriteContains: String
  spriteHasPrefix: String
  spriteHasSuffix: String
  spriteIsNil: Boolean
  spriteNotNil: Boolean
  spriteEqualFold: String
  spriteContainsFold: String
  """
  hustler_bodies edge predicates
  """
  hasHustlerBodies: Boolean
  hasHustlerBodiesWith: [HustlerWhereInput!]
  """
  hustler_hairs edge predicates
  """
  hasHustlerHairs: Boolean
  hasHustlerHairsWith: [HustlerWhereInput!]
  """
  hustler_beards edge predicates
  """
  hasHustlerBeards: Boolean
  hasHustlerBeardsWith: [HustlerWhereInput!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Dope implements Node {
  id: ID!
  claimed: Boolean!
  lastCheckedPaperClaim: Time
  opened: Boolean!
  lastCheckedGearClaim: Time
  score: Int
  rank: Int
  order: Int!
  bestAskPriceEth: Float
  wallet: Wallet
  items: [Item!]
  index: Search
}
"""
A connection to a list of items.
"""
type DopeConnection {
  """
  A list of edges.
  """
  edges: [DopeEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type DopeEdge {
  """
  The item at the end of the edge.
  """
  node: Dope
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Dope connections
"""
input DopeOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Dopes.
  """
  field: DopeOrderField!
}
"""
Properties by which Dope connections can be ordered.
"""
enum DopeOrderField {
  RANK
  ID
  BEST_ASK_PRICE
}
"""
DopeWhereInput is used for filtering Dope objects.
Input was generated by ent.
"""
input DopeWhereInput {
  not: DopeWhereInput
  and: [DopeWhereInput!]
  or: [DopeWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  claimed field predicates
  """
  claimed: Boolean
  claimedNEQ: Boolean
  """
  last_checked_paper_claim field predicates
  """
  lastCheckedPaperClaim: Time
  lastCheckedPaperClaimNEQ: Time
  lastCheckedPaperClaimIn: [Time!]
  lastCheckedPaperClaimNotIn: [Time!]
  lastCheckedPaperClaimGT: Time
  lastCheckedPaperClaimGTE: Time
  lastCheckedPaperClaimLT: Time
  lastCheckedPaperClaimLTE: Time
  lastCheckedPaperClaimIsNil: Boolean
  lastCheckedPaperClaimNotNil: Boolean
  """
  opened field predicates
  """
  opened: Boolean
  openedNEQ: Boolean
  """
  last_checked_gear_claim field predicates
  """
  lastCheckedGearClaim: Time
  lastCheckedGearClaimNEQ: Time
  lastCheckedGearClaimIn: [Time!]
  lastCheckedGearClaimNotIn: [Time!]
  lastCheckedGearClaimGT: Time
  lastCheckedGearClaimGTE: Time
  lastCheckedGearClaimLT: Time
  lastCheckedGearClaimLTE: Time
  lastCheckedGearClaimIsNil: Boolean
  lastCheckedGearClaimNotNil: Boolean
  """
  score field predicates
  """
  score: Int
  scoreNEQ: Int
  scoreIn: [Int!]
  scoreNotIn: [Int!]
  scoreGT: Int
  scoreGTE: Int
  scoreLT: Int
  scoreLTE: Int
  scoreIsNil: Boolean
  scoreNotNil: Boolean
  """
  rank field predicates
  """
  rank: Int
  rankNEQ: Int
  rankIn: [Int!]
  rankNotIn: [Int!]
  rankGT: Int
  rankGTE: Int
  rankLT: Int
  rankLTE: Int
  rankIsNil: Boolean
  rankNotNil: Boolean
  """
  order field predicates
  """
  order: Int
  orderNEQ: Int
  orderIn: [Int!]
  orderNotIn: [Int!]
  orderGT: Int
  orderGTE: Int
  orderLT: Int
  orderLTE: Int
  """
  best_ask_price_eth field predicates
  """
  bestAskPriceEth: Float
  bestAskPriceEthNEQ: Float
  bestAskPriceEthIn: [Float!]
  bestAskPriceEthNotIn: [Float!]
  bestAskPriceEthGT: Float
  bestAskPriceEthGTE: Float
  bestAskPriceEthLT: Float
  bestAskPriceEthLTE: Float
  bestAskPriceEthIsNil: Boolean
  bestAskPriceEthNotNil: Boolean
  """
  wallet edge predicates
  """
  hasWallet: Boolean
  hasWalletWith: [WalletWhereInput!]
  """
  items edge predicates
  """
  hasItems: Boolean
  hasItemsWith: [ItemWhereInput!]
  """
  index edge predicates
  """
  hasIndex: Boolean
  hasIndexWith: [SearchWhereInput!]
}
type Event implements Node {
  id: ID!
  address: Address!
  index: Long!
  hash: Hash!
  createdAt: Time!
  updatedAt: Time!
}
"""
EventWhereInput is used for filtering Event objects.
Input was generated by ent.
"""
input EventWhereInput {
  not: EventWhereInput
  and: [EventWhereInput!]
  or: [EventWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  index field predicates
  """
  index: Long
  indexNEQ: Long
  indexIn: [Long!]
  indexNotIn: [Long!]
  indexGT: Long
  indexGTE: Long
  indexLT: Long
  indexLTE: Long
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  updated_at field predicates
  """
  updatedAt: Time
  updatedAtNEQ: Time
  updatedAtIn: [Time!]
  updatedAtNotIn: [Time!]
  updatedAtGT: Time
  updatedAtGTE: Time
  updatedAtLT: Time
  updatedAtLTE: Time
}
type GameHustler implements Node {
  id: ID!
  lastPosition: Position!
  createdAt: Time!
  relations: [GameHustlerRelation!]
  items: [GameHustlerItem!]
  quests: [GameHustlerQuest!]
}
type GameHustlerItem implements Node {
  id: ID!
  item: String!
  hustler: GameHustler
}
"""
GameHustlerItemWhereInput is used for filtering GameHustlerItem objects.
Input was generated by ent.
"""
input GameHustlerItemWhereInput {
  not: GameHustlerItemWhereInput
  and: [GameHustlerItemWhereInput!]
  or: [GameHustlerItemWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  item field predicates
  """
  item: String
  itemNEQ: String
  itemIn: [String!]
  itemNotIn: [String!]
  itemGT: String
  itemGTE: String
  itemLT: String
  itemLTE: String
  itemContains: String
  itemHasPrefix: String
  itemHasSuffix: String
  itemEqualFold: String
  itemContainsFold: String
  """
  hustler edge predicates
  """
  hasHustler: Boolean
  hasHustlerWith: [GameHustlerWhereInput!]
}
"""
Ordering options for GameHustler connections
"""
input GameHustlerOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order GameHustlers.
  """
  field: GameHustlerOrderField!
}
"""
Properties by which GameHustler connections can be ordered.
"""
enum GameHustlerOrderField {
  CREATED_AT
}
type GameHustlerQuest implements Node {
  id: ID!
  quest: String!
  completed: Boolean!
  hustler: GameHustler
}
"""
GameHustlerQuestWhereInput is used for filtering GameHustlerQuest objects.
Input was generated by ent.
"""
input GameHustlerQuestWhereInput {
  not: GameHustlerQuestWhereInput
  and: [GameHustlerQuestWhereInput!]
  or: [GameHustlerQuestWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  quest field predicates
  """
  quest: String
  questNEQ: String
  questIn: [String!]
  questNotIn: [String!]
  questGT: String
  questGTE: String
  questLT: String
  questLTE: String
  questContains: String
  questHasPrefix: String
  questHasSuffix: String
  questEqualFold: String
  questContainsFold: String
  """
  completed field predicates
  """
  completed: Boolean
  completedNEQ: Boolean
  """
  hustler edge predicates
  """
  hasHustler: Boolean
  hasHustlerWith: [GameHustlerWhereInput!]
}
type GameHustlerRelation implements Node {
  id: ID!
  citizen: String!
  conversation: String!
  text: Int!
  hustler: GameHustler
}
"""
GameHustlerRelationWhereInput is used for filtering GameHustlerRelation objects.
Input was generated by ent.
"""
input GameHustlerRelationWhereInput {
  not: GameHustlerRelationWhereInput
  and: [GameHustlerRelationWhereInput!]
  or: [GameHustlerRelationWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  citizen field predicates
  """
  citizen: String
  citizenNEQ: String
  citizenIn: [String!]
  citizenNotIn: [String!]
  citizenGT: String
  citizenGTE: String
  citizenLT: String
  citizenLTE: String
  citizenContains: String
  citizenHasPrefix: String
  citizenHasSuffix: String
  citizenEqualFold: String
  citizenContainsFold: String
  """
  conversation field predicates
  """
  conversation: String
  conversationNEQ: String
  conversationIn: [String!]
  conversationNotIn: [String!]
  conversationGT: String
  conversationGTE: String
  conversationLT: String
  conversationLTE: String
  conversationContains: String
  conversationHasPrefix: String
  conversationHasSuffix: String
  conversationEqualFold: String
  conversationContainsFold: String
  """
  text field predicates
  """
  text: Int
  textNEQ: Int
  textIn: [Int!]
  textNotIn: [Int!]
  textGT: Int
  textGTE: Int
  textLT: Int
  textLTE: Int
  """
  hustler edge predicates
  """
  hasHustler: Boolean
  hasHustlerWith: [GameHustlerWhereInput!]
}
"""
GameHustlerWhereInput is used for filtering GameHustler objects.
Input was generated by ent.
"""
input GameHustlerWhereInput {
  not: GameHustlerWhereInput
  and: [GameHustlerWhereInput!]
  or: [GameHustlerWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  relations edge predicates
  """
  hasRelations: Boolean
  hasRelationsWith: [GameHustlerRelationWhereInput!]
  """
  items edge predicates
  """
  hasItems: Boolean
  hasItemsWith: [GameHustlerItemWhereInput!]
  """
  quests edge predicates
  """
  hasQuests: Boolean
  hasQuestsWith: [GameHustlerQuestWhereInput!]
}
type Hustler implements Node {
  id: ID!
  type: HustlerHustlerType!
  name: String
  title: String
  color: String
  background: String
  age: Long!
  sex: HustlerHustlerSex!
  viewbox: [Int!]!
  order: [Int!]!
  svg: String
  createdAt: Time!
  bestAskPriceEth: Float
  wallet: Wallet
  weapon: Item
  clothes: Item
  vehicle: Item
  waist: Item
  foot: Item
  hand: Item
  drug: Item
  neck: Item
  ring: Item
  accessory: Item
  body: BodyPart
  hair: BodyPart
  beard: BodyPart
  index: Search
}
"""
A connection to a list of items.
"""
type HustlerConnection {
  """
  A list of edges.
  """
  edges: [HustlerEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type HustlerEdge {
  """
  The item at the end of the edge.
  """
  node: Hustler
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
HustlerHustlerSex is enum for the field sex
"""
enum HustlerHustlerSex @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler.Sex") {
  MALE
  FEMALE
}
"""
HustlerHustlerType is enum for the field type
"""
enum HustlerHustlerType @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler.Type") {
  ORIGINAL_GANGSTA
  REGULAR
}
"""
Ordering options for Hustler connections
"""
input HustlerOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Hustlers.
  """
  field: HustlerOrderField!
}
"""
Properties by which Hustler connections can be ordered.
"""
enum HustlerOrderField {
  CREATED_AT
  BEST_ASK_PRICE
}
"""
HustlerWhereInput is used for filtering Hustler objects.
Input was generated by ent.
"""
input HustlerWhereInput {
  not: HustlerWhereInput
  and: [HustlerWhereInput!]
  or: [HustlerWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  type field predicates
  """
  type: HustlerHustlerType
  typeNEQ: HustlerHustlerType
  typeIn: [HustlerHustlerType!]
  typeNotIn: [HustlerHustlerType!]
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameIsNil: Boolean
  nameNotNil: Boolean
  nameEqualFold: String
  nameContainsFold: String
  """
  title field predicates
  """
  title: String
  titleNEQ: String
  titleIn: [String!]
  titleNotIn: [String!]
  titleGT: String
  titleGTE: String
  titleLT: String
  titleLTE: String
  titleContains: String
  titleHasPrefix: String
  titleHasSuffix: String
  titleIsNil: Boolean
  titleNotNil: Boolean
  titleEqualFold: String
  titleContainsFold: String
  """
  color field predicates
  """
  color: String
  colorNEQ: String
  colorIn: [String!]
  colorNotIn: [String!]
  colorGT: String
  colorGTE: String
  colorLT: String
  colorLTE: String
  colorContains: String
  colorHasPrefix: String
  colorHasSuffix: String
  colorIsNil: Boolean
  colorNotNil: Boolean
  colorEqualFold: String
  colorContainsFold: String
  """
  background field predicates
  """
  background: String
  backgroundNEQ: String
  backgroundIn: [String!]
  backgroundNotIn: [String!]
  backgroundGT: String
  backgroundGTE: String
  backgroundLT: String
  backgroundLTE: String
  backgroundContains: String
  backgroundHasPrefix: String
  backgroundHasSuffix: String
  backgroundIsNil: Boolean
  backgroundNotNil: Boolean
  backgroundEqualFold: String
  backgroundContainsFold: String
  """
  age field predicates
  """
  age: Long
  ageNEQ: Long
  ageIn: [Long!]
  ageNotIn: [Long!]
  ageGT: Long
  ageGTE: Long
  ageLT: Long
  ageLTE: Long
  """
  sex field predicates
  """
  sex: HustlerHustlerSex
  sexNEQ: HustlerHustlerSex
  sexIn: [HustlerHustlerSex!]
  sexNotIn: [HustlerHustlerSex!]
  """
  svg field predicates
  """
  svg: String
  svgNEQ: String
  svgIn: [String!]
  svgNotIn: [String!]
  svgGT: String
  svgGTE: String
  svgLT: String
  svgLTE: String
  svgContains: String
  svgHasPrefix: String
  svgHasSuffix: String
  svgIsNil: Boolean
  svgNotNil: Boolean
  svgEqualFold: String
  svgContainsFold: String
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  best_ask_price_eth field predicates
  """
  bestAskPriceEth: Float
  bestAskPriceEthNEQ: Float
  bestAskPriceEthIn: [Float!]
  bestAskPriceEthNotIn: [Float!]
  bestAskPriceEthGT: Float
  bestAskPriceEthGTE: Float
  bestAskPriceEthLT: Float
  bestAskPriceEthLTE: Float
  bestAskPriceEthIsNil: Boolean
  bestAskPriceEthNotNil: Boolean
  """
  wallet edge predicates
  """
  hasWallet: Boolean
  hasWalletWith: [WalletWhereInput!]
  """
  weapon edge predicates
  """
  hasWeapon: Boolean
  hasWeaponWith: [ItemWhereInput!]
  """
  clothes edge predicates
  """
  hasClothes: Boolean
  hasClothesWith: [ItemWhereInput!]
  """
  vehicle edge predicates
  """
  hasVehicle: Boolean
  hasVehicleWith: [ItemWhereInput!]
  """
  waist edge predicates
  """
  hasWaist: Boolean
  hasWaistWith: [ItemWhereInput!]
  """
  foot edge predicates
  """
  hasFoot: Boolean
  hasFootWith: [ItemWhereInput!]
  """
  hand edge predicates
  """
  hasHand: Boolean
  hasHandWith: [ItemWhereInput!]
  """
  drug edge predicates
  """
  hasDrug: Boolean
  hasDrugWith: [ItemWhereInput!]
  """
  neck edge predicates
  """
  hasNeck: Boolean
  hasNeckWith: [ItemWhereInput!]
  """
  ring edge predicates
  """
  hasRing: Boolean
  hasRingWith: [ItemWhereInput!]
  """
  accessory edge predicates
  """
  hasAccessory: Boolean
  hasAccessoryWith: [ItemWhereInput!]
  """
  body edge predicates
  """
  hasBody: Boolean
  hasBodyWith: [BodyPartWhereInput!]
  """
  hair edge predicates
  """
  hasHair: Boolean
  hasHairWith: [BodyPartWhereInput!]
  """
  beard edge predicates
  """
  hasBeard: Boolean
  hasBeardWith: [BodyPartWhereInput!]
  """
  index edge predicates
  """
  hasIndex: Boolean
  hasIndexWith: [SearchWhereInput!]
}
type Item implements Node {
  id: ID!
  type: ItemItemType!
  namePrefix: String
  nameSuffix: String
  name: String!
  suffix: String
  augmented: Boolean
  count: Int
  tier: ItemItemTier
  greatness: Int
  rles: RLEs
  svg: String
  sprite: Sprites
  bestAskPriceEth: Float
  wallets: [WalletItems!]
  dopes: [Dope!]
  hustlerWeapons: [Hustler!]
  hustlerClothes: [Hustler!]
  hustlerVehicles: [Hustler!]
  hustlerWaists: [Hustler!]
  hustlerFeet: [Hustler!]
  hustlerHands: [Hustler!]
  hustlerDrugs: [Hustler!]
  hustlerNecks: [Hustler!]
  hustlerRings: [Hustler!]
  hustlerAccessories: [Hustler!]
  base: Item
  derivative: [Item!]
  index: Search
}
"""
A connection to a list of items.
"""
type ItemConnection {
  """
  A list of edges.
  """
  edges: [ItemEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type ItemEdge {
  """
  The item at the end of the edge.
  """
  node: Item
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
ItemItemTier is enum for the field tier
"""
enum ItemItemTier @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/item.Tier") {
  COMMON
  RARE
  CUSTOM
  BLACK_MARKET
}
"""
ItemItemType is enum for the field type
"""
enum ItemItemType @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/item.Type") {
  WEAPON
  CLOTHES
  VEHICLE
  WAIST
  FOOT
  HAND
  DRUGS
  NECK
  RING
  ACCESSORY
}
"""
Ordering options for Item connections
"""
input ItemOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Items.
  """
  field: ItemOrderField!
}
"""
Properties by which Item connections can be ordered.
"""
enum ItemOrderField {
  GREATNESS
  BEST_ASK_PRICE
}
"""
ItemWhereInput is used for filtering Item objects.
Input was generated by ent.
"""
input ItemWhereInput {
  not: ItemWhereInput
  and: [ItemWhereInput!]
  or: [ItemWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  type field predicates
  """
  type: ItemItemType
  typeNEQ: ItemItemType
  typeIn: [ItemItemType!]
  typeNotIn: [ItemItemType!]
  """
  name_prefix field predicates
  """
  namePrefix: String
  namePrefixNEQ: String
  namePrefixIn: [String!]
  namePrefixNotIn: [String!]
  namePrefixGT: String
  namePrefixGTE: String
  namePrefixLT: String
  namePrefixLTE: String
  namePrefixContains: String
  namePrefixHasPrefix: String
  namePrefixHasSuffix: String
  namePrefixIsNil: Boolean
  namePrefixNotNil: Boolean
  namePrefixEqualFold: String
  namePrefixContainsFold: String
  """
  name_suffix field predicates
  """
  nameSuffix: String
  nameSuffixNEQ: String
  nameSuffixIn: [String!]
  nameSuffixNotIn: [String!]
  nameSuffixGT: String
  nameSuffixGTE: String
  nameSuffixLT: String
  nameSuffixLTE: String
  nameSuffixContains: String
  nameSuffixHasPrefix: String
  nameSuffixHasSuffix: String
  nameSuffixIsNil: Boolean
  nameSuffixNotNil: Boolean
  nameSuffixEqualFold: String
  nameSuffixContainsFold: String
  """
  name field predicates
  """
  name: String
  nameNEQ: String
  nameIn: [String!]
  nameNotIn: [String!]
  nameGT: String
  nameGTE: String
  nameLT: String
  nameLTE: String
  nameContains: String
  nameHasPrefix: String
  nameHasSuffix: String
  nameEqualFold: String
  nameContainsFold: String
  """
  suffix field predicates
  """
  suffix: String
  suffixNEQ: String
  suffixIn: [String!]
  suffixNotIn: [String!]
  suffixGT: String
  suffixGTE: String
  suffixLT: String
  suffixLTE: String
  suffixContains: String
  suffixHasPrefix: String
  suffixHasSuffix: String
  suffixIsNil: Boolean
  suffixNotNil: Boolean
  suffixEqualFold: String
  suffixContainsFold: String
  """
  augmented field predicates
  """
  augmented: Boolean
  augmentedNEQ: Boolean
  augmentedIsNil: Boolean
  augmentedNotNil: Boolean
  """
  count field predicates
  """
  count: Int
  countNEQ: Int
  countIn: [Int!]
  countNotIn: [Int!]
  countGT: Int
  countGTE: Int
  countLT: Int
  countLTE: Int
  countIsNil: Boolean
  countNotNil: Boolean
  """
  tier field predicates
  """
  tier: ItemItemTier
  tierNEQ: ItemItemTier
  tierIn: [ItemItemTier!]
  tierNotIn: [ItemItemTier!]
  tierIsNil: Boolean
  tierNotNil: Boolean
  """
  greatness field predicates
  """
  greatness: Int
  greatnessNEQ: Int
  greatnessIn: [Int!]
  greatnessNotIn: [Int!]
  greatnessGT: Int
  greatnessGTE: Int
  greatnessLT: Int
  greatnessLTE: Int
  greatnessIsNil: Boolean
  greatnessNotNil: Boolean
  """
  svg field predicates
  """
  svg: String
  svgNEQ: String
  svgIn: [String!]
  svgNotIn: [String!]
  svgGT: String
  svgGTE: String
  svgLT: String
  svgLTE: String
  svgContains: String
  svgHasPrefix: String
  svgHasSuffix: String
  svgIsNil: Boolean
  svgNotNil: Boolean
  svgEqualFold: String
  svgContainsFold: String
  """
  best_ask_price_eth field predicates
  """
  bestAskPriceEth: Float
  bestAskPriceEthNEQ: Float
  bestAskPriceEthIn: [Float!]
  bestAskPriceEthNotIn: [Float!]
  bestAskPriceEthGT: Float
  bestAskPriceEthGTE: Float
  bestAskPriceEthLT: Float
  bestAskPriceEthLTE: Float
  bestAskPriceEthIsNil: Boolean
  bestAskPriceEthNotNil: Boolean
  """
  wallets edge predicates
  """
  hasWallets: Boolean
  hasWalletsWith: [WalletItemsWhereInput!]
  """
  dopes edge predicates
  """
  hasDopes: Boolean
  hasDopesWith: [DopeWhereInput!]
  """
  hustler_weapons edge predicates
  """
  hasHustlerWeapons: Boolean
  hasHustlerWeaponsWith: [HustlerWhereInput!]
  """
  hustler_clothes edge predicates
  """
  hasHustlerClothes: Boolean
  hasHustlerClothesWith: [HustlerWhereInput!]
  """
  hustler_vehicles edge predicates
  """
  hasHustlerVehicles: Boolean
  hasHustlerVehiclesWith: [HustlerWhereInput!]
  """
  hustler_waists edge predicates
  """
  hasHustlerWaists: Boolean
  hasHustlerWaistsWith: [HustlerWhereInput!]
  """
  hustler_feet edge predicates
  """
  hasHustlerFeet: Boolean
  hasHustlerFeetWith: [HustlerWhereInput!]
  """
  hustler_hands edge predicates
  """
  hasHustlerHands: Boolean
  hasHustlerHandsWith: [HustlerWhereInput!]
  """
  hustler_drugs edge predicates
  """
  hasHustlerDrugs: Boolean
  hasHustlerDrugsWith: [HustlerWhereInput!]
  """
  hustler_necks edge predicates
  """
  hasHustlerNecks: Boolean
  hasHustlerNecksWith: [HustlerWhereInput!]
  """
  hustler_rings edge predicates
  """
  hasHustlerRings: Boolean
  hasHustlerRingsWith: [HustlerWhereInput!]
  """
  hustler_accessories edge predicates
  """
  hasHustlerAccessories: Boolean
  hasHustlerAccessoriesWith: [HustlerWhereInput!]
  """
  base edge predicates
  """
  hasBase: Boolean
  hasBaseWith: [ItemWhereInput!]
  """
  derivative edge predicates
  """
  hasDerivative: Boolean
  hasDerivativeWith: [ItemWhereInput!]
  """
  index edge predicates
  """
  hasIndex: Boolean
  hasIndexWith: [SearchWhereInput!]
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  bodyParts(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for BodyParts returned from the connection.
    """
    where: BodyPartWhereInput
  ): BodyPartConnection!
  dopes(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Dopes returned from the connection.
    """
    orderBy: DopeOrder

    """
    Filtering options for Dopes returned from the connection.
    """
    where: DopeWhereInput
  ): DopeConnection!
  hustlers(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Hustlers returned from the connection.
    """
    orderBy: HustlerOrder

    """
    Filtering options for Hustlers returned from the connection.
    """
    where: HustlerWhereInput
  ): HustlerConnection!
  items(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Items returned from the connection.
    """
    orderBy: ItemOrder

    """
    Filtering options for Items returned from the connection.
    """
    where: ItemWhereInput
  ): ItemConnection!
  wallets(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Ordering options for Wallets returned from the connection.
    """
    orderBy: WalletOrder

    """
    Filtering options for Wallets returned from the connection.
    """
    where: WalletWhereInput
  ): WalletConnection!
  walletItems(
    """
    Returns the elements in the list that come after the specified cursor.
    """
    after: Cursor

    """
    Returns the first _n_ elements from the list.
    """
    first: Int

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: Cursor

    """
    Returns the last _n_ elements from the list.
    """
    last: Int

    """
    Filtering options for WalletItemsSlice returned from the connection.
    """
    where: WalletItemsWhereInput
  ): WalletItemsConnection!
}
type Search implements Node {
  id: ID!
  type: SearchSearchType!
  greatness: Int
  claimed: Boolean!
  opened: Boolean!
  banned: Boolean!
  salePrice: Float
  dope: Dope
  item: Item
  hustler: Hustler
}
"""
A connection to a list of items.
"""
type SearchConnection {
  """
  A list of edges.
  """
  edges: [SearchEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type SearchEdge {
  """
  The item at the end of the edge.
  """
  node: Search
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
Ordering options for Search connections
"""
input SearchOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Searches.
  """
  field: SearchOrderField!
}
"""
Properties by which Search connections can be ordered.
"""
enum SearchOrderField {
  GREATNESS
  SALE_PRICE
}
"""
SearchSearchType is enum for the field type
"""
enum SearchSearchType @goModel(model: "github.com/dopedao/dope-monorepo/packages/api/internal/ent/search.Type") {
  DOPE
  ITEM
  HUSTLER
}
"""
SearchWhereInput is used for filtering Search objects.
Input was generated by ent.
"""
input SearchWhereInput {
  not: SearchWhereInput
  and: [SearchWhereInput!]
  or: [SearchWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  type field predicates
  """
  type: SearchSearchType
  typeNEQ: SearchSearchType
  typeIn: [SearchSearchType!]
  typeNotIn: [SearchSearchType!]
  """
  greatness field predicates
  """
  greatness: Int
  greatnessNEQ: Int
  greatnessIn: [Int!]
  greatnessNotIn: [Int!]
  greatnessGT: Int
  greatnessGTE: Int
  greatnessLT: Int
  greatnessLTE: Int
  greatnessIsNil: Boolean
  greatnessNotNil: Boolean
  """
  claimed field predicates
  """
  claimed: Boolean
  claimedNEQ: Boolean
  """
  opened field predicates
  """
  opened: Boolean
  openedNEQ: Boolean
  """
  banned field predicates
  """
  banned: Boolean
  bannedNEQ: Boolean
  """
  sale_price field predicates
  """
  salePrice: Float
  salePriceNEQ: Float
  salePriceIn: [Float!]
  salePriceNotIn: [Float!]
  salePriceGT: Float
  salePriceGTE: Float
  salePriceLT: Float
  salePriceLTE: Float
  salePriceIsNil: Boolean
  salePriceNotNil: Boolean
  """
  dope edge predicates
  """
  hasDope: Boolean
  hasDopeWith: [DopeWhereInput!]
  """
  item edge predicates
  """
  hasItem: Boolean
  hasItemWith: [ItemWhereInput!]
  """
  hustler edge predicates
  """
  hasHustler: Boolean
  hasHustlerWith: [HustlerWhereInput!]
}
type SyncState implements Node {
  id: ID!
  contractName: String
  startBlock: Long!
  blockTime: Time
  lastSyncedAt: Time
}
"""
SyncStateWhereInput is used for filtering SyncState objects.
Input was generated by ent.
"""
input SyncStateWhereInput {
  not: SyncStateWhereInput
  and: [SyncStateWhereInput!]
  or: [SyncStateWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  contract_name field predicates
  """
  contractName: String
  contractNameNEQ: String
  contractNameIn: [String!]
  contractNameNotIn: [String!]
  contractNameGT: String
  contractNameGTE: String
  contractNameLT: String
  contractNameLTE: String
  contractNameContains: String
  contractNameHasPrefix: String
  contractNameHasSuffix: String
  contractNameIsNil: Boolean
  contractNameNotNil: Boolean
  contractNameEqualFold: String
  contractNameContainsFold: String
  """
  start_block field predicates
  """
  startBlock: Long
  startBlockNEQ: Long
  startBlockIn: [Long!]
  startBlockNotIn: [Long!]
  startBlockGT: Long
  startBlockGTE: Long
  startBlockLT: Long
  startBlockLTE: Long
  """
  block_time field predicates
  """
  blockTime: Time
  blockTimeNEQ: Time
  blockTimeIn: [Time!]
  blockTimeNotIn: [Time!]
  blockTimeGT: Time
  blockTimeGTE: Time
  blockTimeLT: Time
  blockTimeLTE: Time
  blockTimeIsNil: Boolean
  blockTimeNotNil: Boolean
  """
  last_synced_at field predicates
  """
  lastSyncedAt: Time
  lastSyncedAtNEQ: Time
  lastSyncedAtIn: [Time!]
  lastSyncedAtNotIn: [Time!]
  lastSyncedAtGT: Time
  lastSyncedAtGTE: Time
  lastSyncedAtLT: Time
  lastSyncedAtLTE: Time
  lastSyncedAtIsNil: Boolean
  lastSyncedAtNotNil: Boolean
}
"""
The builtin Time type
"""
scalar Time
type Wallet implements Node {
  id: ID!
  paper: BigInt!
  lastSetPaperBalanceAt: Time
  createdAt: Time!
  dopes: [Dope!]
  items: [WalletItems!]
  hustlers: [Hustler!]
}
"""
A connection to a list of items.
"""
type WalletConnection {
  """
  A list of edges.
  """
  edges: [WalletEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type WalletEdge {
  """
  The item at the end of the edge.
  """
  node: Wallet
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
type WalletItems implements Node {
  id: ID!
  balance: BigInt!
  wallet: Wallet
  item: Item
}
"""
A connection to a list of items.
"""
type WalletItemsConnection {
  """
  A list of edges.
  """
  edges: [WalletItemsEdge]
  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!
  """
  Identifies the total count of items in the connection.
  """
  totalCount: Int!
}
"""
An edge in a connection.
"""
type WalletItemsEdge {
  """
  The item at the end of the edge.
  """
  node: WalletItems
  """
  A cursor for use in pagination.
  """
  cursor: Cursor!
}
"""
WalletItemsWhereInput is used for filtering WalletItems objects.
Input was generated by ent.
"""
input WalletItemsWhereInput {
  not: WalletItemsWhereInput
  and: [WalletItemsWhereInput!]
  or: [WalletItemsWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  balance field predicates
  """
  balance: BigInt
  balanceNEQ: BigInt
  balanceIn: [BigInt!]
  balanceNotIn: [BigInt!]
  balanceGT: BigInt
  balanceGTE: BigInt
  balanceLT: BigInt
  balanceLTE: BigInt
  """
  wallet edge predicates
  """
  hasWallet: Boolean
  hasWalletWith: [WalletWhereInput!]
  """
  item edge predicates
  """
  hasItem: Boolean
  hasItemWith: [ItemWhereInput!]
}
"""
Ordering options for Wallet connections
"""
input WalletOrder {
  """
  The ordering direction.
  """
  direction: OrderDirection! = ASC
  """
  The field by which to order Wallets.
  """
  field: WalletOrderField!
}
"""
Properties by which Wallet connections can be ordered.
"""
enum WalletOrderField {
  CREATED_AT
}
"""
WalletWhereInput is used for filtering Wallet objects.
Input was generated by ent.
"""
input WalletWhereInput {
  not: WalletWhereInput
  and: [WalletWhereInput!]
  or: [WalletWhereInput!]
  """
  id field predicates
  """
  id: ID
  idNEQ: ID
  idIn: [ID!]
  idNotIn: [ID!]
  idGT: ID
  idGTE: ID
  idLT: ID
  idLTE: ID
  idEqualFold: ID
  idContainsFold: ID
  """
  paper field predicates
  """
  paper: BigInt
  paperNEQ: BigInt
  paperIn: [BigInt!]
  paperNotIn: [BigInt!]
  paperGT: BigInt
  paperGTE: BigInt
  paperLT: BigInt
  paperLTE: BigInt
  """
  last_set_paper_balance_at field predicates
  """
  lastSetPaperBalanceAt: Time
  lastSetPaperBalanceAtNEQ: Time
  lastSetPaperBalanceAtIn: [Time!]
  lastSetPaperBalanceAtNotIn: [Time!]
  lastSetPaperBalanceAtGT: Time
  lastSetPaperBalanceAtGTE: Time
  lastSetPaperBalanceAtLT: Time
  lastSetPaperBalanceAtLTE: Time
  lastSetPaperBalanceAtIsNil: Boolean
  lastSetPaperBalanceAtNotNil: Boolean
  """
  created_at field predicates
  """
  createdAt: Time
  createdAtNEQ: Time
  createdAtIn: [Time!]
  createdAtNotIn: [Time!]
  createdAtGT: Time
  createdAtGTE: Time
  createdAtLT: Time
  createdAtLTE: Time
  """
  dopes edge predicates
  """
  hasDopes: Boolean
  hasDopesWith: [DopeWhereInput!]
  """
  items edge predicates
  """
  hasItems: Boolean
  hasItemsWith: [WalletItemsWhereInput!]
  """
  hustlers edge predicates
  """
  hasHustlers: Boolean
  hasHustlersWith: [HustlerWhereInput!]
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
