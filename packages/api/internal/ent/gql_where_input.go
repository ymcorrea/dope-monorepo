// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/event"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustleritem"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustlerquest"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustlerrelation"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/predicate"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/schema"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/search"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/walletitems"
)

// BodyPartWhereInput represents a where input for filtering BodyPart queries.
type BodyPartWhereInput struct {
	Predicates []predicate.BodyPart  `json:"-"`
	Not        *BodyPartWhereInput   `json:"not,omitempty"`
	Or         []*BodyPartWhereInput `json:"or,omitempty"`
	And        []*BodyPartWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "type" field predicates.
	Type      *bodypart.Type  `json:"type,omitempty"`
	TypeNEQ   *bodypart.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []bodypart.Type `json:"typeIn,omitempty"`
	TypeNotIn []bodypart.Type `json:"typeNotIn,omitempty"`

	// "sex" field predicates.
	Sex      *bodypart.Sex  `json:"sex,omitempty"`
	SexNEQ   *bodypart.Sex  `json:"sexNEQ,omitempty"`
	SexIn    []bodypart.Sex `json:"sexIn,omitempty"`
	SexNotIn []bodypart.Sex `json:"sexNotIn,omitempty"`

	// "rle" field predicates.
	Rle             *string  `json:"rle,omitempty"`
	RleNEQ          *string  `json:"rleNEQ,omitempty"`
	RleIn           []string `json:"rleIn,omitempty"`
	RleNotIn        []string `json:"rleNotIn,omitempty"`
	RleGT           *string  `json:"rleGT,omitempty"`
	RleGTE          *string  `json:"rleGTE,omitempty"`
	RleLT           *string  `json:"rleLT,omitempty"`
	RleLTE          *string  `json:"rleLTE,omitempty"`
	RleContains     *string  `json:"rleContains,omitempty"`
	RleHasPrefix    *string  `json:"rleHasPrefix,omitempty"`
	RleHasSuffix    *string  `json:"rleHasSuffix,omitempty"`
	RleEqualFold    *string  `json:"rleEqualFold,omitempty"`
	RleContainsFold *string  `json:"rleContainsFold,omitempty"`

	// "sprite" field predicates.
	Sprite             *string  `json:"sprite,omitempty"`
	SpriteNEQ          *string  `json:"spriteNEQ,omitempty"`
	SpriteIn           []string `json:"spriteIn,omitempty"`
	SpriteNotIn        []string `json:"spriteNotIn,omitempty"`
	SpriteGT           *string  `json:"spriteGT,omitempty"`
	SpriteGTE          *string  `json:"spriteGTE,omitempty"`
	SpriteLT           *string  `json:"spriteLT,omitempty"`
	SpriteLTE          *string  `json:"spriteLTE,omitempty"`
	SpriteContains     *string  `json:"spriteContains,omitempty"`
	SpriteHasPrefix    *string  `json:"spriteHasPrefix,omitempty"`
	SpriteHasSuffix    *string  `json:"spriteHasSuffix,omitempty"`
	SpriteIsNil        bool     `json:"spriteIsNil,omitempty"`
	SpriteNotNil       bool     `json:"spriteNotNil,omitempty"`
	SpriteEqualFold    *string  `json:"spriteEqualFold,omitempty"`
	SpriteContainsFold *string  `json:"spriteContainsFold,omitempty"`

	// "hustler_bodies" edge predicates.
	HasHustlerBodies     *bool                `json:"hasHustlerBodies,omitempty"`
	HasHustlerBodiesWith []*HustlerWhereInput `json:"hasHustlerBodiesWith,omitempty"`

	// "hustler_hairs" edge predicates.
	HasHustlerHairs     *bool                `json:"hasHustlerHairs,omitempty"`
	HasHustlerHairsWith []*HustlerWhereInput `json:"hasHustlerHairsWith,omitempty"`

	// "hustler_beards" edge predicates.
	HasHustlerBeards     *bool                `json:"hasHustlerBeards,omitempty"`
	HasHustlerBeardsWith []*HustlerWhereInput `json:"hasHustlerBeardsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BodyPartWhereInput) AddPredicates(predicates ...predicate.BodyPart) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BodyPartWhereInput filter on the BodyPartQuery builder.
func (i *BodyPartWhereInput) Filter(q *BodyPartQuery) (*BodyPartQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBodyPartWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBodyPartWhereInput is returned in case the BodyPartWhereInput is empty.
var ErrEmptyBodyPartWhereInput = errors.New("ent: empty predicate BodyPartWhereInput")

// P returns a predicate for filtering bodyparts.
// An error is returned if the input is empty or invalid.
func (i *BodyPartWhereInput) P() (predicate.BodyPart, error) {
	var predicates []predicate.BodyPart
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, bodypart.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BodyPart, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, bodypart.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BodyPart, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, bodypart.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, bodypart.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, bodypart.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, bodypart.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, bodypart.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, bodypart.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, bodypart.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, bodypart.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, bodypart.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, bodypart.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, bodypart.IDContainsFold(*i.IDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, bodypart.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, bodypart.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, bodypart.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, bodypart.TypeNotIn(i.TypeNotIn...))
	}
	if i.Sex != nil {
		predicates = append(predicates, bodypart.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, bodypart.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, bodypart.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, bodypart.SexNotIn(i.SexNotIn...))
	}
	if i.Rle != nil {
		predicates = append(predicates, bodypart.RleEQ(*i.Rle))
	}
	if i.RleNEQ != nil {
		predicates = append(predicates, bodypart.RleNEQ(*i.RleNEQ))
	}
	if len(i.RleIn) > 0 {
		predicates = append(predicates, bodypart.RleIn(i.RleIn...))
	}
	if len(i.RleNotIn) > 0 {
		predicates = append(predicates, bodypart.RleNotIn(i.RleNotIn...))
	}
	if i.RleGT != nil {
		predicates = append(predicates, bodypart.RleGT(*i.RleGT))
	}
	if i.RleGTE != nil {
		predicates = append(predicates, bodypart.RleGTE(*i.RleGTE))
	}
	if i.RleLT != nil {
		predicates = append(predicates, bodypart.RleLT(*i.RleLT))
	}
	if i.RleLTE != nil {
		predicates = append(predicates, bodypart.RleLTE(*i.RleLTE))
	}
	if i.RleContains != nil {
		predicates = append(predicates, bodypart.RleContains(*i.RleContains))
	}
	if i.RleHasPrefix != nil {
		predicates = append(predicates, bodypart.RleHasPrefix(*i.RleHasPrefix))
	}
	if i.RleHasSuffix != nil {
		predicates = append(predicates, bodypart.RleHasSuffix(*i.RleHasSuffix))
	}
	if i.RleEqualFold != nil {
		predicates = append(predicates, bodypart.RleEqualFold(*i.RleEqualFold))
	}
	if i.RleContainsFold != nil {
		predicates = append(predicates, bodypart.RleContainsFold(*i.RleContainsFold))
	}
	if i.Sprite != nil {
		predicates = append(predicates, bodypart.SpriteEQ(*i.Sprite))
	}
	if i.SpriteNEQ != nil {
		predicates = append(predicates, bodypart.SpriteNEQ(*i.SpriteNEQ))
	}
	if len(i.SpriteIn) > 0 {
		predicates = append(predicates, bodypart.SpriteIn(i.SpriteIn...))
	}
	if len(i.SpriteNotIn) > 0 {
		predicates = append(predicates, bodypart.SpriteNotIn(i.SpriteNotIn...))
	}
	if i.SpriteGT != nil {
		predicates = append(predicates, bodypart.SpriteGT(*i.SpriteGT))
	}
	if i.SpriteGTE != nil {
		predicates = append(predicates, bodypart.SpriteGTE(*i.SpriteGTE))
	}
	if i.SpriteLT != nil {
		predicates = append(predicates, bodypart.SpriteLT(*i.SpriteLT))
	}
	if i.SpriteLTE != nil {
		predicates = append(predicates, bodypart.SpriteLTE(*i.SpriteLTE))
	}
	if i.SpriteContains != nil {
		predicates = append(predicates, bodypart.SpriteContains(*i.SpriteContains))
	}
	if i.SpriteHasPrefix != nil {
		predicates = append(predicates, bodypart.SpriteHasPrefix(*i.SpriteHasPrefix))
	}
	if i.SpriteHasSuffix != nil {
		predicates = append(predicates, bodypart.SpriteHasSuffix(*i.SpriteHasSuffix))
	}
	if i.SpriteIsNil {
		predicates = append(predicates, bodypart.SpriteIsNil())
	}
	if i.SpriteNotNil {
		predicates = append(predicates, bodypart.SpriteNotNil())
	}
	if i.SpriteEqualFold != nil {
		predicates = append(predicates, bodypart.SpriteEqualFold(*i.SpriteEqualFold))
	}
	if i.SpriteContainsFold != nil {
		predicates = append(predicates, bodypart.SpriteContainsFold(*i.SpriteContainsFold))
	}

	if i.HasHustlerBodies != nil {
		p := bodypart.HasHustlerBodies()
		if !*i.HasHustlerBodies {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerBodiesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerBodiesWith))
		for _, w := range i.HasHustlerBodiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerBodiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerBodiesWith(with...))
	}
	if i.HasHustlerHairs != nil {
		p := bodypart.HasHustlerHairs()
		if !*i.HasHustlerHairs {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerHairsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerHairsWith))
		for _, w := range i.HasHustlerHairsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerHairsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerHairsWith(with...))
	}
	if i.HasHustlerBeards != nil {
		p := bodypart.HasHustlerBeards()
		if !*i.HasHustlerBeards {
			p = bodypart.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerBeardsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerBeardsWith))
		for _, w := range i.HasHustlerBeardsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerBeardsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, bodypart.HasHustlerBeardsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBodyPartWhereInput
	case 1:
		return predicates[0], nil
	default:
		return bodypart.And(predicates...), nil
	}
}

// DopeWhereInput represents a where input for filtering Dope queries.
type DopeWhereInput struct {
	Predicates []predicate.Dope  `json:"-"`
	Not        *DopeWhereInput   `json:"not,omitempty"`
	Or         []*DopeWhereInput `json:"or,omitempty"`
	And        []*DopeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "claimed" field predicates.
	Claimed    *bool `json:"claimed,omitempty"`
	ClaimedNEQ *bool `json:"claimedNEQ,omitempty"`

	// "last_checked_paper_claim" field predicates.
	LastCheckedPaperClaim       *time.Time  `json:"lastCheckedPaperClaim,omitempty"`
	LastCheckedPaperClaimNEQ    *time.Time  `json:"lastCheckedPaperClaimNEQ,omitempty"`
	LastCheckedPaperClaimIn     []time.Time `json:"lastCheckedPaperClaimIn,omitempty"`
	LastCheckedPaperClaimNotIn  []time.Time `json:"lastCheckedPaperClaimNotIn,omitempty"`
	LastCheckedPaperClaimGT     *time.Time  `json:"lastCheckedPaperClaimGT,omitempty"`
	LastCheckedPaperClaimGTE    *time.Time  `json:"lastCheckedPaperClaimGTE,omitempty"`
	LastCheckedPaperClaimLT     *time.Time  `json:"lastCheckedPaperClaimLT,omitempty"`
	LastCheckedPaperClaimLTE    *time.Time  `json:"lastCheckedPaperClaimLTE,omitempty"`
	LastCheckedPaperClaimIsNil  bool        `json:"lastCheckedPaperClaimIsNil,omitempty"`
	LastCheckedPaperClaimNotNil bool        `json:"lastCheckedPaperClaimNotNil,omitempty"`

	// "opened" field predicates.
	Opened    *bool `json:"opened,omitempty"`
	OpenedNEQ *bool `json:"openedNEQ,omitempty"`

	// "last_checked_gear_claim" field predicates.
	LastCheckedGearClaim       *time.Time  `json:"lastCheckedGearClaim,omitempty"`
	LastCheckedGearClaimNEQ    *time.Time  `json:"lastCheckedGearClaimNEQ,omitempty"`
	LastCheckedGearClaimIn     []time.Time `json:"lastCheckedGearClaimIn,omitempty"`
	LastCheckedGearClaimNotIn  []time.Time `json:"lastCheckedGearClaimNotIn,omitempty"`
	LastCheckedGearClaimGT     *time.Time  `json:"lastCheckedGearClaimGT,omitempty"`
	LastCheckedGearClaimGTE    *time.Time  `json:"lastCheckedGearClaimGTE,omitempty"`
	LastCheckedGearClaimLT     *time.Time  `json:"lastCheckedGearClaimLT,omitempty"`
	LastCheckedGearClaimLTE    *time.Time  `json:"lastCheckedGearClaimLTE,omitempty"`
	LastCheckedGearClaimIsNil  bool        `json:"lastCheckedGearClaimIsNil,omitempty"`
	LastCheckedGearClaimNotNil bool        `json:"lastCheckedGearClaimNotNil,omitempty"`

	// "score" field predicates.
	Score       *int  `json:"score,omitempty"`
	ScoreNEQ    *int  `json:"scoreNEQ,omitempty"`
	ScoreIn     []int `json:"scoreIn,omitempty"`
	ScoreNotIn  []int `json:"scoreNotIn,omitempty"`
	ScoreGT     *int  `json:"scoreGT,omitempty"`
	ScoreGTE    *int  `json:"scoreGTE,omitempty"`
	ScoreLT     *int  `json:"scoreLT,omitempty"`
	ScoreLTE    *int  `json:"scoreLTE,omitempty"`
	ScoreIsNil  bool  `json:"scoreIsNil,omitempty"`
	ScoreNotNil bool  `json:"scoreNotNil,omitempty"`

	// "rank" field predicates.
	Rank       *int  `json:"rank,omitempty"`
	RankNEQ    *int  `json:"rankNEQ,omitempty"`
	RankIn     []int `json:"rankIn,omitempty"`
	RankNotIn  []int `json:"rankNotIn,omitempty"`
	RankGT     *int  `json:"rankGT,omitempty"`
	RankGTE    *int  `json:"rankGTE,omitempty"`
	RankLT     *int  `json:"rankLT,omitempty"`
	RankLTE    *int  `json:"rankLTE,omitempty"`
	RankIsNil  bool  `json:"rankIsNil,omitempty"`
	RankNotNil bool  `json:"rankNotNil,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "best_ask_price_eth" field predicates.
	BestAskPriceEth       *float64  `json:"bestAskPriceEth,omitempty"`
	BestAskPriceEthNEQ    *float64  `json:"bestAskPriceEthNEQ,omitempty"`
	BestAskPriceEthIn     []float64 `json:"bestAskPriceEthIn,omitempty"`
	BestAskPriceEthNotIn  []float64 `json:"bestAskPriceEthNotIn,omitempty"`
	BestAskPriceEthGT     *float64  `json:"bestAskPriceEthGT,omitempty"`
	BestAskPriceEthGTE    *float64  `json:"bestAskPriceEthGTE,omitempty"`
	BestAskPriceEthLT     *float64  `json:"bestAskPriceEthLT,omitempty"`
	BestAskPriceEthLTE    *float64  `json:"bestAskPriceEthLTE,omitempty"`
	BestAskPriceEthIsNil  bool      `json:"bestAskPriceEthIsNil,omitempty"`
	BestAskPriceEthNotNil bool      `json:"bestAskPriceEthNotNil,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool             `json:"hasItems,omitempty"`
	HasItemsWith []*ItemWhereInput `json:"hasItemsWith,omitempty"`

	// "index" edge predicates.
	HasIndex     *bool               `json:"hasIndex,omitempty"`
	HasIndexWith []*SearchWhereInput `json:"hasIndexWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DopeWhereInput) AddPredicates(predicates ...predicate.Dope) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DopeWhereInput filter on the DopeQuery builder.
func (i *DopeWhereInput) Filter(q *DopeQuery) (*DopeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDopeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDopeWhereInput is returned in case the DopeWhereInput is empty.
var ErrEmptyDopeWhereInput = errors.New("ent: empty predicate DopeWhereInput")

// P returns a predicate for filtering dopes.
// An error is returned if the input is empty or invalid.
func (i *DopeWhereInput) P() (predicate.Dope, error) {
	var predicates []predicate.Dope
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, dope.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Dope, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, dope.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Dope, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, dope.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, dope.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, dope.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, dope.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, dope.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, dope.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, dope.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, dope.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, dope.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, dope.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, dope.IDContainsFold(*i.IDContainsFold))
	}
	if i.Claimed != nil {
		predicates = append(predicates, dope.ClaimedEQ(*i.Claimed))
	}
	if i.ClaimedNEQ != nil {
		predicates = append(predicates, dope.ClaimedNEQ(*i.ClaimedNEQ))
	}
	if i.LastCheckedPaperClaim != nil {
		predicates = append(predicates, dope.LastCheckedPaperClaimEQ(*i.LastCheckedPaperClaim))
	}
	if i.LastCheckedPaperClaimNEQ != nil {
		predicates = append(predicates, dope.LastCheckedPaperClaimNEQ(*i.LastCheckedPaperClaimNEQ))
	}
	if len(i.LastCheckedPaperClaimIn) > 0 {
		predicates = append(predicates, dope.LastCheckedPaperClaimIn(i.LastCheckedPaperClaimIn...))
	}
	if len(i.LastCheckedPaperClaimNotIn) > 0 {
		predicates = append(predicates, dope.LastCheckedPaperClaimNotIn(i.LastCheckedPaperClaimNotIn...))
	}
	if i.LastCheckedPaperClaimGT != nil {
		predicates = append(predicates, dope.LastCheckedPaperClaimGT(*i.LastCheckedPaperClaimGT))
	}
	if i.LastCheckedPaperClaimGTE != nil {
		predicates = append(predicates, dope.LastCheckedPaperClaimGTE(*i.LastCheckedPaperClaimGTE))
	}
	if i.LastCheckedPaperClaimLT != nil {
		predicates = append(predicates, dope.LastCheckedPaperClaimLT(*i.LastCheckedPaperClaimLT))
	}
	if i.LastCheckedPaperClaimLTE != nil {
		predicates = append(predicates, dope.LastCheckedPaperClaimLTE(*i.LastCheckedPaperClaimLTE))
	}
	if i.LastCheckedPaperClaimIsNil {
		predicates = append(predicates, dope.LastCheckedPaperClaimIsNil())
	}
	if i.LastCheckedPaperClaimNotNil {
		predicates = append(predicates, dope.LastCheckedPaperClaimNotNil())
	}
	if i.Opened != nil {
		predicates = append(predicates, dope.OpenedEQ(*i.Opened))
	}
	if i.OpenedNEQ != nil {
		predicates = append(predicates, dope.OpenedNEQ(*i.OpenedNEQ))
	}
	if i.LastCheckedGearClaim != nil {
		predicates = append(predicates, dope.LastCheckedGearClaimEQ(*i.LastCheckedGearClaim))
	}
	if i.LastCheckedGearClaimNEQ != nil {
		predicates = append(predicates, dope.LastCheckedGearClaimNEQ(*i.LastCheckedGearClaimNEQ))
	}
	if len(i.LastCheckedGearClaimIn) > 0 {
		predicates = append(predicates, dope.LastCheckedGearClaimIn(i.LastCheckedGearClaimIn...))
	}
	if len(i.LastCheckedGearClaimNotIn) > 0 {
		predicates = append(predicates, dope.LastCheckedGearClaimNotIn(i.LastCheckedGearClaimNotIn...))
	}
	if i.LastCheckedGearClaimGT != nil {
		predicates = append(predicates, dope.LastCheckedGearClaimGT(*i.LastCheckedGearClaimGT))
	}
	if i.LastCheckedGearClaimGTE != nil {
		predicates = append(predicates, dope.LastCheckedGearClaimGTE(*i.LastCheckedGearClaimGTE))
	}
	if i.LastCheckedGearClaimLT != nil {
		predicates = append(predicates, dope.LastCheckedGearClaimLT(*i.LastCheckedGearClaimLT))
	}
	if i.LastCheckedGearClaimLTE != nil {
		predicates = append(predicates, dope.LastCheckedGearClaimLTE(*i.LastCheckedGearClaimLTE))
	}
	if i.LastCheckedGearClaimIsNil {
		predicates = append(predicates, dope.LastCheckedGearClaimIsNil())
	}
	if i.LastCheckedGearClaimNotNil {
		predicates = append(predicates, dope.LastCheckedGearClaimNotNil())
	}
	if i.Score != nil {
		predicates = append(predicates, dope.ScoreEQ(*i.Score))
	}
	if i.ScoreNEQ != nil {
		predicates = append(predicates, dope.ScoreNEQ(*i.ScoreNEQ))
	}
	if len(i.ScoreIn) > 0 {
		predicates = append(predicates, dope.ScoreIn(i.ScoreIn...))
	}
	if len(i.ScoreNotIn) > 0 {
		predicates = append(predicates, dope.ScoreNotIn(i.ScoreNotIn...))
	}
	if i.ScoreGT != nil {
		predicates = append(predicates, dope.ScoreGT(*i.ScoreGT))
	}
	if i.ScoreGTE != nil {
		predicates = append(predicates, dope.ScoreGTE(*i.ScoreGTE))
	}
	if i.ScoreLT != nil {
		predicates = append(predicates, dope.ScoreLT(*i.ScoreLT))
	}
	if i.ScoreLTE != nil {
		predicates = append(predicates, dope.ScoreLTE(*i.ScoreLTE))
	}
	if i.ScoreIsNil {
		predicates = append(predicates, dope.ScoreIsNil())
	}
	if i.ScoreNotNil {
		predicates = append(predicates, dope.ScoreNotNil())
	}
	if i.Rank != nil {
		predicates = append(predicates, dope.RankEQ(*i.Rank))
	}
	if i.RankNEQ != nil {
		predicates = append(predicates, dope.RankNEQ(*i.RankNEQ))
	}
	if len(i.RankIn) > 0 {
		predicates = append(predicates, dope.RankIn(i.RankIn...))
	}
	if len(i.RankNotIn) > 0 {
		predicates = append(predicates, dope.RankNotIn(i.RankNotIn...))
	}
	if i.RankGT != nil {
		predicates = append(predicates, dope.RankGT(*i.RankGT))
	}
	if i.RankGTE != nil {
		predicates = append(predicates, dope.RankGTE(*i.RankGTE))
	}
	if i.RankLT != nil {
		predicates = append(predicates, dope.RankLT(*i.RankLT))
	}
	if i.RankLTE != nil {
		predicates = append(predicates, dope.RankLTE(*i.RankLTE))
	}
	if i.RankIsNil {
		predicates = append(predicates, dope.RankIsNil())
	}
	if i.RankNotNil {
		predicates = append(predicates, dope.RankNotNil())
	}
	if i.Order != nil {
		predicates = append(predicates, dope.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, dope.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, dope.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, dope.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, dope.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, dope.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, dope.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, dope.OrderLTE(*i.OrderLTE))
	}
	if i.BestAskPriceEth != nil {
		predicates = append(predicates, dope.BestAskPriceEthEQ(*i.BestAskPriceEth))
	}
	if i.BestAskPriceEthNEQ != nil {
		predicates = append(predicates, dope.BestAskPriceEthNEQ(*i.BestAskPriceEthNEQ))
	}
	if len(i.BestAskPriceEthIn) > 0 {
		predicates = append(predicates, dope.BestAskPriceEthIn(i.BestAskPriceEthIn...))
	}
	if len(i.BestAskPriceEthNotIn) > 0 {
		predicates = append(predicates, dope.BestAskPriceEthNotIn(i.BestAskPriceEthNotIn...))
	}
	if i.BestAskPriceEthGT != nil {
		predicates = append(predicates, dope.BestAskPriceEthGT(*i.BestAskPriceEthGT))
	}
	if i.BestAskPriceEthGTE != nil {
		predicates = append(predicates, dope.BestAskPriceEthGTE(*i.BestAskPriceEthGTE))
	}
	if i.BestAskPriceEthLT != nil {
		predicates = append(predicates, dope.BestAskPriceEthLT(*i.BestAskPriceEthLT))
	}
	if i.BestAskPriceEthLTE != nil {
		predicates = append(predicates, dope.BestAskPriceEthLTE(*i.BestAskPriceEthLTE))
	}
	if i.BestAskPriceEthIsNil {
		predicates = append(predicates, dope.BestAskPriceEthIsNil())
	}
	if i.BestAskPriceEthNotNil {
		predicates = append(predicates, dope.BestAskPriceEthNotNil())
	}

	if i.HasWallet != nil {
		p := dope.HasWallet()
		if !*i.HasWallet {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasWalletWith(with...))
	}
	if i.HasItems != nil {
		p := dope.HasItems()
		if !*i.HasItems {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasItemsWith(with...))
	}
	if i.HasIndex != nil {
		p := dope.HasIndex()
		if !*i.HasIndex {
			p = dope.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIndexWith) > 0 {
		with := make([]predicate.Search, 0, len(i.HasIndexWith))
		for _, w := range i.HasIndexWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIndexWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, dope.HasIndexWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDopeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return dope.And(predicates...), nil
	}
}

// EventWhereInput represents a where input for filtering Event queries.
type EventWhereInput struct {
	Predicates []predicate.Event  `json:"-"`
	Not        *EventWhereInput   `json:"not,omitempty"`
	Or         []*EventWhereInput `json:"or,omitempty"`
	And        []*EventWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "index" field predicates.
	Index      *uint64  `json:"index,omitempty"`
	IndexNEQ   *uint64  `json:"indexNEQ,omitempty"`
	IndexIn    []uint64 `json:"indexIn,omitempty"`
	IndexNotIn []uint64 `json:"indexNotIn,omitempty"`
	IndexGT    *uint64  `json:"indexGT,omitempty"`
	IndexGTE   *uint64  `json:"indexGTE,omitempty"`
	IndexLT    *uint64  `json:"indexLT,omitempty"`
	IndexLTE   *uint64  `json:"indexLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EventWhereInput) AddPredicates(predicates ...predicate.Event) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EventWhereInput filter on the EventQuery builder.
func (i *EventWhereInput) Filter(q *EventQuery) (*EventQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEventWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEventWhereInput is returned in case the EventWhereInput is empty.
var ErrEmptyEventWhereInput = errors.New("ent: empty predicate EventWhereInput")

// P returns a predicate for filtering events.
// An error is returned if the input is empty or invalid.
func (i *EventWhereInput) P() (predicate.Event, error) {
	var predicates []predicate.Event
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, event.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Event, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, event.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Event, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, event.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, event.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, event.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, event.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, event.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, event.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, event.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, event.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, event.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, event.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, event.IDContainsFold(*i.IDContainsFold))
	}
	if i.Index != nil {
		predicates = append(predicates, event.IndexEQ(*i.Index))
	}
	if i.IndexNEQ != nil {
		predicates = append(predicates, event.IndexNEQ(*i.IndexNEQ))
	}
	if len(i.IndexIn) > 0 {
		predicates = append(predicates, event.IndexIn(i.IndexIn...))
	}
	if len(i.IndexNotIn) > 0 {
		predicates = append(predicates, event.IndexNotIn(i.IndexNotIn...))
	}
	if i.IndexGT != nil {
		predicates = append(predicates, event.IndexGT(*i.IndexGT))
	}
	if i.IndexGTE != nil {
		predicates = append(predicates, event.IndexGTE(*i.IndexGTE))
	}
	if i.IndexLT != nil {
		predicates = append(predicates, event.IndexLT(*i.IndexLT))
	}
	if i.IndexLTE != nil {
		predicates = append(predicates, event.IndexLTE(*i.IndexLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, event.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, event.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, event.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, event.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, event.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, event.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, event.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, event.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, event.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, event.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, event.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, event.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, event.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, event.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, event.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, event.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEventWhereInput
	case 1:
		return predicates[0], nil
	default:
		return event.And(predicates...), nil
	}
}

// GameHustlerWhereInput represents a where input for filtering GameHustler queries.
type GameHustlerWhereInput struct {
	Predicates []predicate.GameHustler  `json:"-"`
	Not        *GameHustlerWhereInput   `json:"not,omitempty"`
	Or         []*GameHustlerWhereInput `json:"or,omitempty"`
	And        []*GameHustlerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "relations" edge predicates.
	HasRelations     *bool                            `json:"hasRelations,omitempty"`
	HasRelationsWith []*GameHustlerRelationWhereInput `json:"hasRelationsWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                        `json:"hasItems,omitempty"`
	HasItemsWith []*GameHustlerItemWhereInput `json:"hasItemsWith,omitempty"`

	// "quests" edge predicates.
	HasQuests     *bool                         `json:"hasQuests,omitempty"`
	HasQuestsWith []*GameHustlerQuestWhereInput `json:"hasQuestsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameHustlerWhereInput) AddPredicates(predicates ...predicate.GameHustler) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameHustlerWhereInput filter on the GameHustlerQuery builder.
func (i *GameHustlerWhereInput) Filter(q *GameHustlerQuery) (*GameHustlerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameHustlerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameHustlerWhereInput is returned in case the GameHustlerWhereInput is empty.
var ErrEmptyGameHustlerWhereInput = errors.New("ent: empty predicate GameHustlerWhereInput")

// P returns a predicate for filtering gamehustlers.
// An error is returned if the input is empty or invalid.
func (i *GameHustlerWhereInput) P() (predicate.GameHustler, error) {
	var predicates []predicate.GameHustler
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gamehustler.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GameHustler, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gamehustler.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GameHustler, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gamehustler.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gamehustler.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gamehustler.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gamehustler.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gamehustler.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gamehustler.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gamehustler.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gamehustler.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gamehustler.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, gamehustler.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, gamehustler.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, gamehustler.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, gamehustler.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, gamehustler.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, gamehustler.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, gamehustler.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, gamehustler.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, gamehustler.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, gamehustler.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasRelations != nil {
		p := gamehustler.HasRelations()
		if !*i.HasRelations {
			p = gamehustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRelationsWith) > 0 {
		with := make([]predicate.GameHustlerRelation, 0, len(i.HasRelationsWith))
		for _, w := range i.HasRelationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRelationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamehustler.HasRelationsWith(with...))
	}
	if i.HasItems != nil {
		p := gamehustler.HasItems()
		if !*i.HasItems {
			p = gamehustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.GameHustlerItem, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamehustler.HasItemsWith(with...))
	}
	if i.HasQuests != nil {
		p := gamehustler.HasQuests()
		if !*i.HasQuests {
			p = gamehustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasQuestsWith) > 0 {
		with := make([]predicate.GameHustlerQuest, 0, len(i.HasQuestsWith))
		for _, w := range i.HasQuestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasQuestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamehustler.HasQuestsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameHustlerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gamehustler.And(predicates...), nil
	}
}

// GameHustlerItemWhereInput represents a where input for filtering GameHustlerItem queries.
type GameHustlerItemWhereInput struct {
	Predicates []predicate.GameHustlerItem  `json:"-"`
	Not        *GameHustlerItemWhereInput   `json:"not,omitempty"`
	Or         []*GameHustlerItemWhereInput `json:"or,omitempty"`
	And        []*GameHustlerItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "item" field predicates.
	Item             *string  `json:"item,omitempty"`
	ItemNEQ          *string  `json:"itemNEQ,omitempty"`
	ItemIn           []string `json:"itemIn,omitempty"`
	ItemNotIn        []string `json:"itemNotIn,omitempty"`
	ItemGT           *string  `json:"itemGT,omitempty"`
	ItemGTE          *string  `json:"itemGTE,omitempty"`
	ItemLT           *string  `json:"itemLT,omitempty"`
	ItemLTE          *string  `json:"itemLTE,omitempty"`
	ItemContains     *string  `json:"itemContains,omitempty"`
	ItemHasPrefix    *string  `json:"itemHasPrefix,omitempty"`
	ItemHasSuffix    *string  `json:"itemHasSuffix,omitempty"`
	ItemEqualFold    *string  `json:"itemEqualFold,omitempty"`
	ItemContainsFold *string  `json:"itemContainsFold,omitempty"`

	// "hustler" edge predicates.
	HasHustler     *bool                    `json:"hasHustler,omitempty"`
	HasHustlerWith []*GameHustlerWhereInput `json:"hasHustlerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameHustlerItemWhereInput) AddPredicates(predicates ...predicate.GameHustlerItem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameHustlerItemWhereInput filter on the GameHustlerItemQuery builder.
func (i *GameHustlerItemWhereInput) Filter(q *GameHustlerItemQuery) (*GameHustlerItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameHustlerItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameHustlerItemWhereInput is returned in case the GameHustlerItemWhereInput is empty.
var ErrEmptyGameHustlerItemWhereInput = errors.New("ent: empty predicate GameHustlerItemWhereInput")

// P returns a predicate for filtering gamehustleritems.
// An error is returned if the input is empty or invalid.
func (i *GameHustlerItemWhereInput) P() (predicate.GameHustlerItem, error) {
	var predicates []predicate.GameHustlerItem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gamehustleritem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GameHustlerItem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gamehustleritem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GameHustlerItem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gamehustleritem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gamehustleritem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gamehustleritem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gamehustleritem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gamehustleritem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gamehustleritem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gamehustleritem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gamehustleritem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gamehustleritem.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, gamehustleritem.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, gamehustleritem.IDContainsFold(*i.IDContainsFold))
	}
	if i.Item != nil {
		predicates = append(predicates, gamehustleritem.ItemEQ(*i.Item))
	}
	if i.ItemNEQ != nil {
		predicates = append(predicates, gamehustleritem.ItemNEQ(*i.ItemNEQ))
	}
	if len(i.ItemIn) > 0 {
		predicates = append(predicates, gamehustleritem.ItemIn(i.ItemIn...))
	}
	if len(i.ItemNotIn) > 0 {
		predicates = append(predicates, gamehustleritem.ItemNotIn(i.ItemNotIn...))
	}
	if i.ItemGT != nil {
		predicates = append(predicates, gamehustleritem.ItemGT(*i.ItemGT))
	}
	if i.ItemGTE != nil {
		predicates = append(predicates, gamehustleritem.ItemGTE(*i.ItemGTE))
	}
	if i.ItemLT != nil {
		predicates = append(predicates, gamehustleritem.ItemLT(*i.ItemLT))
	}
	if i.ItemLTE != nil {
		predicates = append(predicates, gamehustleritem.ItemLTE(*i.ItemLTE))
	}
	if i.ItemContains != nil {
		predicates = append(predicates, gamehustleritem.ItemContains(*i.ItemContains))
	}
	if i.ItemHasPrefix != nil {
		predicates = append(predicates, gamehustleritem.ItemHasPrefix(*i.ItemHasPrefix))
	}
	if i.ItemHasSuffix != nil {
		predicates = append(predicates, gamehustleritem.ItemHasSuffix(*i.ItemHasSuffix))
	}
	if i.ItemEqualFold != nil {
		predicates = append(predicates, gamehustleritem.ItemEqualFold(*i.ItemEqualFold))
	}
	if i.ItemContainsFold != nil {
		predicates = append(predicates, gamehustleritem.ItemContainsFold(*i.ItemContainsFold))
	}

	if i.HasHustler != nil {
		p := gamehustleritem.HasHustler()
		if !*i.HasHustler {
			p = gamehustleritem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWith) > 0 {
		with := make([]predicate.GameHustler, 0, len(i.HasHustlerWith))
		for _, w := range i.HasHustlerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamehustleritem.HasHustlerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameHustlerItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gamehustleritem.And(predicates...), nil
	}
}

// GameHustlerQuestWhereInput represents a where input for filtering GameHustlerQuest queries.
type GameHustlerQuestWhereInput struct {
	Predicates []predicate.GameHustlerQuest  `json:"-"`
	Not        *GameHustlerQuestWhereInput   `json:"not,omitempty"`
	Or         []*GameHustlerQuestWhereInput `json:"or,omitempty"`
	And        []*GameHustlerQuestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "quest" field predicates.
	Quest             *string  `json:"quest,omitempty"`
	QuestNEQ          *string  `json:"questNEQ,omitempty"`
	QuestIn           []string `json:"questIn,omitempty"`
	QuestNotIn        []string `json:"questNotIn,omitempty"`
	QuestGT           *string  `json:"questGT,omitempty"`
	QuestGTE          *string  `json:"questGTE,omitempty"`
	QuestLT           *string  `json:"questLT,omitempty"`
	QuestLTE          *string  `json:"questLTE,omitempty"`
	QuestContains     *string  `json:"questContains,omitempty"`
	QuestHasPrefix    *string  `json:"questHasPrefix,omitempty"`
	QuestHasSuffix    *string  `json:"questHasSuffix,omitempty"`
	QuestEqualFold    *string  `json:"questEqualFold,omitempty"`
	QuestContainsFold *string  `json:"questContainsFold,omitempty"`

	// "completed" field predicates.
	Completed    *bool `json:"completed,omitempty"`
	CompletedNEQ *bool `json:"completedNEQ,omitempty"`

	// "hustler" edge predicates.
	HasHustler     *bool                    `json:"hasHustler,omitempty"`
	HasHustlerWith []*GameHustlerWhereInput `json:"hasHustlerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameHustlerQuestWhereInput) AddPredicates(predicates ...predicate.GameHustlerQuest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameHustlerQuestWhereInput filter on the GameHustlerQuestQuery builder.
func (i *GameHustlerQuestWhereInput) Filter(q *GameHustlerQuestQuery) (*GameHustlerQuestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameHustlerQuestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameHustlerQuestWhereInput is returned in case the GameHustlerQuestWhereInput is empty.
var ErrEmptyGameHustlerQuestWhereInput = errors.New("ent: empty predicate GameHustlerQuestWhereInput")

// P returns a predicate for filtering gamehustlerquests.
// An error is returned if the input is empty or invalid.
func (i *GameHustlerQuestWhereInput) P() (predicate.GameHustlerQuest, error) {
	var predicates []predicate.GameHustlerQuest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gamehustlerquest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GameHustlerQuest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gamehustlerquest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GameHustlerQuest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gamehustlerquest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gamehustlerquest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gamehustlerquest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gamehustlerquest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gamehustlerquest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gamehustlerquest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gamehustlerquest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gamehustlerquest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gamehustlerquest.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, gamehustlerquest.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, gamehustlerquest.IDContainsFold(*i.IDContainsFold))
	}
	if i.Quest != nil {
		predicates = append(predicates, gamehustlerquest.QuestEQ(*i.Quest))
	}
	if i.QuestNEQ != nil {
		predicates = append(predicates, gamehustlerquest.QuestNEQ(*i.QuestNEQ))
	}
	if len(i.QuestIn) > 0 {
		predicates = append(predicates, gamehustlerquest.QuestIn(i.QuestIn...))
	}
	if len(i.QuestNotIn) > 0 {
		predicates = append(predicates, gamehustlerquest.QuestNotIn(i.QuestNotIn...))
	}
	if i.QuestGT != nil {
		predicates = append(predicates, gamehustlerquest.QuestGT(*i.QuestGT))
	}
	if i.QuestGTE != nil {
		predicates = append(predicates, gamehustlerquest.QuestGTE(*i.QuestGTE))
	}
	if i.QuestLT != nil {
		predicates = append(predicates, gamehustlerquest.QuestLT(*i.QuestLT))
	}
	if i.QuestLTE != nil {
		predicates = append(predicates, gamehustlerquest.QuestLTE(*i.QuestLTE))
	}
	if i.QuestContains != nil {
		predicates = append(predicates, gamehustlerquest.QuestContains(*i.QuestContains))
	}
	if i.QuestHasPrefix != nil {
		predicates = append(predicates, gamehustlerquest.QuestHasPrefix(*i.QuestHasPrefix))
	}
	if i.QuestHasSuffix != nil {
		predicates = append(predicates, gamehustlerquest.QuestHasSuffix(*i.QuestHasSuffix))
	}
	if i.QuestEqualFold != nil {
		predicates = append(predicates, gamehustlerquest.QuestEqualFold(*i.QuestEqualFold))
	}
	if i.QuestContainsFold != nil {
		predicates = append(predicates, gamehustlerquest.QuestContainsFold(*i.QuestContainsFold))
	}
	if i.Completed != nil {
		predicates = append(predicates, gamehustlerquest.CompletedEQ(*i.Completed))
	}
	if i.CompletedNEQ != nil {
		predicates = append(predicates, gamehustlerquest.CompletedNEQ(*i.CompletedNEQ))
	}

	if i.HasHustler != nil {
		p := gamehustlerquest.HasHustler()
		if !*i.HasHustler {
			p = gamehustlerquest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWith) > 0 {
		with := make([]predicate.GameHustler, 0, len(i.HasHustlerWith))
		for _, w := range i.HasHustlerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamehustlerquest.HasHustlerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameHustlerQuestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gamehustlerquest.And(predicates...), nil
	}
}

// GameHustlerRelationWhereInput represents a where input for filtering GameHustlerRelation queries.
type GameHustlerRelationWhereInput struct {
	Predicates []predicate.GameHustlerRelation  `json:"-"`
	Not        *GameHustlerRelationWhereInput   `json:"not,omitempty"`
	Or         []*GameHustlerRelationWhereInput `json:"or,omitempty"`
	And        []*GameHustlerRelationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "citizen" field predicates.
	Citizen             *string  `json:"citizen,omitempty"`
	CitizenNEQ          *string  `json:"citizenNEQ,omitempty"`
	CitizenIn           []string `json:"citizenIn,omitempty"`
	CitizenNotIn        []string `json:"citizenNotIn,omitempty"`
	CitizenGT           *string  `json:"citizenGT,omitempty"`
	CitizenGTE          *string  `json:"citizenGTE,omitempty"`
	CitizenLT           *string  `json:"citizenLT,omitempty"`
	CitizenLTE          *string  `json:"citizenLTE,omitempty"`
	CitizenContains     *string  `json:"citizenContains,omitempty"`
	CitizenHasPrefix    *string  `json:"citizenHasPrefix,omitempty"`
	CitizenHasSuffix    *string  `json:"citizenHasSuffix,omitempty"`
	CitizenEqualFold    *string  `json:"citizenEqualFold,omitempty"`
	CitizenContainsFold *string  `json:"citizenContainsFold,omitempty"`

	// "conversation" field predicates.
	Conversation             *string  `json:"conversation,omitempty"`
	ConversationNEQ          *string  `json:"conversationNEQ,omitempty"`
	ConversationIn           []string `json:"conversationIn,omitempty"`
	ConversationNotIn        []string `json:"conversationNotIn,omitempty"`
	ConversationGT           *string  `json:"conversationGT,omitempty"`
	ConversationGTE          *string  `json:"conversationGTE,omitempty"`
	ConversationLT           *string  `json:"conversationLT,omitempty"`
	ConversationLTE          *string  `json:"conversationLTE,omitempty"`
	ConversationContains     *string  `json:"conversationContains,omitempty"`
	ConversationHasPrefix    *string  `json:"conversationHasPrefix,omitempty"`
	ConversationHasSuffix    *string  `json:"conversationHasSuffix,omitempty"`
	ConversationEqualFold    *string  `json:"conversationEqualFold,omitempty"`
	ConversationContainsFold *string  `json:"conversationContainsFold,omitempty"`

	// "text" field predicates.
	Text      *uint  `json:"text,omitempty"`
	TextNEQ   *uint  `json:"textNEQ,omitempty"`
	TextIn    []uint `json:"textIn,omitempty"`
	TextNotIn []uint `json:"textNotIn,omitempty"`
	TextGT    *uint  `json:"textGT,omitempty"`
	TextGTE   *uint  `json:"textGTE,omitempty"`
	TextLT    *uint  `json:"textLT,omitempty"`
	TextLTE   *uint  `json:"textLTE,omitempty"`

	// "hustler" edge predicates.
	HasHustler     *bool                    `json:"hasHustler,omitempty"`
	HasHustlerWith []*GameHustlerWhereInput `json:"hasHustlerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameHustlerRelationWhereInput) AddPredicates(predicates ...predicate.GameHustlerRelation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameHustlerRelationWhereInput filter on the GameHustlerRelationQuery builder.
func (i *GameHustlerRelationWhereInput) Filter(q *GameHustlerRelationQuery) (*GameHustlerRelationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameHustlerRelationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameHustlerRelationWhereInput is returned in case the GameHustlerRelationWhereInput is empty.
var ErrEmptyGameHustlerRelationWhereInput = errors.New("ent: empty predicate GameHustlerRelationWhereInput")

// P returns a predicate for filtering gamehustlerrelations.
// An error is returned if the input is empty or invalid.
func (i *GameHustlerRelationWhereInput) P() (predicate.GameHustlerRelation, error) {
	var predicates []predicate.GameHustlerRelation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, gamehustlerrelation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.GameHustlerRelation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, gamehustlerrelation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.GameHustlerRelation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, gamehustlerrelation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, gamehustlerrelation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, gamehustlerrelation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, gamehustlerrelation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, gamehustlerrelation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, gamehustlerrelation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, gamehustlerrelation.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, gamehustlerrelation.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, gamehustlerrelation.IDContainsFold(*i.IDContainsFold))
	}
	if i.Citizen != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenEQ(*i.Citizen))
	}
	if i.CitizenNEQ != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenNEQ(*i.CitizenNEQ))
	}
	if len(i.CitizenIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.CitizenIn(i.CitizenIn...))
	}
	if len(i.CitizenNotIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.CitizenNotIn(i.CitizenNotIn...))
	}
	if i.CitizenGT != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenGT(*i.CitizenGT))
	}
	if i.CitizenGTE != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenGTE(*i.CitizenGTE))
	}
	if i.CitizenLT != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenLT(*i.CitizenLT))
	}
	if i.CitizenLTE != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenLTE(*i.CitizenLTE))
	}
	if i.CitizenContains != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenContains(*i.CitizenContains))
	}
	if i.CitizenHasPrefix != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenHasPrefix(*i.CitizenHasPrefix))
	}
	if i.CitizenHasSuffix != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenHasSuffix(*i.CitizenHasSuffix))
	}
	if i.CitizenEqualFold != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenEqualFold(*i.CitizenEqualFold))
	}
	if i.CitizenContainsFold != nil {
		predicates = append(predicates, gamehustlerrelation.CitizenContainsFold(*i.CitizenContainsFold))
	}
	if i.Conversation != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationEQ(*i.Conversation))
	}
	if i.ConversationNEQ != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationNEQ(*i.ConversationNEQ))
	}
	if len(i.ConversationIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.ConversationIn(i.ConversationIn...))
	}
	if len(i.ConversationNotIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.ConversationNotIn(i.ConversationNotIn...))
	}
	if i.ConversationGT != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationGT(*i.ConversationGT))
	}
	if i.ConversationGTE != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationGTE(*i.ConversationGTE))
	}
	if i.ConversationLT != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationLT(*i.ConversationLT))
	}
	if i.ConversationLTE != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationLTE(*i.ConversationLTE))
	}
	if i.ConversationContains != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationContains(*i.ConversationContains))
	}
	if i.ConversationHasPrefix != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationHasPrefix(*i.ConversationHasPrefix))
	}
	if i.ConversationHasSuffix != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationHasSuffix(*i.ConversationHasSuffix))
	}
	if i.ConversationEqualFold != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationEqualFold(*i.ConversationEqualFold))
	}
	if i.ConversationContainsFold != nil {
		predicates = append(predicates, gamehustlerrelation.ConversationContainsFold(*i.ConversationContainsFold))
	}
	if i.Text != nil {
		predicates = append(predicates, gamehustlerrelation.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, gamehustlerrelation.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, gamehustlerrelation.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, gamehustlerrelation.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, gamehustlerrelation.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, gamehustlerrelation.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, gamehustlerrelation.TextLTE(*i.TextLTE))
	}

	if i.HasHustler != nil {
		p := gamehustlerrelation.HasHustler()
		if !*i.HasHustler {
			p = gamehustlerrelation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWith) > 0 {
		with := make([]predicate.GameHustler, 0, len(i.HasHustlerWith))
		for _, w := range i.HasHustlerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, gamehustlerrelation.HasHustlerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameHustlerRelationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return gamehustlerrelation.And(predicates...), nil
	}
}

// HustlerWhereInput represents a where input for filtering Hustler queries.
type HustlerWhereInput struct {
	Predicates []predicate.Hustler  `json:"-"`
	Not        *HustlerWhereInput   `json:"not,omitempty"`
	Or         []*HustlerWhereInput `json:"or,omitempty"`
	And        []*HustlerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "type" field predicates.
	Type      *hustler.Type  `json:"type,omitempty"`
	TypeNEQ   *hustler.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []hustler.Type `json:"typeIn,omitempty"`
	TypeNotIn []hustler.Type `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "color" field predicates.
	Color             *string  `json:"color,omitempty"`
	ColorNEQ          *string  `json:"colorNEQ,omitempty"`
	ColorIn           []string `json:"colorIn,omitempty"`
	ColorNotIn        []string `json:"colorNotIn,omitempty"`
	ColorGT           *string  `json:"colorGT,omitempty"`
	ColorGTE          *string  `json:"colorGTE,omitempty"`
	ColorLT           *string  `json:"colorLT,omitempty"`
	ColorLTE          *string  `json:"colorLTE,omitempty"`
	ColorContains     *string  `json:"colorContains,omitempty"`
	ColorHasPrefix    *string  `json:"colorHasPrefix,omitempty"`
	ColorHasSuffix    *string  `json:"colorHasSuffix,omitempty"`
	ColorIsNil        bool     `json:"colorIsNil,omitempty"`
	ColorNotNil       bool     `json:"colorNotNil,omitempty"`
	ColorEqualFold    *string  `json:"colorEqualFold,omitempty"`
	ColorContainsFold *string  `json:"colorContainsFold,omitempty"`

	// "background" field predicates.
	Background             *string  `json:"background,omitempty"`
	BackgroundNEQ          *string  `json:"backgroundNEQ,omitempty"`
	BackgroundIn           []string `json:"backgroundIn,omitempty"`
	BackgroundNotIn        []string `json:"backgroundNotIn,omitempty"`
	BackgroundGT           *string  `json:"backgroundGT,omitempty"`
	BackgroundGTE          *string  `json:"backgroundGTE,omitempty"`
	BackgroundLT           *string  `json:"backgroundLT,omitempty"`
	BackgroundLTE          *string  `json:"backgroundLTE,omitempty"`
	BackgroundContains     *string  `json:"backgroundContains,omitempty"`
	BackgroundHasPrefix    *string  `json:"backgroundHasPrefix,omitempty"`
	BackgroundHasSuffix    *string  `json:"backgroundHasSuffix,omitempty"`
	BackgroundIsNil        bool     `json:"backgroundIsNil,omitempty"`
	BackgroundNotNil       bool     `json:"backgroundNotNil,omitempty"`
	BackgroundEqualFold    *string  `json:"backgroundEqualFold,omitempty"`
	BackgroundContainsFold *string  `json:"backgroundContainsFold,omitempty"`

	// "age" field predicates.
	Age      *uint64  `json:"age,omitempty"`
	AgeNEQ   *uint64  `json:"ageNEQ,omitempty"`
	AgeIn    []uint64 `json:"ageIn,omitempty"`
	AgeNotIn []uint64 `json:"ageNotIn,omitempty"`
	AgeGT    *uint64  `json:"ageGT,omitempty"`
	AgeGTE   *uint64  `json:"ageGTE,omitempty"`
	AgeLT    *uint64  `json:"ageLT,omitempty"`
	AgeLTE   *uint64  `json:"ageLTE,omitempty"`

	// "sex" field predicates.
	Sex      *hustler.Sex  `json:"sex,omitempty"`
	SexNEQ   *hustler.Sex  `json:"sexNEQ,omitempty"`
	SexIn    []hustler.Sex `json:"sexIn,omitempty"`
	SexNotIn []hustler.Sex `json:"sexNotIn,omitempty"`

	// "svg" field predicates.
	Svg             *string  `json:"svg,omitempty"`
	SvgNEQ          *string  `json:"svgNEQ,omitempty"`
	SvgIn           []string `json:"svgIn,omitempty"`
	SvgNotIn        []string `json:"svgNotIn,omitempty"`
	SvgGT           *string  `json:"svgGT,omitempty"`
	SvgGTE          *string  `json:"svgGTE,omitempty"`
	SvgLT           *string  `json:"svgLT,omitempty"`
	SvgLTE          *string  `json:"svgLTE,omitempty"`
	SvgContains     *string  `json:"svgContains,omitempty"`
	SvgHasPrefix    *string  `json:"svgHasPrefix,omitempty"`
	SvgHasSuffix    *string  `json:"svgHasSuffix,omitempty"`
	SvgIsNil        bool     `json:"svgIsNil,omitempty"`
	SvgNotNil       bool     `json:"svgNotNil,omitempty"`
	SvgEqualFold    *string  `json:"svgEqualFold,omitempty"`
	SvgContainsFold *string  `json:"svgContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "best_ask_price_eth" field predicates.
	BestAskPriceEth       *float64  `json:"bestAskPriceEth,omitempty"`
	BestAskPriceEthNEQ    *float64  `json:"bestAskPriceEthNEQ,omitempty"`
	BestAskPriceEthIn     []float64 `json:"bestAskPriceEthIn,omitempty"`
	BestAskPriceEthNotIn  []float64 `json:"bestAskPriceEthNotIn,omitempty"`
	BestAskPriceEthGT     *float64  `json:"bestAskPriceEthGT,omitempty"`
	BestAskPriceEthGTE    *float64  `json:"bestAskPriceEthGTE,omitempty"`
	BestAskPriceEthLT     *float64  `json:"bestAskPriceEthLT,omitempty"`
	BestAskPriceEthLTE    *float64  `json:"bestAskPriceEthLTE,omitempty"`
	BestAskPriceEthIsNil  bool      `json:"bestAskPriceEthIsNil,omitempty"`
	BestAskPriceEthNotNil bool      `json:"bestAskPriceEthNotNil,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "weapon" edge predicates.
	HasWeapon     *bool             `json:"hasWeapon,omitempty"`
	HasWeaponWith []*ItemWhereInput `json:"hasWeaponWith,omitempty"`

	// "clothes" edge predicates.
	HasClothes     *bool             `json:"hasClothes,omitempty"`
	HasClothesWith []*ItemWhereInput `json:"hasClothesWith,omitempty"`

	// "vehicle" edge predicates.
	HasVehicle     *bool             `json:"hasVehicle,omitempty"`
	HasVehicleWith []*ItemWhereInput `json:"hasVehicleWith,omitempty"`

	// "waist" edge predicates.
	HasWaist     *bool             `json:"hasWaist,omitempty"`
	HasWaistWith []*ItemWhereInput `json:"hasWaistWith,omitempty"`

	// "foot" edge predicates.
	HasFoot     *bool             `json:"hasFoot,omitempty"`
	HasFootWith []*ItemWhereInput `json:"hasFootWith,omitempty"`

	// "hand" edge predicates.
	HasHand     *bool             `json:"hasHand,omitempty"`
	HasHandWith []*ItemWhereInput `json:"hasHandWith,omitempty"`

	// "drug" edge predicates.
	HasDrug     *bool             `json:"hasDrug,omitempty"`
	HasDrugWith []*ItemWhereInput `json:"hasDrugWith,omitempty"`

	// "neck" edge predicates.
	HasNeck     *bool             `json:"hasNeck,omitempty"`
	HasNeckWith []*ItemWhereInput `json:"hasNeckWith,omitempty"`

	// "ring" edge predicates.
	HasRing     *bool             `json:"hasRing,omitempty"`
	HasRingWith []*ItemWhereInput `json:"hasRingWith,omitempty"`

	// "accessory" edge predicates.
	HasAccessory     *bool             `json:"hasAccessory,omitempty"`
	HasAccessoryWith []*ItemWhereInput `json:"hasAccessoryWith,omitempty"`

	// "body" edge predicates.
	HasBody     *bool                 `json:"hasBody,omitempty"`
	HasBodyWith []*BodyPartWhereInput `json:"hasBodyWith,omitempty"`

	// "hair" edge predicates.
	HasHair     *bool                 `json:"hasHair,omitempty"`
	HasHairWith []*BodyPartWhereInput `json:"hasHairWith,omitempty"`

	// "beard" edge predicates.
	HasBeard     *bool                 `json:"hasBeard,omitempty"`
	HasBeardWith []*BodyPartWhereInput `json:"hasBeardWith,omitempty"`

	// "index" edge predicates.
	HasIndex     *bool               `json:"hasIndex,omitempty"`
	HasIndexWith []*SearchWhereInput `json:"hasIndexWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HustlerWhereInput) AddPredicates(predicates ...predicate.Hustler) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HustlerWhereInput filter on the HustlerQuery builder.
func (i *HustlerWhereInput) Filter(q *HustlerQuery) (*HustlerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHustlerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHustlerWhereInput is returned in case the HustlerWhereInput is empty.
var ErrEmptyHustlerWhereInput = errors.New("ent: empty predicate HustlerWhereInput")

// P returns a predicate for filtering hustlers.
// An error is returned if the input is empty or invalid.
func (i *HustlerWhereInput) P() (predicate.Hustler, error) {
	var predicates []predicate.Hustler
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hustler.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Hustler, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hustler.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Hustler, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hustler.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hustler.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hustler.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hustler.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hustler.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hustler.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hustler.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hustler.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hustler.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, hustler.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, hustler.IDContainsFold(*i.IDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, hustler.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, hustler.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, hustler.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, hustler.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, hustler.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hustler.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hustler.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hustler.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hustler.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hustler.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hustler.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hustler.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hustler.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hustler.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hustler.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, hustler.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, hustler.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hustler.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hustler.NameContainsFold(*i.NameContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, hustler.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, hustler.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, hustler.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, hustler.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, hustler.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, hustler.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, hustler.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, hustler.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, hustler.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, hustler.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, hustler.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, hustler.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, hustler.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, hustler.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, hustler.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Color != nil {
		predicates = append(predicates, hustler.ColorEQ(*i.Color))
	}
	if i.ColorNEQ != nil {
		predicates = append(predicates, hustler.ColorNEQ(*i.ColorNEQ))
	}
	if len(i.ColorIn) > 0 {
		predicates = append(predicates, hustler.ColorIn(i.ColorIn...))
	}
	if len(i.ColorNotIn) > 0 {
		predicates = append(predicates, hustler.ColorNotIn(i.ColorNotIn...))
	}
	if i.ColorGT != nil {
		predicates = append(predicates, hustler.ColorGT(*i.ColorGT))
	}
	if i.ColorGTE != nil {
		predicates = append(predicates, hustler.ColorGTE(*i.ColorGTE))
	}
	if i.ColorLT != nil {
		predicates = append(predicates, hustler.ColorLT(*i.ColorLT))
	}
	if i.ColorLTE != nil {
		predicates = append(predicates, hustler.ColorLTE(*i.ColorLTE))
	}
	if i.ColorContains != nil {
		predicates = append(predicates, hustler.ColorContains(*i.ColorContains))
	}
	if i.ColorHasPrefix != nil {
		predicates = append(predicates, hustler.ColorHasPrefix(*i.ColorHasPrefix))
	}
	if i.ColorHasSuffix != nil {
		predicates = append(predicates, hustler.ColorHasSuffix(*i.ColorHasSuffix))
	}
	if i.ColorIsNil {
		predicates = append(predicates, hustler.ColorIsNil())
	}
	if i.ColorNotNil {
		predicates = append(predicates, hustler.ColorNotNil())
	}
	if i.ColorEqualFold != nil {
		predicates = append(predicates, hustler.ColorEqualFold(*i.ColorEqualFold))
	}
	if i.ColorContainsFold != nil {
		predicates = append(predicates, hustler.ColorContainsFold(*i.ColorContainsFold))
	}
	if i.Background != nil {
		predicates = append(predicates, hustler.BackgroundEQ(*i.Background))
	}
	if i.BackgroundNEQ != nil {
		predicates = append(predicates, hustler.BackgroundNEQ(*i.BackgroundNEQ))
	}
	if len(i.BackgroundIn) > 0 {
		predicates = append(predicates, hustler.BackgroundIn(i.BackgroundIn...))
	}
	if len(i.BackgroundNotIn) > 0 {
		predicates = append(predicates, hustler.BackgroundNotIn(i.BackgroundNotIn...))
	}
	if i.BackgroundGT != nil {
		predicates = append(predicates, hustler.BackgroundGT(*i.BackgroundGT))
	}
	if i.BackgroundGTE != nil {
		predicates = append(predicates, hustler.BackgroundGTE(*i.BackgroundGTE))
	}
	if i.BackgroundLT != nil {
		predicates = append(predicates, hustler.BackgroundLT(*i.BackgroundLT))
	}
	if i.BackgroundLTE != nil {
		predicates = append(predicates, hustler.BackgroundLTE(*i.BackgroundLTE))
	}
	if i.BackgroundContains != nil {
		predicates = append(predicates, hustler.BackgroundContains(*i.BackgroundContains))
	}
	if i.BackgroundHasPrefix != nil {
		predicates = append(predicates, hustler.BackgroundHasPrefix(*i.BackgroundHasPrefix))
	}
	if i.BackgroundHasSuffix != nil {
		predicates = append(predicates, hustler.BackgroundHasSuffix(*i.BackgroundHasSuffix))
	}
	if i.BackgroundIsNil {
		predicates = append(predicates, hustler.BackgroundIsNil())
	}
	if i.BackgroundNotNil {
		predicates = append(predicates, hustler.BackgroundNotNil())
	}
	if i.BackgroundEqualFold != nil {
		predicates = append(predicates, hustler.BackgroundEqualFold(*i.BackgroundEqualFold))
	}
	if i.BackgroundContainsFold != nil {
		predicates = append(predicates, hustler.BackgroundContainsFold(*i.BackgroundContainsFold))
	}
	if i.Age != nil {
		predicates = append(predicates, hustler.AgeEQ(*i.Age))
	}
	if i.AgeNEQ != nil {
		predicates = append(predicates, hustler.AgeNEQ(*i.AgeNEQ))
	}
	if len(i.AgeIn) > 0 {
		predicates = append(predicates, hustler.AgeIn(i.AgeIn...))
	}
	if len(i.AgeNotIn) > 0 {
		predicates = append(predicates, hustler.AgeNotIn(i.AgeNotIn...))
	}
	if i.AgeGT != nil {
		predicates = append(predicates, hustler.AgeGT(*i.AgeGT))
	}
	if i.AgeGTE != nil {
		predicates = append(predicates, hustler.AgeGTE(*i.AgeGTE))
	}
	if i.AgeLT != nil {
		predicates = append(predicates, hustler.AgeLT(*i.AgeLT))
	}
	if i.AgeLTE != nil {
		predicates = append(predicates, hustler.AgeLTE(*i.AgeLTE))
	}
	if i.Sex != nil {
		predicates = append(predicates, hustler.SexEQ(*i.Sex))
	}
	if i.SexNEQ != nil {
		predicates = append(predicates, hustler.SexNEQ(*i.SexNEQ))
	}
	if len(i.SexIn) > 0 {
		predicates = append(predicates, hustler.SexIn(i.SexIn...))
	}
	if len(i.SexNotIn) > 0 {
		predicates = append(predicates, hustler.SexNotIn(i.SexNotIn...))
	}
	if i.Svg != nil {
		predicates = append(predicates, hustler.SvgEQ(*i.Svg))
	}
	if i.SvgNEQ != nil {
		predicates = append(predicates, hustler.SvgNEQ(*i.SvgNEQ))
	}
	if len(i.SvgIn) > 0 {
		predicates = append(predicates, hustler.SvgIn(i.SvgIn...))
	}
	if len(i.SvgNotIn) > 0 {
		predicates = append(predicates, hustler.SvgNotIn(i.SvgNotIn...))
	}
	if i.SvgGT != nil {
		predicates = append(predicates, hustler.SvgGT(*i.SvgGT))
	}
	if i.SvgGTE != nil {
		predicates = append(predicates, hustler.SvgGTE(*i.SvgGTE))
	}
	if i.SvgLT != nil {
		predicates = append(predicates, hustler.SvgLT(*i.SvgLT))
	}
	if i.SvgLTE != nil {
		predicates = append(predicates, hustler.SvgLTE(*i.SvgLTE))
	}
	if i.SvgContains != nil {
		predicates = append(predicates, hustler.SvgContains(*i.SvgContains))
	}
	if i.SvgHasPrefix != nil {
		predicates = append(predicates, hustler.SvgHasPrefix(*i.SvgHasPrefix))
	}
	if i.SvgHasSuffix != nil {
		predicates = append(predicates, hustler.SvgHasSuffix(*i.SvgHasSuffix))
	}
	if i.SvgIsNil {
		predicates = append(predicates, hustler.SvgIsNil())
	}
	if i.SvgNotNil {
		predicates = append(predicates, hustler.SvgNotNil())
	}
	if i.SvgEqualFold != nil {
		predicates = append(predicates, hustler.SvgEqualFold(*i.SvgEqualFold))
	}
	if i.SvgContainsFold != nil {
		predicates = append(predicates, hustler.SvgContainsFold(*i.SvgContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hustler.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hustler.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hustler.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hustler.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hustler.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hustler.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hustler.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hustler.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.BestAskPriceEth != nil {
		predicates = append(predicates, hustler.BestAskPriceEthEQ(*i.BestAskPriceEth))
	}
	if i.BestAskPriceEthNEQ != nil {
		predicates = append(predicates, hustler.BestAskPriceEthNEQ(*i.BestAskPriceEthNEQ))
	}
	if len(i.BestAskPriceEthIn) > 0 {
		predicates = append(predicates, hustler.BestAskPriceEthIn(i.BestAskPriceEthIn...))
	}
	if len(i.BestAskPriceEthNotIn) > 0 {
		predicates = append(predicates, hustler.BestAskPriceEthNotIn(i.BestAskPriceEthNotIn...))
	}
	if i.BestAskPriceEthGT != nil {
		predicates = append(predicates, hustler.BestAskPriceEthGT(*i.BestAskPriceEthGT))
	}
	if i.BestAskPriceEthGTE != nil {
		predicates = append(predicates, hustler.BestAskPriceEthGTE(*i.BestAskPriceEthGTE))
	}
	if i.BestAskPriceEthLT != nil {
		predicates = append(predicates, hustler.BestAskPriceEthLT(*i.BestAskPriceEthLT))
	}
	if i.BestAskPriceEthLTE != nil {
		predicates = append(predicates, hustler.BestAskPriceEthLTE(*i.BestAskPriceEthLTE))
	}
	if i.BestAskPriceEthIsNil {
		predicates = append(predicates, hustler.BestAskPriceEthIsNil())
	}
	if i.BestAskPriceEthNotNil {
		predicates = append(predicates, hustler.BestAskPriceEthNotNil())
	}

	if i.HasWallet != nil {
		p := hustler.HasWallet()
		if !*i.HasWallet {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWalletWith(with...))
	}
	if i.HasWeapon != nil {
		p := hustler.HasWeapon()
		if !*i.HasWeapon {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWeaponWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasWeaponWith))
		for _, w := range i.HasWeaponWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWeaponWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWeaponWith(with...))
	}
	if i.HasClothes != nil {
		p := hustler.HasClothes()
		if !*i.HasClothes {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClothesWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasClothesWith))
		for _, w := range i.HasClothesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClothesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasClothesWith(with...))
	}
	if i.HasVehicle != nil {
		p := hustler.HasVehicle()
		if !*i.HasVehicle {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVehicleWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasVehicleWith))
		for _, w := range i.HasVehicleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVehicleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasVehicleWith(with...))
	}
	if i.HasWaist != nil {
		p := hustler.HasWaist()
		if !*i.HasWaist {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWaistWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasWaistWith))
		for _, w := range i.HasWaistWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWaistWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasWaistWith(with...))
	}
	if i.HasFoot != nil {
		p := hustler.HasFoot()
		if !*i.HasFoot {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFootWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasFootWith))
		for _, w := range i.HasFootWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFootWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasFootWith(with...))
	}
	if i.HasHand != nil {
		p := hustler.HasHand()
		if !*i.HasHand {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHandWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasHandWith))
		for _, w := range i.HasHandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasHandWith(with...))
	}
	if i.HasDrug != nil {
		p := hustler.HasDrug()
		if !*i.HasDrug {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDrugWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasDrugWith))
		for _, w := range i.HasDrugWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDrugWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasDrugWith(with...))
	}
	if i.HasNeck != nil {
		p := hustler.HasNeck()
		if !*i.HasNeck {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNeckWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasNeckWith))
		for _, w := range i.HasNeckWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNeckWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasNeckWith(with...))
	}
	if i.HasRing != nil {
		p := hustler.HasRing()
		if !*i.HasRing {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRingWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasRingWith))
		for _, w := range i.HasRingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasRingWith(with...))
	}
	if i.HasAccessory != nil {
		p := hustler.HasAccessory()
		if !*i.HasAccessory {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccessoryWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasAccessoryWith))
		for _, w := range i.HasAccessoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccessoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasAccessoryWith(with...))
	}
	if i.HasBody != nil {
		p := hustler.HasBody()
		if !*i.HasBody {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBodyWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasBodyWith))
		for _, w := range i.HasBodyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBodyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasBodyWith(with...))
	}
	if i.HasHair != nil {
		p := hustler.HasHair()
		if !*i.HasHair {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHairWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasHairWith))
		for _, w := range i.HasHairWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHairWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasHairWith(with...))
	}
	if i.HasBeard != nil {
		p := hustler.HasBeard()
		if !*i.HasBeard {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBeardWith) > 0 {
		with := make([]predicate.BodyPart, 0, len(i.HasBeardWith))
		for _, w := range i.HasBeardWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBeardWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasBeardWith(with...))
	}
	if i.HasIndex != nil {
		p := hustler.HasIndex()
		if !*i.HasIndex {
			p = hustler.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIndexWith) > 0 {
		with := make([]predicate.Search, 0, len(i.HasIndexWith))
		for _, w := range i.HasIndexWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIndexWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hustler.HasIndexWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHustlerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hustler.And(predicates...), nil
	}
}

// ItemWhereInput represents a where input for filtering Item queries.
type ItemWhereInput struct {
	Predicates []predicate.Item  `json:"-"`
	Not        *ItemWhereInput   `json:"not,omitempty"`
	Or         []*ItemWhereInput `json:"or,omitempty"`
	And        []*ItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "type" field predicates.
	Type      *item.Type  `json:"type,omitempty"`
	TypeNEQ   *item.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []item.Type `json:"typeIn,omitempty"`
	TypeNotIn []item.Type `json:"typeNotIn,omitempty"`

	// "name_prefix" field predicates.
	NamePrefix             *string  `json:"namePrefix,omitempty"`
	NamePrefixNEQ          *string  `json:"namePrefixNEQ,omitempty"`
	NamePrefixIn           []string `json:"namePrefixIn,omitempty"`
	NamePrefixNotIn        []string `json:"namePrefixNotIn,omitempty"`
	NamePrefixGT           *string  `json:"namePrefixGT,omitempty"`
	NamePrefixGTE          *string  `json:"namePrefixGTE,omitempty"`
	NamePrefixLT           *string  `json:"namePrefixLT,omitempty"`
	NamePrefixLTE          *string  `json:"namePrefixLTE,omitempty"`
	NamePrefixContains     *string  `json:"namePrefixContains,omitempty"`
	NamePrefixHasPrefix    *string  `json:"namePrefixHasPrefix,omitempty"`
	NamePrefixHasSuffix    *string  `json:"namePrefixHasSuffix,omitempty"`
	NamePrefixIsNil        bool     `json:"namePrefixIsNil,omitempty"`
	NamePrefixNotNil       bool     `json:"namePrefixNotNil,omitempty"`
	NamePrefixEqualFold    *string  `json:"namePrefixEqualFold,omitempty"`
	NamePrefixContainsFold *string  `json:"namePrefixContainsFold,omitempty"`

	// "name_suffix" field predicates.
	NameSuffix             *string  `json:"nameSuffix,omitempty"`
	NameSuffixNEQ          *string  `json:"nameSuffixNEQ,omitempty"`
	NameSuffixIn           []string `json:"nameSuffixIn,omitempty"`
	NameSuffixNotIn        []string `json:"nameSuffixNotIn,omitempty"`
	NameSuffixGT           *string  `json:"nameSuffixGT,omitempty"`
	NameSuffixGTE          *string  `json:"nameSuffixGTE,omitempty"`
	NameSuffixLT           *string  `json:"nameSuffixLT,omitempty"`
	NameSuffixLTE          *string  `json:"nameSuffixLTE,omitempty"`
	NameSuffixContains     *string  `json:"nameSuffixContains,omitempty"`
	NameSuffixHasPrefix    *string  `json:"nameSuffixHasPrefix,omitempty"`
	NameSuffixHasSuffix    *string  `json:"nameSuffixHasSuffix,omitempty"`
	NameSuffixIsNil        bool     `json:"nameSuffixIsNil,omitempty"`
	NameSuffixNotNil       bool     `json:"nameSuffixNotNil,omitempty"`
	NameSuffixEqualFold    *string  `json:"nameSuffixEqualFold,omitempty"`
	NameSuffixContainsFold *string  `json:"nameSuffixContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "suffix" field predicates.
	Suffix             *string  `json:"suffix,omitempty"`
	SuffixNEQ          *string  `json:"suffixNEQ,omitempty"`
	SuffixIn           []string `json:"suffixIn,omitempty"`
	SuffixNotIn        []string `json:"suffixNotIn,omitempty"`
	SuffixGT           *string  `json:"suffixGT,omitempty"`
	SuffixGTE          *string  `json:"suffixGTE,omitempty"`
	SuffixLT           *string  `json:"suffixLT,omitempty"`
	SuffixLTE          *string  `json:"suffixLTE,omitempty"`
	SuffixContains     *string  `json:"suffixContains,omitempty"`
	SuffixHasPrefix    *string  `json:"suffixHasPrefix,omitempty"`
	SuffixHasSuffix    *string  `json:"suffixHasSuffix,omitempty"`
	SuffixIsNil        bool     `json:"suffixIsNil,omitempty"`
	SuffixNotNil       bool     `json:"suffixNotNil,omitempty"`
	SuffixEqualFold    *string  `json:"suffixEqualFold,omitempty"`
	SuffixContainsFold *string  `json:"suffixContainsFold,omitempty"`

	// "augmented" field predicates.
	Augmented       *bool `json:"augmented,omitempty"`
	AugmentedNEQ    *bool `json:"augmentedNEQ,omitempty"`
	AugmentedIsNil  bool  `json:"augmentedIsNil,omitempty"`
	AugmentedNotNil bool  `json:"augmentedNotNil,omitempty"`

	// "count" field predicates.
	Count       *int  `json:"count,omitempty"`
	CountNEQ    *int  `json:"countNEQ,omitempty"`
	CountIn     []int `json:"countIn,omitempty"`
	CountNotIn  []int `json:"countNotIn,omitempty"`
	CountGT     *int  `json:"countGT,omitempty"`
	CountGTE    *int  `json:"countGTE,omitempty"`
	CountLT     *int  `json:"countLT,omitempty"`
	CountLTE    *int  `json:"countLTE,omitempty"`
	CountIsNil  bool  `json:"countIsNil,omitempty"`
	CountNotNil bool  `json:"countNotNil,omitempty"`

	// "tier" field predicates.
	Tier       *item.Tier  `json:"tier,omitempty"`
	TierNEQ    *item.Tier  `json:"tierNEQ,omitempty"`
	TierIn     []item.Tier `json:"tierIn,omitempty"`
	TierNotIn  []item.Tier `json:"tierNotIn,omitempty"`
	TierIsNil  bool        `json:"tierIsNil,omitempty"`
	TierNotNil bool        `json:"tierNotNil,omitempty"`

	// "greatness" field predicates.
	Greatness       *int  `json:"greatness,omitempty"`
	GreatnessNEQ    *int  `json:"greatnessNEQ,omitempty"`
	GreatnessIn     []int `json:"greatnessIn,omitempty"`
	GreatnessNotIn  []int `json:"greatnessNotIn,omitempty"`
	GreatnessGT     *int  `json:"greatnessGT,omitempty"`
	GreatnessGTE    *int  `json:"greatnessGTE,omitempty"`
	GreatnessLT     *int  `json:"greatnessLT,omitempty"`
	GreatnessLTE    *int  `json:"greatnessLTE,omitempty"`
	GreatnessIsNil  bool  `json:"greatnessIsNil,omitempty"`
	GreatnessNotNil bool  `json:"greatnessNotNil,omitempty"`

	// "svg" field predicates.
	Svg             *string  `json:"svg,omitempty"`
	SvgNEQ          *string  `json:"svgNEQ,omitempty"`
	SvgIn           []string `json:"svgIn,omitempty"`
	SvgNotIn        []string `json:"svgNotIn,omitempty"`
	SvgGT           *string  `json:"svgGT,omitempty"`
	SvgGTE          *string  `json:"svgGTE,omitempty"`
	SvgLT           *string  `json:"svgLT,omitempty"`
	SvgLTE          *string  `json:"svgLTE,omitempty"`
	SvgContains     *string  `json:"svgContains,omitempty"`
	SvgHasPrefix    *string  `json:"svgHasPrefix,omitempty"`
	SvgHasSuffix    *string  `json:"svgHasSuffix,omitempty"`
	SvgIsNil        bool     `json:"svgIsNil,omitempty"`
	SvgNotNil       bool     `json:"svgNotNil,omitempty"`
	SvgEqualFold    *string  `json:"svgEqualFold,omitempty"`
	SvgContainsFold *string  `json:"svgContainsFold,omitempty"`

	// "best_ask_price_eth" field predicates.
	BestAskPriceEth       *float64  `json:"bestAskPriceEth,omitempty"`
	BestAskPriceEthNEQ    *float64  `json:"bestAskPriceEthNEQ,omitempty"`
	BestAskPriceEthIn     []float64 `json:"bestAskPriceEthIn,omitempty"`
	BestAskPriceEthNotIn  []float64 `json:"bestAskPriceEthNotIn,omitempty"`
	BestAskPriceEthGT     *float64  `json:"bestAskPriceEthGT,omitempty"`
	BestAskPriceEthGTE    *float64  `json:"bestAskPriceEthGTE,omitempty"`
	BestAskPriceEthLT     *float64  `json:"bestAskPriceEthLT,omitempty"`
	BestAskPriceEthLTE    *float64  `json:"bestAskPriceEthLTE,omitempty"`
	BestAskPriceEthIsNil  bool      `json:"bestAskPriceEthIsNil,omitempty"`
	BestAskPriceEthNotNil bool      `json:"bestAskPriceEthNotNil,omitempty"`

	// "wallets" edge predicates.
	HasWallets     *bool                    `json:"hasWallets,omitempty"`
	HasWalletsWith []*WalletItemsWhereInput `json:"hasWalletsWith,omitempty"`

	// "dopes" edge predicates.
	HasDopes     *bool             `json:"hasDopes,omitempty"`
	HasDopesWith []*DopeWhereInput `json:"hasDopesWith,omitempty"`

	// "hustler_weapons" edge predicates.
	HasHustlerWeapons     *bool                `json:"hasHustlerWeapons,omitempty"`
	HasHustlerWeaponsWith []*HustlerWhereInput `json:"hasHustlerWeaponsWith,omitempty"`

	// "hustler_clothes" edge predicates.
	HasHustlerClothes     *bool                `json:"hasHustlerClothes,omitempty"`
	HasHustlerClothesWith []*HustlerWhereInput `json:"hasHustlerClothesWith,omitempty"`

	// "hustler_vehicles" edge predicates.
	HasHustlerVehicles     *bool                `json:"hasHustlerVehicles,omitempty"`
	HasHustlerVehiclesWith []*HustlerWhereInput `json:"hasHustlerVehiclesWith,omitempty"`

	// "hustler_waists" edge predicates.
	HasHustlerWaists     *bool                `json:"hasHustlerWaists,omitempty"`
	HasHustlerWaistsWith []*HustlerWhereInput `json:"hasHustlerWaistsWith,omitempty"`

	// "hustler_feet" edge predicates.
	HasHustlerFeet     *bool                `json:"hasHustlerFeet,omitempty"`
	HasHustlerFeetWith []*HustlerWhereInput `json:"hasHustlerFeetWith,omitempty"`

	// "hustler_hands" edge predicates.
	HasHustlerHands     *bool                `json:"hasHustlerHands,omitempty"`
	HasHustlerHandsWith []*HustlerWhereInput `json:"hasHustlerHandsWith,omitempty"`

	// "hustler_drugs" edge predicates.
	HasHustlerDrugs     *bool                `json:"hasHustlerDrugs,omitempty"`
	HasHustlerDrugsWith []*HustlerWhereInput `json:"hasHustlerDrugsWith,omitempty"`

	// "hustler_necks" edge predicates.
	HasHustlerNecks     *bool                `json:"hasHustlerNecks,omitempty"`
	HasHustlerNecksWith []*HustlerWhereInput `json:"hasHustlerNecksWith,omitempty"`

	// "hustler_rings" edge predicates.
	HasHustlerRings     *bool                `json:"hasHustlerRings,omitempty"`
	HasHustlerRingsWith []*HustlerWhereInput `json:"hasHustlerRingsWith,omitempty"`

	// "hustler_accessories" edge predicates.
	HasHustlerAccessories     *bool                `json:"hasHustlerAccessories,omitempty"`
	HasHustlerAccessoriesWith []*HustlerWhereInput `json:"hasHustlerAccessoriesWith,omitempty"`

	// "base" edge predicates.
	HasBase     *bool             `json:"hasBase,omitempty"`
	HasBaseWith []*ItemWhereInput `json:"hasBaseWith,omitempty"`

	// "derivative" edge predicates.
	HasDerivative     *bool             `json:"hasDerivative,omitempty"`
	HasDerivativeWith []*ItemWhereInput `json:"hasDerivativeWith,omitempty"`

	// "index" edge predicates.
	HasIndex     *bool               `json:"hasIndex,omitempty"`
	HasIndexWith []*SearchWhereInput `json:"hasIndexWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ItemWhereInput) AddPredicates(predicates ...predicate.Item) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ItemWhereInput filter on the ItemQuery builder.
func (i *ItemWhereInput) Filter(q *ItemQuery) (*ItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyItemWhereInput is returned in case the ItemWhereInput is empty.
var ErrEmptyItemWhereInput = errors.New("ent: empty predicate ItemWhereInput")

// P returns a predicate for filtering items.
// An error is returned if the input is empty or invalid.
func (i *ItemWhereInput) P() (predicate.Item, error) {
	var predicates []predicate.Item
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, item.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Item, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, item.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Item, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, item.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, item.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, item.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, item.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, item.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, item.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, item.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, item.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, item.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, item.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, item.IDContainsFold(*i.IDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, item.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, item.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, item.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, item.TypeNotIn(i.TypeNotIn...))
	}
	if i.NamePrefix != nil {
		predicates = append(predicates, item.NamePrefixEQ(*i.NamePrefix))
	}
	if i.NamePrefixNEQ != nil {
		predicates = append(predicates, item.NamePrefixNEQ(*i.NamePrefixNEQ))
	}
	if len(i.NamePrefixIn) > 0 {
		predicates = append(predicates, item.NamePrefixIn(i.NamePrefixIn...))
	}
	if len(i.NamePrefixNotIn) > 0 {
		predicates = append(predicates, item.NamePrefixNotIn(i.NamePrefixNotIn...))
	}
	if i.NamePrefixGT != nil {
		predicates = append(predicates, item.NamePrefixGT(*i.NamePrefixGT))
	}
	if i.NamePrefixGTE != nil {
		predicates = append(predicates, item.NamePrefixGTE(*i.NamePrefixGTE))
	}
	if i.NamePrefixLT != nil {
		predicates = append(predicates, item.NamePrefixLT(*i.NamePrefixLT))
	}
	if i.NamePrefixLTE != nil {
		predicates = append(predicates, item.NamePrefixLTE(*i.NamePrefixLTE))
	}
	if i.NamePrefixContains != nil {
		predicates = append(predicates, item.NamePrefixContains(*i.NamePrefixContains))
	}
	if i.NamePrefixHasPrefix != nil {
		predicates = append(predicates, item.NamePrefixHasPrefix(*i.NamePrefixHasPrefix))
	}
	if i.NamePrefixHasSuffix != nil {
		predicates = append(predicates, item.NamePrefixHasSuffix(*i.NamePrefixHasSuffix))
	}
	if i.NamePrefixIsNil {
		predicates = append(predicates, item.NamePrefixIsNil())
	}
	if i.NamePrefixNotNil {
		predicates = append(predicates, item.NamePrefixNotNil())
	}
	if i.NamePrefixEqualFold != nil {
		predicates = append(predicates, item.NamePrefixEqualFold(*i.NamePrefixEqualFold))
	}
	if i.NamePrefixContainsFold != nil {
		predicates = append(predicates, item.NamePrefixContainsFold(*i.NamePrefixContainsFold))
	}
	if i.NameSuffix != nil {
		predicates = append(predicates, item.NameSuffixEQ(*i.NameSuffix))
	}
	if i.NameSuffixNEQ != nil {
		predicates = append(predicates, item.NameSuffixNEQ(*i.NameSuffixNEQ))
	}
	if len(i.NameSuffixIn) > 0 {
		predicates = append(predicates, item.NameSuffixIn(i.NameSuffixIn...))
	}
	if len(i.NameSuffixNotIn) > 0 {
		predicates = append(predicates, item.NameSuffixNotIn(i.NameSuffixNotIn...))
	}
	if i.NameSuffixGT != nil {
		predicates = append(predicates, item.NameSuffixGT(*i.NameSuffixGT))
	}
	if i.NameSuffixGTE != nil {
		predicates = append(predicates, item.NameSuffixGTE(*i.NameSuffixGTE))
	}
	if i.NameSuffixLT != nil {
		predicates = append(predicates, item.NameSuffixLT(*i.NameSuffixLT))
	}
	if i.NameSuffixLTE != nil {
		predicates = append(predicates, item.NameSuffixLTE(*i.NameSuffixLTE))
	}
	if i.NameSuffixContains != nil {
		predicates = append(predicates, item.NameSuffixContains(*i.NameSuffixContains))
	}
	if i.NameSuffixHasPrefix != nil {
		predicates = append(predicates, item.NameSuffixHasPrefix(*i.NameSuffixHasPrefix))
	}
	if i.NameSuffixHasSuffix != nil {
		predicates = append(predicates, item.NameSuffixHasSuffix(*i.NameSuffixHasSuffix))
	}
	if i.NameSuffixIsNil {
		predicates = append(predicates, item.NameSuffixIsNil())
	}
	if i.NameSuffixNotNil {
		predicates = append(predicates, item.NameSuffixNotNil())
	}
	if i.NameSuffixEqualFold != nil {
		predicates = append(predicates, item.NameSuffixEqualFold(*i.NameSuffixEqualFold))
	}
	if i.NameSuffixContainsFold != nil {
		predicates = append(predicates, item.NameSuffixContainsFold(*i.NameSuffixContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, item.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, item.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, item.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, item.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, item.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, item.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, item.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, item.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, item.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, item.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, item.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, item.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, item.NameContainsFold(*i.NameContainsFold))
	}
	if i.Suffix != nil {
		predicates = append(predicates, item.SuffixEQ(*i.Suffix))
	}
	if i.SuffixNEQ != nil {
		predicates = append(predicates, item.SuffixNEQ(*i.SuffixNEQ))
	}
	if len(i.SuffixIn) > 0 {
		predicates = append(predicates, item.SuffixIn(i.SuffixIn...))
	}
	if len(i.SuffixNotIn) > 0 {
		predicates = append(predicates, item.SuffixNotIn(i.SuffixNotIn...))
	}
	if i.SuffixGT != nil {
		predicates = append(predicates, item.SuffixGT(*i.SuffixGT))
	}
	if i.SuffixGTE != nil {
		predicates = append(predicates, item.SuffixGTE(*i.SuffixGTE))
	}
	if i.SuffixLT != nil {
		predicates = append(predicates, item.SuffixLT(*i.SuffixLT))
	}
	if i.SuffixLTE != nil {
		predicates = append(predicates, item.SuffixLTE(*i.SuffixLTE))
	}
	if i.SuffixContains != nil {
		predicates = append(predicates, item.SuffixContains(*i.SuffixContains))
	}
	if i.SuffixHasPrefix != nil {
		predicates = append(predicates, item.SuffixHasPrefix(*i.SuffixHasPrefix))
	}
	if i.SuffixHasSuffix != nil {
		predicates = append(predicates, item.SuffixHasSuffix(*i.SuffixHasSuffix))
	}
	if i.SuffixIsNil {
		predicates = append(predicates, item.SuffixIsNil())
	}
	if i.SuffixNotNil {
		predicates = append(predicates, item.SuffixNotNil())
	}
	if i.SuffixEqualFold != nil {
		predicates = append(predicates, item.SuffixEqualFold(*i.SuffixEqualFold))
	}
	if i.SuffixContainsFold != nil {
		predicates = append(predicates, item.SuffixContainsFold(*i.SuffixContainsFold))
	}
	if i.Augmented != nil {
		predicates = append(predicates, item.AugmentedEQ(*i.Augmented))
	}
	if i.AugmentedNEQ != nil {
		predicates = append(predicates, item.AugmentedNEQ(*i.AugmentedNEQ))
	}
	if i.AugmentedIsNil {
		predicates = append(predicates, item.AugmentedIsNil())
	}
	if i.AugmentedNotNil {
		predicates = append(predicates, item.AugmentedNotNil())
	}
	if i.Count != nil {
		predicates = append(predicates, item.CountEQ(*i.Count))
	}
	if i.CountNEQ != nil {
		predicates = append(predicates, item.CountNEQ(*i.CountNEQ))
	}
	if len(i.CountIn) > 0 {
		predicates = append(predicates, item.CountIn(i.CountIn...))
	}
	if len(i.CountNotIn) > 0 {
		predicates = append(predicates, item.CountNotIn(i.CountNotIn...))
	}
	if i.CountGT != nil {
		predicates = append(predicates, item.CountGT(*i.CountGT))
	}
	if i.CountGTE != nil {
		predicates = append(predicates, item.CountGTE(*i.CountGTE))
	}
	if i.CountLT != nil {
		predicates = append(predicates, item.CountLT(*i.CountLT))
	}
	if i.CountLTE != nil {
		predicates = append(predicates, item.CountLTE(*i.CountLTE))
	}
	if i.CountIsNil {
		predicates = append(predicates, item.CountIsNil())
	}
	if i.CountNotNil {
		predicates = append(predicates, item.CountNotNil())
	}
	if i.Tier != nil {
		predicates = append(predicates, item.TierEQ(*i.Tier))
	}
	if i.TierNEQ != nil {
		predicates = append(predicates, item.TierNEQ(*i.TierNEQ))
	}
	if len(i.TierIn) > 0 {
		predicates = append(predicates, item.TierIn(i.TierIn...))
	}
	if len(i.TierNotIn) > 0 {
		predicates = append(predicates, item.TierNotIn(i.TierNotIn...))
	}
	if i.TierIsNil {
		predicates = append(predicates, item.TierIsNil())
	}
	if i.TierNotNil {
		predicates = append(predicates, item.TierNotNil())
	}
	if i.Greatness != nil {
		predicates = append(predicates, item.GreatnessEQ(*i.Greatness))
	}
	if i.GreatnessNEQ != nil {
		predicates = append(predicates, item.GreatnessNEQ(*i.GreatnessNEQ))
	}
	if len(i.GreatnessIn) > 0 {
		predicates = append(predicates, item.GreatnessIn(i.GreatnessIn...))
	}
	if len(i.GreatnessNotIn) > 0 {
		predicates = append(predicates, item.GreatnessNotIn(i.GreatnessNotIn...))
	}
	if i.GreatnessGT != nil {
		predicates = append(predicates, item.GreatnessGT(*i.GreatnessGT))
	}
	if i.GreatnessGTE != nil {
		predicates = append(predicates, item.GreatnessGTE(*i.GreatnessGTE))
	}
	if i.GreatnessLT != nil {
		predicates = append(predicates, item.GreatnessLT(*i.GreatnessLT))
	}
	if i.GreatnessLTE != nil {
		predicates = append(predicates, item.GreatnessLTE(*i.GreatnessLTE))
	}
	if i.GreatnessIsNil {
		predicates = append(predicates, item.GreatnessIsNil())
	}
	if i.GreatnessNotNil {
		predicates = append(predicates, item.GreatnessNotNil())
	}
	if i.Svg != nil {
		predicates = append(predicates, item.SvgEQ(*i.Svg))
	}
	if i.SvgNEQ != nil {
		predicates = append(predicates, item.SvgNEQ(*i.SvgNEQ))
	}
	if len(i.SvgIn) > 0 {
		predicates = append(predicates, item.SvgIn(i.SvgIn...))
	}
	if len(i.SvgNotIn) > 0 {
		predicates = append(predicates, item.SvgNotIn(i.SvgNotIn...))
	}
	if i.SvgGT != nil {
		predicates = append(predicates, item.SvgGT(*i.SvgGT))
	}
	if i.SvgGTE != nil {
		predicates = append(predicates, item.SvgGTE(*i.SvgGTE))
	}
	if i.SvgLT != nil {
		predicates = append(predicates, item.SvgLT(*i.SvgLT))
	}
	if i.SvgLTE != nil {
		predicates = append(predicates, item.SvgLTE(*i.SvgLTE))
	}
	if i.SvgContains != nil {
		predicates = append(predicates, item.SvgContains(*i.SvgContains))
	}
	if i.SvgHasPrefix != nil {
		predicates = append(predicates, item.SvgHasPrefix(*i.SvgHasPrefix))
	}
	if i.SvgHasSuffix != nil {
		predicates = append(predicates, item.SvgHasSuffix(*i.SvgHasSuffix))
	}
	if i.SvgIsNil {
		predicates = append(predicates, item.SvgIsNil())
	}
	if i.SvgNotNil {
		predicates = append(predicates, item.SvgNotNil())
	}
	if i.SvgEqualFold != nil {
		predicates = append(predicates, item.SvgEqualFold(*i.SvgEqualFold))
	}
	if i.SvgContainsFold != nil {
		predicates = append(predicates, item.SvgContainsFold(*i.SvgContainsFold))
	}
	if i.BestAskPriceEth != nil {
		predicates = append(predicates, item.BestAskPriceEthEQ(*i.BestAskPriceEth))
	}
	if i.BestAskPriceEthNEQ != nil {
		predicates = append(predicates, item.BestAskPriceEthNEQ(*i.BestAskPriceEthNEQ))
	}
	if len(i.BestAskPriceEthIn) > 0 {
		predicates = append(predicates, item.BestAskPriceEthIn(i.BestAskPriceEthIn...))
	}
	if len(i.BestAskPriceEthNotIn) > 0 {
		predicates = append(predicates, item.BestAskPriceEthNotIn(i.BestAskPriceEthNotIn...))
	}
	if i.BestAskPriceEthGT != nil {
		predicates = append(predicates, item.BestAskPriceEthGT(*i.BestAskPriceEthGT))
	}
	if i.BestAskPriceEthGTE != nil {
		predicates = append(predicates, item.BestAskPriceEthGTE(*i.BestAskPriceEthGTE))
	}
	if i.BestAskPriceEthLT != nil {
		predicates = append(predicates, item.BestAskPriceEthLT(*i.BestAskPriceEthLT))
	}
	if i.BestAskPriceEthLTE != nil {
		predicates = append(predicates, item.BestAskPriceEthLTE(*i.BestAskPriceEthLTE))
	}
	if i.BestAskPriceEthIsNil {
		predicates = append(predicates, item.BestAskPriceEthIsNil())
	}
	if i.BestAskPriceEthNotNil {
		predicates = append(predicates, item.BestAskPriceEthNotNil())
	}

	if i.HasWallets != nil {
		p := item.HasWallets()
		if !*i.HasWallets {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletsWith) > 0 {
		with := make([]predicate.WalletItems, 0, len(i.HasWalletsWith))
		for _, w := range i.HasWalletsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWalletsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasWalletsWith(with...))
	}
	if i.HasDopes != nil {
		p := item.HasDopes()
		if !*i.HasDopes {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopesWith))
		for _, w := range i.HasDopesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDopesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasDopesWith(with...))
	}
	if i.HasHustlerWeapons != nil {
		p := item.HasHustlerWeapons()
		if !*i.HasHustlerWeapons {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWeaponsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWeaponsWith))
		for _, w := range i.HasHustlerWeaponsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerWeaponsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerWeaponsWith(with...))
	}
	if i.HasHustlerClothes != nil {
		p := item.HasHustlerClothes()
		if !*i.HasHustlerClothes {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerClothesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerClothesWith))
		for _, w := range i.HasHustlerClothesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerClothesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerClothesWith(with...))
	}
	if i.HasHustlerVehicles != nil {
		p := item.HasHustlerVehicles()
		if !*i.HasHustlerVehicles {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerVehiclesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerVehiclesWith))
		for _, w := range i.HasHustlerVehiclesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerVehiclesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerVehiclesWith(with...))
	}
	if i.HasHustlerWaists != nil {
		p := item.HasHustlerWaists()
		if !*i.HasHustlerWaists {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWaistsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWaistsWith))
		for _, w := range i.HasHustlerWaistsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerWaistsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerWaistsWith(with...))
	}
	if i.HasHustlerFeet != nil {
		p := item.HasHustlerFeet()
		if !*i.HasHustlerFeet {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerFeetWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerFeetWith))
		for _, w := range i.HasHustlerFeetWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerFeetWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerFeetWith(with...))
	}
	if i.HasHustlerHands != nil {
		p := item.HasHustlerHands()
		if !*i.HasHustlerHands {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerHandsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerHandsWith))
		for _, w := range i.HasHustlerHandsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerHandsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerHandsWith(with...))
	}
	if i.HasHustlerDrugs != nil {
		p := item.HasHustlerDrugs()
		if !*i.HasHustlerDrugs {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerDrugsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerDrugsWith))
		for _, w := range i.HasHustlerDrugsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerDrugsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerDrugsWith(with...))
	}
	if i.HasHustlerNecks != nil {
		p := item.HasHustlerNecks()
		if !*i.HasHustlerNecks {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerNecksWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerNecksWith))
		for _, w := range i.HasHustlerNecksWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerNecksWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerNecksWith(with...))
	}
	if i.HasHustlerRings != nil {
		p := item.HasHustlerRings()
		if !*i.HasHustlerRings {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerRingsWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerRingsWith))
		for _, w := range i.HasHustlerRingsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerRingsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerRingsWith(with...))
	}
	if i.HasHustlerAccessories != nil {
		p := item.HasHustlerAccessories()
		if !*i.HasHustlerAccessories {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerAccessoriesWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerAccessoriesWith))
		for _, w := range i.HasHustlerAccessoriesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerAccessoriesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasHustlerAccessoriesWith(with...))
	}
	if i.HasBase != nil {
		p := item.HasBase()
		if !*i.HasBase {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBaseWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasBaseWith))
		for _, w := range i.HasBaseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBaseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasBaseWith(with...))
	}
	if i.HasDerivative != nil {
		p := item.HasDerivative()
		if !*i.HasDerivative {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDerivativeWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasDerivativeWith))
		for _, w := range i.HasDerivativeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDerivativeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasDerivativeWith(with...))
	}
	if i.HasIndex != nil {
		p := item.HasIndex()
		if !*i.HasIndex {
			p = item.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIndexWith) > 0 {
		with := make([]predicate.Search, 0, len(i.HasIndexWith))
		for _, w := range i.HasIndexWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIndexWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, item.HasIndexWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return item.And(predicates...), nil
	}
}

// SearchWhereInput represents a where input for filtering Search queries.
type SearchWhereInput struct {
	Predicates []predicate.Search  `json:"-"`
	Not        *SearchWhereInput   `json:"not,omitempty"`
	Or         []*SearchWhereInput `json:"or,omitempty"`
	And        []*SearchWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "type" field predicates.
	Type      *search.Type  `json:"type,omitempty"`
	TypeNEQ   *search.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []search.Type `json:"typeIn,omitempty"`
	TypeNotIn []search.Type `json:"typeNotIn,omitempty"`

	// "greatness" field predicates.
	Greatness       *int  `json:"greatness,omitempty"`
	GreatnessNEQ    *int  `json:"greatnessNEQ,omitempty"`
	GreatnessIn     []int `json:"greatnessIn,omitempty"`
	GreatnessNotIn  []int `json:"greatnessNotIn,omitempty"`
	GreatnessGT     *int  `json:"greatnessGT,omitempty"`
	GreatnessGTE    *int  `json:"greatnessGTE,omitempty"`
	GreatnessLT     *int  `json:"greatnessLT,omitempty"`
	GreatnessLTE    *int  `json:"greatnessLTE,omitempty"`
	GreatnessIsNil  bool  `json:"greatnessIsNil,omitempty"`
	GreatnessNotNil bool  `json:"greatnessNotNil,omitempty"`

	// "claimed" field predicates.
	Claimed    *bool `json:"claimed,omitempty"`
	ClaimedNEQ *bool `json:"claimedNEQ,omitempty"`

	// "opened" field predicates.
	Opened    *bool `json:"opened,omitempty"`
	OpenedNEQ *bool `json:"openedNEQ,omitempty"`

	// "banned" field predicates.
	Banned    *bool `json:"banned,omitempty"`
	BannedNEQ *bool `json:"bannedNEQ,omitempty"`

	// "sale_price" field predicates.
	SalePrice       *float64  `json:"salePrice,omitempty"`
	SalePriceNEQ    *float64  `json:"salePriceNEQ,omitempty"`
	SalePriceIn     []float64 `json:"salePriceIn,omitempty"`
	SalePriceNotIn  []float64 `json:"salePriceNotIn,omitempty"`
	SalePriceGT     *float64  `json:"salePriceGT,omitempty"`
	SalePriceGTE    *float64  `json:"salePriceGTE,omitempty"`
	SalePriceLT     *float64  `json:"salePriceLT,omitempty"`
	SalePriceLTE    *float64  `json:"salePriceLTE,omitempty"`
	SalePriceIsNil  bool      `json:"salePriceIsNil,omitempty"`
	SalePriceNotNil bool      `json:"salePriceNotNil,omitempty"`

	// "dope" edge predicates.
	HasDope     *bool             `json:"hasDope,omitempty"`
	HasDopeWith []*DopeWhereInput `json:"hasDopeWith,omitempty"`

	// "item" edge predicates.
	HasItem     *bool             `json:"hasItem,omitempty"`
	HasItemWith []*ItemWhereInput `json:"hasItemWith,omitempty"`

	// "hustler" edge predicates.
	HasHustler     *bool                `json:"hasHustler,omitempty"`
	HasHustlerWith []*HustlerWhereInput `json:"hasHustlerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SearchWhereInput) AddPredicates(predicates ...predicate.Search) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SearchWhereInput filter on the SearchQuery builder.
func (i *SearchWhereInput) Filter(q *SearchQuery) (*SearchQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySearchWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySearchWhereInput is returned in case the SearchWhereInput is empty.
var ErrEmptySearchWhereInput = errors.New("ent: empty predicate SearchWhereInput")

// P returns a predicate for filtering searches.
// An error is returned if the input is empty or invalid.
func (i *SearchWhereInput) P() (predicate.Search, error) {
	var predicates []predicate.Search
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, search.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Search, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, search.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Search, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, search.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, search.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, search.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, search.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, search.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, search.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, search.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, search.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, search.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, search.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, search.IDContainsFold(*i.IDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, search.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, search.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, search.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, search.TypeNotIn(i.TypeNotIn...))
	}
	if i.Greatness != nil {
		predicates = append(predicates, search.GreatnessEQ(*i.Greatness))
	}
	if i.GreatnessNEQ != nil {
		predicates = append(predicates, search.GreatnessNEQ(*i.GreatnessNEQ))
	}
	if len(i.GreatnessIn) > 0 {
		predicates = append(predicates, search.GreatnessIn(i.GreatnessIn...))
	}
	if len(i.GreatnessNotIn) > 0 {
		predicates = append(predicates, search.GreatnessNotIn(i.GreatnessNotIn...))
	}
	if i.GreatnessGT != nil {
		predicates = append(predicates, search.GreatnessGT(*i.GreatnessGT))
	}
	if i.GreatnessGTE != nil {
		predicates = append(predicates, search.GreatnessGTE(*i.GreatnessGTE))
	}
	if i.GreatnessLT != nil {
		predicates = append(predicates, search.GreatnessLT(*i.GreatnessLT))
	}
	if i.GreatnessLTE != nil {
		predicates = append(predicates, search.GreatnessLTE(*i.GreatnessLTE))
	}
	if i.GreatnessIsNil {
		predicates = append(predicates, search.GreatnessIsNil())
	}
	if i.GreatnessNotNil {
		predicates = append(predicates, search.GreatnessNotNil())
	}
	if i.Claimed != nil {
		predicates = append(predicates, search.ClaimedEQ(*i.Claimed))
	}
	if i.ClaimedNEQ != nil {
		predicates = append(predicates, search.ClaimedNEQ(*i.ClaimedNEQ))
	}
	if i.Opened != nil {
		predicates = append(predicates, search.OpenedEQ(*i.Opened))
	}
	if i.OpenedNEQ != nil {
		predicates = append(predicates, search.OpenedNEQ(*i.OpenedNEQ))
	}
	if i.Banned != nil {
		predicates = append(predicates, search.BannedEQ(*i.Banned))
	}
	if i.BannedNEQ != nil {
		predicates = append(predicates, search.BannedNEQ(*i.BannedNEQ))
	}
	if i.SalePrice != nil {
		predicates = append(predicates, search.SalePriceEQ(*i.SalePrice))
	}
	if i.SalePriceNEQ != nil {
		predicates = append(predicates, search.SalePriceNEQ(*i.SalePriceNEQ))
	}
	if len(i.SalePriceIn) > 0 {
		predicates = append(predicates, search.SalePriceIn(i.SalePriceIn...))
	}
	if len(i.SalePriceNotIn) > 0 {
		predicates = append(predicates, search.SalePriceNotIn(i.SalePriceNotIn...))
	}
	if i.SalePriceGT != nil {
		predicates = append(predicates, search.SalePriceGT(*i.SalePriceGT))
	}
	if i.SalePriceGTE != nil {
		predicates = append(predicates, search.SalePriceGTE(*i.SalePriceGTE))
	}
	if i.SalePriceLT != nil {
		predicates = append(predicates, search.SalePriceLT(*i.SalePriceLT))
	}
	if i.SalePriceLTE != nil {
		predicates = append(predicates, search.SalePriceLTE(*i.SalePriceLTE))
	}
	if i.SalePriceIsNil {
		predicates = append(predicates, search.SalePriceIsNil())
	}
	if i.SalePriceNotNil {
		predicates = append(predicates, search.SalePriceNotNil())
	}

	if i.HasDope != nil {
		p := search.HasDope()
		if !*i.HasDope {
			p = search.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopeWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopeWith))
		for _, w := range i.HasDopeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDopeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, search.HasDopeWith(with...))
	}
	if i.HasItem != nil {
		p := search.HasItem()
		if !*i.HasItem {
			p = search.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemWith))
		for _, w := range i.HasItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, search.HasItemWith(with...))
	}
	if i.HasHustler != nil {
		p := search.HasHustler()
		if !*i.HasHustler {
			p = search.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlerWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlerWith))
		for _, w := range i.HasHustlerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, search.HasHustlerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySearchWhereInput
	case 1:
		return predicates[0], nil
	default:
		return search.And(predicates...), nil
	}
}

// SyncStateWhereInput represents a where input for filtering SyncState queries.
type SyncStateWhereInput struct {
	Predicates []predicate.SyncState  `json:"-"`
	Not        *SyncStateWhereInput   `json:"not,omitempty"`
	Or         []*SyncStateWhereInput `json:"or,omitempty"`
	And        []*SyncStateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "contract_name" field predicates.
	ContractName             *string  `json:"contractName,omitempty"`
	ContractNameNEQ          *string  `json:"contractNameNEQ,omitempty"`
	ContractNameIn           []string `json:"contractNameIn,omitempty"`
	ContractNameNotIn        []string `json:"contractNameNotIn,omitempty"`
	ContractNameGT           *string  `json:"contractNameGT,omitempty"`
	ContractNameGTE          *string  `json:"contractNameGTE,omitempty"`
	ContractNameLT           *string  `json:"contractNameLT,omitempty"`
	ContractNameLTE          *string  `json:"contractNameLTE,omitempty"`
	ContractNameContains     *string  `json:"contractNameContains,omitempty"`
	ContractNameHasPrefix    *string  `json:"contractNameHasPrefix,omitempty"`
	ContractNameHasSuffix    *string  `json:"contractNameHasSuffix,omitempty"`
	ContractNameIsNil        bool     `json:"contractNameIsNil,omitempty"`
	ContractNameNotNil       bool     `json:"contractNameNotNil,omitempty"`
	ContractNameEqualFold    *string  `json:"contractNameEqualFold,omitempty"`
	ContractNameContainsFold *string  `json:"contractNameContainsFold,omitempty"`

	// "start_block" field predicates.
	StartBlock      *uint64  `json:"startBlock,omitempty"`
	StartBlockNEQ   *uint64  `json:"startBlockNEQ,omitempty"`
	StartBlockIn    []uint64 `json:"startBlockIn,omitempty"`
	StartBlockNotIn []uint64 `json:"startBlockNotIn,omitempty"`
	StartBlockGT    *uint64  `json:"startBlockGT,omitempty"`
	StartBlockGTE   *uint64  `json:"startBlockGTE,omitempty"`
	StartBlockLT    *uint64  `json:"startBlockLT,omitempty"`
	StartBlockLTE   *uint64  `json:"startBlockLTE,omitempty"`

	// "block_time" field predicates.
	BlockTime       *time.Time  `json:"blockTime,omitempty"`
	BlockTimeNEQ    *time.Time  `json:"blockTimeNEQ,omitempty"`
	BlockTimeIn     []time.Time `json:"blockTimeIn,omitempty"`
	BlockTimeNotIn  []time.Time `json:"blockTimeNotIn,omitempty"`
	BlockTimeGT     *time.Time  `json:"blockTimeGT,omitempty"`
	BlockTimeGTE    *time.Time  `json:"blockTimeGTE,omitempty"`
	BlockTimeLT     *time.Time  `json:"blockTimeLT,omitempty"`
	BlockTimeLTE    *time.Time  `json:"blockTimeLTE,omitempty"`
	BlockTimeIsNil  bool        `json:"blockTimeIsNil,omitempty"`
	BlockTimeNotNil bool        `json:"blockTimeNotNil,omitempty"`

	// "last_synced_at" field predicates.
	LastSyncedAt       *time.Time  `json:"lastSyncedAt,omitempty"`
	LastSyncedAtNEQ    *time.Time  `json:"lastSyncedAtNEQ,omitempty"`
	LastSyncedAtIn     []time.Time `json:"lastSyncedAtIn,omitempty"`
	LastSyncedAtNotIn  []time.Time `json:"lastSyncedAtNotIn,omitempty"`
	LastSyncedAtGT     *time.Time  `json:"lastSyncedAtGT,omitempty"`
	LastSyncedAtGTE    *time.Time  `json:"lastSyncedAtGTE,omitempty"`
	LastSyncedAtLT     *time.Time  `json:"lastSyncedAtLT,omitempty"`
	LastSyncedAtLTE    *time.Time  `json:"lastSyncedAtLTE,omitempty"`
	LastSyncedAtIsNil  bool        `json:"lastSyncedAtIsNil,omitempty"`
	LastSyncedAtNotNil bool        `json:"lastSyncedAtNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SyncStateWhereInput) AddPredicates(predicates ...predicate.SyncState) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SyncStateWhereInput filter on the SyncStateQuery builder.
func (i *SyncStateWhereInput) Filter(q *SyncStateQuery) (*SyncStateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySyncStateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySyncStateWhereInput is returned in case the SyncStateWhereInput is empty.
var ErrEmptySyncStateWhereInput = errors.New("ent: empty predicate SyncStateWhereInput")

// P returns a predicate for filtering syncstates.
// An error is returned if the input is empty or invalid.
func (i *SyncStateWhereInput) P() (predicate.SyncState, error) {
	var predicates []predicate.SyncState
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, syncstate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SyncState, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, syncstate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SyncState, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, syncstate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, syncstate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, syncstate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, syncstate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, syncstate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, syncstate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, syncstate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, syncstate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, syncstate.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, syncstate.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, syncstate.IDContainsFold(*i.IDContainsFold))
	}
	if i.ContractName != nil {
		predicates = append(predicates, syncstate.ContractNameEQ(*i.ContractName))
	}
	if i.ContractNameNEQ != nil {
		predicates = append(predicates, syncstate.ContractNameNEQ(*i.ContractNameNEQ))
	}
	if len(i.ContractNameIn) > 0 {
		predicates = append(predicates, syncstate.ContractNameIn(i.ContractNameIn...))
	}
	if len(i.ContractNameNotIn) > 0 {
		predicates = append(predicates, syncstate.ContractNameNotIn(i.ContractNameNotIn...))
	}
	if i.ContractNameGT != nil {
		predicates = append(predicates, syncstate.ContractNameGT(*i.ContractNameGT))
	}
	if i.ContractNameGTE != nil {
		predicates = append(predicates, syncstate.ContractNameGTE(*i.ContractNameGTE))
	}
	if i.ContractNameLT != nil {
		predicates = append(predicates, syncstate.ContractNameLT(*i.ContractNameLT))
	}
	if i.ContractNameLTE != nil {
		predicates = append(predicates, syncstate.ContractNameLTE(*i.ContractNameLTE))
	}
	if i.ContractNameContains != nil {
		predicates = append(predicates, syncstate.ContractNameContains(*i.ContractNameContains))
	}
	if i.ContractNameHasPrefix != nil {
		predicates = append(predicates, syncstate.ContractNameHasPrefix(*i.ContractNameHasPrefix))
	}
	if i.ContractNameHasSuffix != nil {
		predicates = append(predicates, syncstate.ContractNameHasSuffix(*i.ContractNameHasSuffix))
	}
	if i.ContractNameIsNil {
		predicates = append(predicates, syncstate.ContractNameIsNil())
	}
	if i.ContractNameNotNil {
		predicates = append(predicates, syncstate.ContractNameNotNil())
	}
	if i.ContractNameEqualFold != nil {
		predicates = append(predicates, syncstate.ContractNameEqualFold(*i.ContractNameEqualFold))
	}
	if i.ContractNameContainsFold != nil {
		predicates = append(predicates, syncstate.ContractNameContainsFold(*i.ContractNameContainsFold))
	}
	if i.StartBlock != nil {
		predicates = append(predicates, syncstate.StartBlockEQ(*i.StartBlock))
	}
	if i.StartBlockNEQ != nil {
		predicates = append(predicates, syncstate.StartBlockNEQ(*i.StartBlockNEQ))
	}
	if len(i.StartBlockIn) > 0 {
		predicates = append(predicates, syncstate.StartBlockIn(i.StartBlockIn...))
	}
	if len(i.StartBlockNotIn) > 0 {
		predicates = append(predicates, syncstate.StartBlockNotIn(i.StartBlockNotIn...))
	}
	if i.StartBlockGT != nil {
		predicates = append(predicates, syncstate.StartBlockGT(*i.StartBlockGT))
	}
	if i.StartBlockGTE != nil {
		predicates = append(predicates, syncstate.StartBlockGTE(*i.StartBlockGTE))
	}
	if i.StartBlockLT != nil {
		predicates = append(predicates, syncstate.StartBlockLT(*i.StartBlockLT))
	}
	if i.StartBlockLTE != nil {
		predicates = append(predicates, syncstate.StartBlockLTE(*i.StartBlockLTE))
	}
	if i.BlockTime != nil {
		predicates = append(predicates, syncstate.BlockTimeEQ(*i.BlockTime))
	}
	if i.BlockTimeNEQ != nil {
		predicates = append(predicates, syncstate.BlockTimeNEQ(*i.BlockTimeNEQ))
	}
	if len(i.BlockTimeIn) > 0 {
		predicates = append(predicates, syncstate.BlockTimeIn(i.BlockTimeIn...))
	}
	if len(i.BlockTimeNotIn) > 0 {
		predicates = append(predicates, syncstate.BlockTimeNotIn(i.BlockTimeNotIn...))
	}
	if i.BlockTimeGT != nil {
		predicates = append(predicates, syncstate.BlockTimeGT(*i.BlockTimeGT))
	}
	if i.BlockTimeGTE != nil {
		predicates = append(predicates, syncstate.BlockTimeGTE(*i.BlockTimeGTE))
	}
	if i.BlockTimeLT != nil {
		predicates = append(predicates, syncstate.BlockTimeLT(*i.BlockTimeLT))
	}
	if i.BlockTimeLTE != nil {
		predicates = append(predicates, syncstate.BlockTimeLTE(*i.BlockTimeLTE))
	}
	if i.BlockTimeIsNil {
		predicates = append(predicates, syncstate.BlockTimeIsNil())
	}
	if i.BlockTimeNotNil {
		predicates = append(predicates, syncstate.BlockTimeNotNil())
	}
	if i.LastSyncedAt != nil {
		predicates = append(predicates, syncstate.LastSyncedAtEQ(*i.LastSyncedAt))
	}
	if i.LastSyncedAtNEQ != nil {
		predicates = append(predicates, syncstate.LastSyncedAtNEQ(*i.LastSyncedAtNEQ))
	}
	if len(i.LastSyncedAtIn) > 0 {
		predicates = append(predicates, syncstate.LastSyncedAtIn(i.LastSyncedAtIn...))
	}
	if len(i.LastSyncedAtNotIn) > 0 {
		predicates = append(predicates, syncstate.LastSyncedAtNotIn(i.LastSyncedAtNotIn...))
	}
	if i.LastSyncedAtGT != nil {
		predicates = append(predicates, syncstate.LastSyncedAtGT(*i.LastSyncedAtGT))
	}
	if i.LastSyncedAtGTE != nil {
		predicates = append(predicates, syncstate.LastSyncedAtGTE(*i.LastSyncedAtGTE))
	}
	if i.LastSyncedAtLT != nil {
		predicates = append(predicates, syncstate.LastSyncedAtLT(*i.LastSyncedAtLT))
	}
	if i.LastSyncedAtLTE != nil {
		predicates = append(predicates, syncstate.LastSyncedAtLTE(*i.LastSyncedAtLTE))
	}
	if i.LastSyncedAtIsNil {
		predicates = append(predicates, syncstate.LastSyncedAtIsNil())
	}
	if i.LastSyncedAtNotNil {
		predicates = append(predicates, syncstate.LastSyncedAtNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptySyncStateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return syncstate.And(predicates...), nil
	}
}

// WalletWhereInput represents a where input for filtering Wallet queries.
type WalletWhereInput struct {
	Predicates []predicate.Wallet  `json:"-"`
	Not        *WalletWhereInput   `json:"not,omitempty"`
	Or         []*WalletWhereInput `json:"or,omitempty"`
	And        []*WalletWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "paper" field predicates.
	Paper      *schema.BigInt  `json:"paper,omitempty"`
	PaperNEQ   *schema.BigInt  `json:"paperNEQ,omitempty"`
	PaperIn    []schema.BigInt `json:"paperIn,omitempty"`
	PaperNotIn []schema.BigInt `json:"paperNotIn,omitempty"`
	PaperGT    *schema.BigInt  `json:"paperGT,omitempty"`
	PaperGTE   *schema.BigInt  `json:"paperGTE,omitempty"`
	PaperLT    *schema.BigInt  `json:"paperLT,omitempty"`
	PaperLTE   *schema.BigInt  `json:"paperLTE,omitempty"`

	// "last_set_paper_balance_at" field predicates.
	LastSetPaperBalanceAt       *time.Time  `json:"lastSetPaperBalanceAt,omitempty"`
	LastSetPaperBalanceAtNEQ    *time.Time  `json:"lastSetPaperBalanceAtNEQ,omitempty"`
	LastSetPaperBalanceAtIn     []time.Time `json:"lastSetPaperBalanceAtIn,omitempty"`
	LastSetPaperBalanceAtNotIn  []time.Time `json:"lastSetPaperBalanceAtNotIn,omitempty"`
	LastSetPaperBalanceAtGT     *time.Time  `json:"lastSetPaperBalanceAtGT,omitempty"`
	LastSetPaperBalanceAtGTE    *time.Time  `json:"lastSetPaperBalanceAtGTE,omitempty"`
	LastSetPaperBalanceAtLT     *time.Time  `json:"lastSetPaperBalanceAtLT,omitempty"`
	LastSetPaperBalanceAtLTE    *time.Time  `json:"lastSetPaperBalanceAtLTE,omitempty"`
	LastSetPaperBalanceAtIsNil  bool        `json:"lastSetPaperBalanceAtIsNil,omitempty"`
	LastSetPaperBalanceAtNotNil bool        `json:"lastSetPaperBalanceAtNotNil,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "dopes" edge predicates.
	HasDopes     *bool             `json:"hasDopes,omitempty"`
	HasDopesWith []*DopeWhereInput `json:"hasDopesWith,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                    `json:"hasItems,omitempty"`
	HasItemsWith []*WalletItemsWhereInput `json:"hasItemsWith,omitempty"`

	// "hustlers" edge predicates.
	HasHustlers     *bool                `json:"hasHustlers,omitempty"`
	HasHustlersWith []*HustlerWhereInput `json:"hasHustlersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WalletWhereInput) AddPredicates(predicates ...predicate.Wallet) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WalletWhereInput filter on the WalletQuery builder.
func (i *WalletWhereInput) Filter(q *WalletQuery) (*WalletQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWalletWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWalletWhereInput is returned in case the WalletWhereInput is empty.
var ErrEmptyWalletWhereInput = errors.New("ent: empty predicate WalletWhereInput")

// P returns a predicate for filtering wallets.
// An error is returned if the input is empty or invalid.
func (i *WalletWhereInput) P() (predicate.Wallet, error) {
	var predicates []predicate.Wallet
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, wallet.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Wallet, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, wallet.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Wallet, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, wallet.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, wallet.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, wallet.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, wallet.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, wallet.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, wallet.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, wallet.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, wallet.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, wallet.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, wallet.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, wallet.IDContainsFold(*i.IDContainsFold))
	}
	if i.Paper != nil {
		predicates = append(predicates, wallet.PaperEQ(*i.Paper))
	}
	if i.PaperNEQ != nil {
		predicates = append(predicates, wallet.PaperNEQ(*i.PaperNEQ))
	}
	if len(i.PaperIn) > 0 {
		predicates = append(predicates, wallet.PaperIn(i.PaperIn...))
	}
	if len(i.PaperNotIn) > 0 {
		predicates = append(predicates, wallet.PaperNotIn(i.PaperNotIn...))
	}
	if i.PaperGT != nil {
		predicates = append(predicates, wallet.PaperGT(*i.PaperGT))
	}
	if i.PaperGTE != nil {
		predicates = append(predicates, wallet.PaperGTE(*i.PaperGTE))
	}
	if i.PaperLT != nil {
		predicates = append(predicates, wallet.PaperLT(*i.PaperLT))
	}
	if i.PaperLTE != nil {
		predicates = append(predicates, wallet.PaperLTE(*i.PaperLTE))
	}
	if i.LastSetPaperBalanceAt != nil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtEQ(*i.LastSetPaperBalanceAt))
	}
	if i.LastSetPaperBalanceAtNEQ != nil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtNEQ(*i.LastSetPaperBalanceAtNEQ))
	}
	if len(i.LastSetPaperBalanceAtIn) > 0 {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtIn(i.LastSetPaperBalanceAtIn...))
	}
	if len(i.LastSetPaperBalanceAtNotIn) > 0 {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtNotIn(i.LastSetPaperBalanceAtNotIn...))
	}
	if i.LastSetPaperBalanceAtGT != nil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtGT(*i.LastSetPaperBalanceAtGT))
	}
	if i.LastSetPaperBalanceAtGTE != nil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtGTE(*i.LastSetPaperBalanceAtGTE))
	}
	if i.LastSetPaperBalanceAtLT != nil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtLT(*i.LastSetPaperBalanceAtLT))
	}
	if i.LastSetPaperBalanceAtLTE != nil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtLTE(*i.LastSetPaperBalanceAtLTE))
	}
	if i.LastSetPaperBalanceAtIsNil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtIsNil())
	}
	if i.LastSetPaperBalanceAtNotNil {
		predicates = append(predicates, wallet.LastSetPaperBalanceAtNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, wallet.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, wallet.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, wallet.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, wallet.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, wallet.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, wallet.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, wallet.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, wallet.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasDopes != nil {
		p := wallet.HasDopes()
		if !*i.HasDopes {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDopesWith) > 0 {
		with := make([]predicate.Dope, 0, len(i.HasDopesWith))
		for _, w := range i.HasDopesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDopesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasDopesWith(with...))
	}
	if i.HasItems != nil {
		p := wallet.HasItems()
		if !*i.HasItems {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.WalletItems, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasItemsWith(with...))
	}
	if i.HasHustlers != nil {
		p := wallet.HasHustlers()
		if !*i.HasHustlers {
			p = wallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHustlersWith) > 0 {
		with := make([]predicate.Hustler, 0, len(i.HasHustlersWith))
		for _, w := range i.HasHustlersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHustlersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, wallet.HasHustlersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWalletWhereInput
	case 1:
		return predicates[0], nil
	default:
		return wallet.And(predicates...), nil
	}
}

// WalletItemsWhereInput represents a where input for filtering WalletItems queries.
type WalletItemsWhereInput struct {
	Predicates []predicate.WalletItems  `json:"-"`
	Not        *WalletItemsWhereInput   `json:"not,omitempty"`
	Or         []*WalletItemsWhereInput `json:"or,omitempty"`
	And        []*WalletItemsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "balance" field predicates.
	Balance      *schema.BigInt  `json:"balance,omitempty"`
	BalanceNEQ   *schema.BigInt  `json:"balanceNEQ,omitempty"`
	BalanceIn    []schema.BigInt `json:"balanceIn,omitempty"`
	BalanceNotIn []schema.BigInt `json:"balanceNotIn,omitempty"`
	BalanceGT    *schema.BigInt  `json:"balanceGT,omitempty"`
	BalanceGTE   *schema.BigInt  `json:"balanceGTE,omitempty"`
	BalanceLT    *schema.BigInt  `json:"balanceLT,omitempty"`
	BalanceLTE   *schema.BigInt  `json:"balanceLTE,omitempty"`

	// "wallet" edge predicates.
	HasWallet     *bool               `json:"hasWallet,omitempty"`
	HasWalletWith []*WalletWhereInput `json:"hasWalletWith,omitempty"`

	// "item" edge predicates.
	HasItem     *bool             `json:"hasItem,omitempty"`
	HasItemWith []*ItemWhereInput `json:"hasItemWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WalletItemsWhereInput) AddPredicates(predicates ...predicate.WalletItems) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WalletItemsWhereInput filter on the WalletItemsQuery builder.
func (i *WalletItemsWhereInput) Filter(q *WalletItemsQuery) (*WalletItemsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWalletItemsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWalletItemsWhereInput is returned in case the WalletItemsWhereInput is empty.
var ErrEmptyWalletItemsWhereInput = errors.New("ent: empty predicate WalletItemsWhereInput")

// P returns a predicate for filtering walletitemsslice.
// An error is returned if the input is empty or invalid.
func (i *WalletItemsWhereInput) P() (predicate.WalletItems, error) {
	var predicates []predicate.WalletItems
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, walletitems.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WalletItems, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, walletitems.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WalletItems, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, walletitems.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, walletitems.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, walletitems.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, walletitems.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, walletitems.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, walletitems.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, walletitems.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, walletitems.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, walletitems.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, walletitems.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, walletitems.IDContainsFold(*i.IDContainsFold))
	}
	if i.Balance != nil {
		predicates = append(predicates, walletitems.BalanceEQ(*i.Balance))
	}
	if i.BalanceNEQ != nil {
		predicates = append(predicates, walletitems.BalanceNEQ(*i.BalanceNEQ))
	}
	if len(i.BalanceIn) > 0 {
		predicates = append(predicates, walletitems.BalanceIn(i.BalanceIn...))
	}
	if len(i.BalanceNotIn) > 0 {
		predicates = append(predicates, walletitems.BalanceNotIn(i.BalanceNotIn...))
	}
	if i.BalanceGT != nil {
		predicates = append(predicates, walletitems.BalanceGT(*i.BalanceGT))
	}
	if i.BalanceGTE != nil {
		predicates = append(predicates, walletitems.BalanceGTE(*i.BalanceGTE))
	}
	if i.BalanceLT != nil {
		predicates = append(predicates, walletitems.BalanceLT(*i.BalanceLT))
	}
	if i.BalanceLTE != nil {
		predicates = append(predicates, walletitems.BalanceLTE(*i.BalanceLTE))
	}

	if i.HasWallet != nil {
		p := walletitems.HasWallet()
		if !*i.HasWallet {
			p = walletitems.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWalletWith) > 0 {
		with := make([]predicate.Wallet, 0, len(i.HasWalletWith))
		for _, w := range i.HasWalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, walletitems.HasWalletWith(with...))
	}
	if i.HasItem != nil {
		p := walletitems.HasItem()
		if !*i.HasItem {
			p = walletitems.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemWith) > 0 {
		with := make([]predicate.Item, 0, len(i.HasItemWith))
		for _, w := range i.HasItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, walletitems.HasItemWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWalletItemsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return walletitems.And(predicates...), nil
	}
}
