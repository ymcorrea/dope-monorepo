// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/bodypart"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/dope"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/event"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustleritem"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustlerquest"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/gamehustlerrelation"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/hustler"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/item"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/search"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/syncstate"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/wallet"
	"github.com/dopedao/dope-monorepo/packages/api/internal/ent/walletitems"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// BodyPartEdge is the edge representation of BodyPart.
type BodyPartEdge struct {
	Node   *BodyPart `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// BodyPartConnection is the connection containing edges to BodyPart.
type BodyPartConnection struct {
	Edges      []*BodyPartEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *BodyPartConnection) build(nodes []*BodyPart, pager *bodypartPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BodyPart
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BodyPart {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BodyPart {
			return nodes[i]
		}
	}
	c.Edges = make([]*BodyPartEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BodyPartEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BodyPartPaginateOption enables pagination customization.
type BodyPartPaginateOption func(*bodypartPager) error

// WithBodyPartOrder configures pagination ordering.
func WithBodyPartOrder(order *BodyPartOrder) BodyPartPaginateOption {
	if order == nil {
		order = DefaultBodyPartOrder
	}
	o := *order
	return func(pager *bodypartPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBodyPartOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBodyPartFilter configures pagination filter.
func WithBodyPartFilter(filter func(*BodyPartQuery) (*BodyPartQuery, error)) BodyPartPaginateOption {
	return func(pager *bodypartPager) error {
		if filter == nil {
			return errors.New("BodyPartQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type bodypartPager struct {
	reverse bool
	order   *BodyPartOrder
	filter  func(*BodyPartQuery) (*BodyPartQuery, error)
}

func newBodyPartPager(opts []BodyPartPaginateOption, reverse bool) (*bodypartPager, error) {
	pager := &bodypartPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBodyPartOrder
	}
	return pager, nil
}

func (p *bodypartPager) applyFilter(query *BodyPartQuery) (*BodyPartQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *bodypartPager) toCursor(bp *BodyPart) Cursor {
	return p.order.Field.toCursor(bp)
}

func (p *bodypartPager) applyCursors(query *BodyPartQuery, after, before *Cursor) (*BodyPartQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBodyPartOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *bodypartPager) applyOrder(query *BodyPartQuery) *BodyPartQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBodyPartOrder.Field {
		query = query.Order(DefaultBodyPartOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *bodypartPager) orderExpr(query *BodyPartQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBodyPartOrder.Field {
			b.Comma().Ident(DefaultBodyPartOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BodyPart.
func (bp *BodyPartQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BodyPartPaginateOption,
) (*BodyPartConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBodyPartPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bp, err = pager.applyFilter(bp); err != nil {
		return nil, err
	}
	conn := &BodyPartConnection{Edges: []*BodyPartEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = bp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bp, err = pager.applyCursors(bp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		bp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bp = pager.applyOrder(bp)
	nodes, err := bp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BodyPartOrderField defines the ordering field of BodyPart.
type BodyPartOrderField struct {
	// Value extracts the ordering value from the given BodyPart.
	Value    func(*BodyPart) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) bodypart.OrderOption
	toCursor func(*BodyPart) Cursor
}

// BodyPartOrder defines the ordering of BodyPart.
type BodyPartOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *BodyPartOrderField `json:"field"`
}

// DefaultBodyPartOrder is the default ordering of BodyPart.
var DefaultBodyPartOrder = &BodyPartOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BodyPartOrderField{
		Value: func(bp *BodyPart) (ent.Value, error) {
			return bp.ID, nil
		},
		column: bodypart.FieldID,
		toTerm: bodypart.ByID,
		toCursor: func(bp *BodyPart) Cursor {
			return Cursor{ID: bp.ID}
		},
	},
}

// ToEdge converts BodyPart into BodyPartEdge.
func (bp *BodyPart) ToEdge(order *BodyPartOrder) *BodyPartEdge {
	if order == nil {
		order = DefaultBodyPartOrder
	}
	return &BodyPartEdge{
		Node:   bp,
		Cursor: order.Field.toCursor(bp),
	}
}

// DopeEdge is the edge representation of Dope.
type DopeEdge struct {
	Node   *Dope  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// DopeConnection is the connection containing edges to Dope.
type DopeConnection struct {
	Edges      []*DopeEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *DopeConnection) build(nodes []*Dope, pager *dopePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Dope
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Dope {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Dope {
			return nodes[i]
		}
	}
	c.Edges = make([]*DopeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DopeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DopePaginateOption enables pagination customization.
type DopePaginateOption func(*dopePager) error

// WithDopeOrder configures pagination ordering.
func WithDopeOrder(order *DopeOrder) DopePaginateOption {
	if order == nil {
		order = DefaultDopeOrder
	}
	o := *order
	return func(pager *dopePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDopeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDopeFilter configures pagination filter.
func WithDopeFilter(filter func(*DopeQuery) (*DopeQuery, error)) DopePaginateOption {
	return func(pager *dopePager) error {
		if filter == nil {
			return errors.New("DopeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type dopePager struct {
	reverse bool
	order   *DopeOrder
	filter  func(*DopeQuery) (*DopeQuery, error)
}

func newDopePager(opts []DopePaginateOption, reverse bool) (*dopePager, error) {
	pager := &dopePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDopeOrder
	}
	return pager, nil
}

func (p *dopePager) applyFilter(query *DopeQuery) (*DopeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *dopePager) toCursor(d *Dope) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *dopePager) applyCursors(query *DopeQuery, after, before *Cursor) (*DopeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDopeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *dopePager) applyOrder(query *DopeQuery) *DopeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDopeOrder.Field {
		query = query.Order(DefaultDopeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *dopePager) orderExpr(query *DopeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDopeOrder.Field {
			b.Comma().Ident(DefaultDopeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Dope.
func (d *DopeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DopePaginateOption,
) (*DopeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDopePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DopeConnection{Edges: []*DopeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = d.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DopeOrderFieldRank orders Dope by rank.
	DopeOrderFieldRank = &DopeOrderField{
		Value: func(d *Dope) (ent.Value, error) {
			return d.Rank, nil
		},
		column: dope.FieldRank,
		toTerm: dope.ByRank,
		toCursor: func(d *Dope) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.Rank,
			}
		},
	}
	// DopeOrderFieldOrder orders Dope by order.
	DopeOrderFieldOrder = &DopeOrderField{
		Value: func(d *Dope) (ent.Value, error) {
			return d.Order, nil
		},
		column: dope.FieldOrder,
		toTerm: dope.ByOrder,
		toCursor: func(d *Dope) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.Order,
			}
		},
	}
	// DopeOrderFieldBestAskPriceEth orders Dope by best_ask_price_eth.
	DopeOrderFieldBestAskPriceEth = &DopeOrderField{
		Value: func(d *Dope) (ent.Value, error) {
			return d.BestAskPriceEth, nil
		},
		column: dope.FieldBestAskPriceEth,
		toTerm: dope.ByBestAskPriceEth,
		toCursor: func(d *Dope) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.BestAskPriceEth,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DopeOrderField) String() string {
	var str string
	switch f.column {
	case DopeOrderFieldRank.column:
		str = "RANK"
	case DopeOrderFieldOrder.column:
		str = "ID"
	case DopeOrderFieldBestAskPriceEth.column:
		str = "BEST_ASK_PRICE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DopeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DopeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DopeOrderField %T must be a string", v)
	}
	switch str {
	case "RANK":
		*f = *DopeOrderFieldRank
	case "ID":
		*f = *DopeOrderFieldOrder
	case "BEST_ASK_PRICE":
		*f = *DopeOrderFieldBestAskPriceEth
	default:
		return fmt.Errorf("%s is not a valid DopeOrderField", str)
	}
	return nil
}

// DopeOrderField defines the ordering field of Dope.
type DopeOrderField struct {
	// Value extracts the ordering value from the given Dope.
	Value    func(*Dope) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) dope.OrderOption
	toCursor func(*Dope) Cursor
}

// DopeOrder defines the ordering of Dope.
type DopeOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *DopeOrderField `json:"field"`
}

// DefaultDopeOrder is the default ordering of Dope.
var DefaultDopeOrder = &DopeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DopeOrderField{
		Value: func(d *Dope) (ent.Value, error) {
			return d.ID, nil
		},
		column: dope.FieldID,
		toTerm: dope.ByID,
		toCursor: func(d *Dope) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Dope into DopeEdge.
func (d *Dope) ToEdge(order *DopeOrder) *DopeEdge {
	if order == nil {
		order = DefaultDopeOrder
	}
	return &DopeEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EventConnection) build(nodes []*Event, pager *eventPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}
	c.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order *EventOrder) EventPaginateOption {
	if order == nil {
		order = DefaultEventOrder
	}
	o := *order
	return func(pager *eventPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	reverse bool
	order   *EventOrder
	filter  func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption, reverse bool) (*eventPager, error) {
	pager := &eventPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventOrder
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(e *Event) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) (*EventQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEventOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *eventPager) applyOrder(query *EventQuery) *EventQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEventOrder.Field {
		query = query.Order(DefaultEventOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *eventPager) orderExpr(query *EventQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEventOrder.Field {
			b.Comma().Ident(DefaultEventOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (e *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EventConnection{Edges: []*EventEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	// Value extracts the ordering value from the given Event.
	Value    func(*Event) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) event.OrderOption
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EventOrderField{
		Value: func(e *Event) (ent.Value, error) {
			return e.ID, nil
		},
		column: event.FieldID,
		toTerm: event.ByID,
		toCursor: func(e *Event) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (e *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// GameHustlerEdge is the edge representation of GameHustler.
type GameHustlerEdge struct {
	Node   *GameHustler `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// GameHustlerConnection is the connection containing edges to GameHustler.
type GameHustlerConnection struct {
	Edges      []*GameHustlerEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *GameHustlerConnection) build(nodes []*GameHustler, pager *gamehustlerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GameHustler
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameHustler {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameHustler {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameHustlerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameHustlerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GameHustlerPaginateOption enables pagination customization.
type GameHustlerPaginateOption func(*gamehustlerPager) error

// WithGameHustlerOrder configures pagination ordering.
func WithGameHustlerOrder(order *GameHustlerOrder) GameHustlerPaginateOption {
	if order == nil {
		order = DefaultGameHustlerOrder
	}
	o := *order
	return func(pager *gamehustlerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameHustlerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameHustlerFilter configures pagination filter.
func WithGameHustlerFilter(filter func(*GameHustlerQuery) (*GameHustlerQuery, error)) GameHustlerPaginateOption {
	return func(pager *gamehustlerPager) error {
		if filter == nil {
			return errors.New("GameHustlerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamehustlerPager struct {
	reverse bool
	order   *GameHustlerOrder
	filter  func(*GameHustlerQuery) (*GameHustlerQuery, error)
}

func newGameHustlerPager(opts []GameHustlerPaginateOption, reverse bool) (*gamehustlerPager, error) {
	pager := &gamehustlerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameHustlerOrder
	}
	return pager, nil
}

func (p *gamehustlerPager) applyFilter(query *GameHustlerQuery) (*GameHustlerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamehustlerPager) toCursor(gh *GameHustler) Cursor {
	return p.order.Field.toCursor(gh)
}

func (p *gamehustlerPager) applyCursors(query *GameHustlerQuery, after, before *Cursor) (*GameHustlerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameHustlerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamehustlerPager) applyOrder(query *GameHustlerQuery) *GameHustlerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameHustlerOrder.Field {
		query = query.Order(DefaultGameHustlerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamehustlerPager) orderExpr(query *GameHustlerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameHustlerOrder.Field {
			b.Comma().Ident(DefaultGameHustlerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GameHustler.
func (gh *GameHustlerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameHustlerPaginateOption,
) (*GameHustlerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameHustlerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if gh, err = pager.applyFilter(gh); err != nil {
		return nil, err
	}
	conn := &GameHustlerConnection{Edges: []*GameHustlerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = gh.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if gh, err = pager.applyCursors(gh, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		gh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := gh.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	gh = pager.applyOrder(gh)
	nodes, err := gh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// GameHustlerOrderFieldCreatedAt orders GameHustler by created_at.
	GameHustlerOrderFieldCreatedAt = &GameHustlerOrderField{
		Value: func(gh *GameHustler) (ent.Value, error) {
			return gh.CreatedAt, nil
		},
		column: gamehustler.FieldCreatedAt,
		toTerm: gamehustler.ByCreatedAt,
		toCursor: func(gh *GameHustler) Cursor {
			return Cursor{
				ID:    gh.ID,
				Value: gh.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f GameHustlerOrderField) String() string {
	var str string
	switch f.column {
	case GameHustlerOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f GameHustlerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *GameHustlerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("GameHustlerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *GameHustlerOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid GameHustlerOrderField", str)
	}
	return nil
}

// GameHustlerOrderField defines the ordering field of GameHustler.
type GameHustlerOrderField struct {
	// Value extracts the ordering value from the given GameHustler.
	Value    func(*GameHustler) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) gamehustler.OrderOption
	toCursor func(*GameHustler) Cursor
}

// GameHustlerOrder defines the ordering of GameHustler.
type GameHustlerOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *GameHustlerOrderField `json:"field"`
}

// DefaultGameHustlerOrder is the default ordering of GameHustler.
var DefaultGameHustlerOrder = &GameHustlerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameHustlerOrderField{
		Value: func(gh *GameHustler) (ent.Value, error) {
			return gh.ID, nil
		},
		column: gamehustler.FieldID,
		toTerm: gamehustler.ByID,
		toCursor: func(gh *GameHustler) Cursor {
			return Cursor{ID: gh.ID}
		},
	},
}

// ToEdge converts GameHustler into GameHustlerEdge.
func (gh *GameHustler) ToEdge(order *GameHustlerOrder) *GameHustlerEdge {
	if order == nil {
		order = DefaultGameHustlerOrder
	}
	return &GameHustlerEdge{
		Node:   gh,
		Cursor: order.Field.toCursor(gh),
	}
}

// GameHustlerItemEdge is the edge representation of GameHustlerItem.
type GameHustlerItemEdge struct {
	Node   *GameHustlerItem `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// GameHustlerItemConnection is the connection containing edges to GameHustlerItem.
type GameHustlerItemConnection struct {
	Edges      []*GameHustlerItemEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *GameHustlerItemConnection) build(nodes []*GameHustlerItem, pager *gamehustleritemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GameHustlerItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameHustlerItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameHustlerItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameHustlerItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameHustlerItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GameHustlerItemPaginateOption enables pagination customization.
type GameHustlerItemPaginateOption func(*gamehustleritemPager) error

// WithGameHustlerItemOrder configures pagination ordering.
func WithGameHustlerItemOrder(order *GameHustlerItemOrder) GameHustlerItemPaginateOption {
	if order == nil {
		order = DefaultGameHustlerItemOrder
	}
	o := *order
	return func(pager *gamehustleritemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameHustlerItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameHustlerItemFilter configures pagination filter.
func WithGameHustlerItemFilter(filter func(*GameHustlerItemQuery) (*GameHustlerItemQuery, error)) GameHustlerItemPaginateOption {
	return func(pager *gamehustleritemPager) error {
		if filter == nil {
			return errors.New("GameHustlerItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamehustleritemPager struct {
	reverse bool
	order   *GameHustlerItemOrder
	filter  func(*GameHustlerItemQuery) (*GameHustlerItemQuery, error)
}

func newGameHustlerItemPager(opts []GameHustlerItemPaginateOption, reverse bool) (*gamehustleritemPager, error) {
	pager := &gamehustleritemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameHustlerItemOrder
	}
	return pager, nil
}

func (p *gamehustleritemPager) applyFilter(query *GameHustlerItemQuery) (*GameHustlerItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamehustleritemPager) toCursor(ghi *GameHustlerItem) Cursor {
	return p.order.Field.toCursor(ghi)
}

func (p *gamehustleritemPager) applyCursors(query *GameHustlerItemQuery, after, before *Cursor) (*GameHustlerItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameHustlerItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamehustleritemPager) applyOrder(query *GameHustlerItemQuery) *GameHustlerItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameHustlerItemOrder.Field {
		query = query.Order(DefaultGameHustlerItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamehustleritemPager) orderExpr(query *GameHustlerItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameHustlerItemOrder.Field {
			b.Comma().Ident(DefaultGameHustlerItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GameHustlerItem.
func (ghi *GameHustlerItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameHustlerItemPaginateOption,
) (*GameHustlerItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameHustlerItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ghi, err = pager.applyFilter(ghi); err != nil {
		return nil, err
	}
	conn := &GameHustlerItemConnection{Edges: []*GameHustlerItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ghi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ghi, err = pager.applyCursors(ghi, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ghi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ghi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ghi = pager.applyOrder(ghi)
	nodes, err := ghi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameHustlerItemOrderField defines the ordering field of GameHustlerItem.
type GameHustlerItemOrderField struct {
	// Value extracts the ordering value from the given GameHustlerItem.
	Value    func(*GameHustlerItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) gamehustleritem.OrderOption
	toCursor func(*GameHustlerItem) Cursor
}

// GameHustlerItemOrder defines the ordering of GameHustlerItem.
type GameHustlerItemOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *GameHustlerItemOrderField `json:"field"`
}

// DefaultGameHustlerItemOrder is the default ordering of GameHustlerItem.
var DefaultGameHustlerItemOrder = &GameHustlerItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameHustlerItemOrderField{
		Value: func(ghi *GameHustlerItem) (ent.Value, error) {
			return ghi.ID, nil
		},
		column: gamehustleritem.FieldID,
		toTerm: gamehustleritem.ByID,
		toCursor: func(ghi *GameHustlerItem) Cursor {
			return Cursor{ID: ghi.ID}
		},
	},
}

// ToEdge converts GameHustlerItem into GameHustlerItemEdge.
func (ghi *GameHustlerItem) ToEdge(order *GameHustlerItemOrder) *GameHustlerItemEdge {
	if order == nil {
		order = DefaultGameHustlerItemOrder
	}
	return &GameHustlerItemEdge{
		Node:   ghi,
		Cursor: order.Field.toCursor(ghi),
	}
}

// GameHustlerQuestEdge is the edge representation of GameHustlerQuest.
type GameHustlerQuestEdge struct {
	Node   *GameHustlerQuest `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// GameHustlerQuestConnection is the connection containing edges to GameHustlerQuest.
type GameHustlerQuestConnection struct {
	Edges      []*GameHustlerQuestEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *GameHustlerQuestConnection) build(nodes []*GameHustlerQuest, pager *gamehustlerquestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GameHustlerQuest
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameHustlerQuest {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameHustlerQuest {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameHustlerQuestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameHustlerQuestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GameHustlerQuestPaginateOption enables pagination customization.
type GameHustlerQuestPaginateOption func(*gamehustlerquestPager) error

// WithGameHustlerQuestOrder configures pagination ordering.
func WithGameHustlerQuestOrder(order *GameHustlerQuestOrder) GameHustlerQuestPaginateOption {
	if order == nil {
		order = DefaultGameHustlerQuestOrder
	}
	o := *order
	return func(pager *gamehustlerquestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameHustlerQuestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameHustlerQuestFilter configures pagination filter.
func WithGameHustlerQuestFilter(filter func(*GameHustlerQuestQuery) (*GameHustlerQuestQuery, error)) GameHustlerQuestPaginateOption {
	return func(pager *gamehustlerquestPager) error {
		if filter == nil {
			return errors.New("GameHustlerQuestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamehustlerquestPager struct {
	reverse bool
	order   *GameHustlerQuestOrder
	filter  func(*GameHustlerQuestQuery) (*GameHustlerQuestQuery, error)
}

func newGameHustlerQuestPager(opts []GameHustlerQuestPaginateOption, reverse bool) (*gamehustlerquestPager, error) {
	pager := &gamehustlerquestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameHustlerQuestOrder
	}
	return pager, nil
}

func (p *gamehustlerquestPager) applyFilter(query *GameHustlerQuestQuery) (*GameHustlerQuestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamehustlerquestPager) toCursor(ghq *GameHustlerQuest) Cursor {
	return p.order.Field.toCursor(ghq)
}

func (p *gamehustlerquestPager) applyCursors(query *GameHustlerQuestQuery, after, before *Cursor) (*GameHustlerQuestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameHustlerQuestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamehustlerquestPager) applyOrder(query *GameHustlerQuestQuery) *GameHustlerQuestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameHustlerQuestOrder.Field {
		query = query.Order(DefaultGameHustlerQuestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamehustlerquestPager) orderExpr(query *GameHustlerQuestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameHustlerQuestOrder.Field {
			b.Comma().Ident(DefaultGameHustlerQuestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GameHustlerQuest.
func (ghq *GameHustlerQuestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameHustlerQuestPaginateOption,
) (*GameHustlerQuestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameHustlerQuestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ghq, err = pager.applyFilter(ghq); err != nil {
		return nil, err
	}
	conn := &GameHustlerQuestConnection{Edges: []*GameHustlerQuestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ghq.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ghq, err = pager.applyCursors(ghq, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ghq.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ghq.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ghq = pager.applyOrder(ghq)
	nodes, err := ghq.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameHustlerQuestOrderField defines the ordering field of GameHustlerQuest.
type GameHustlerQuestOrderField struct {
	// Value extracts the ordering value from the given GameHustlerQuest.
	Value    func(*GameHustlerQuest) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) gamehustlerquest.OrderOption
	toCursor func(*GameHustlerQuest) Cursor
}

// GameHustlerQuestOrder defines the ordering of GameHustlerQuest.
type GameHustlerQuestOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *GameHustlerQuestOrderField `json:"field"`
}

// DefaultGameHustlerQuestOrder is the default ordering of GameHustlerQuest.
var DefaultGameHustlerQuestOrder = &GameHustlerQuestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameHustlerQuestOrderField{
		Value: func(ghq *GameHustlerQuest) (ent.Value, error) {
			return ghq.ID, nil
		},
		column: gamehustlerquest.FieldID,
		toTerm: gamehustlerquest.ByID,
		toCursor: func(ghq *GameHustlerQuest) Cursor {
			return Cursor{ID: ghq.ID}
		},
	},
}

// ToEdge converts GameHustlerQuest into GameHustlerQuestEdge.
func (ghq *GameHustlerQuest) ToEdge(order *GameHustlerQuestOrder) *GameHustlerQuestEdge {
	if order == nil {
		order = DefaultGameHustlerQuestOrder
	}
	return &GameHustlerQuestEdge{
		Node:   ghq,
		Cursor: order.Field.toCursor(ghq),
	}
}

// GameHustlerRelationEdge is the edge representation of GameHustlerRelation.
type GameHustlerRelationEdge struct {
	Node   *GameHustlerRelation `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// GameHustlerRelationConnection is the connection containing edges to GameHustlerRelation.
type GameHustlerRelationConnection struct {
	Edges      []*GameHustlerRelationEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *GameHustlerRelationConnection) build(nodes []*GameHustlerRelation, pager *gamehustlerrelationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *GameHustlerRelation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *GameHustlerRelation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *GameHustlerRelation {
			return nodes[i]
		}
	}
	c.Edges = make([]*GameHustlerRelationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &GameHustlerRelationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// GameHustlerRelationPaginateOption enables pagination customization.
type GameHustlerRelationPaginateOption func(*gamehustlerrelationPager) error

// WithGameHustlerRelationOrder configures pagination ordering.
func WithGameHustlerRelationOrder(order *GameHustlerRelationOrder) GameHustlerRelationPaginateOption {
	if order == nil {
		order = DefaultGameHustlerRelationOrder
	}
	o := *order
	return func(pager *gamehustlerrelationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultGameHustlerRelationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithGameHustlerRelationFilter configures pagination filter.
func WithGameHustlerRelationFilter(filter func(*GameHustlerRelationQuery) (*GameHustlerRelationQuery, error)) GameHustlerRelationPaginateOption {
	return func(pager *gamehustlerrelationPager) error {
		if filter == nil {
			return errors.New("GameHustlerRelationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type gamehustlerrelationPager struct {
	reverse bool
	order   *GameHustlerRelationOrder
	filter  func(*GameHustlerRelationQuery) (*GameHustlerRelationQuery, error)
}

func newGameHustlerRelationPager(opts []GameHustlerRelationPaginateOption, reverse bool) (*gamehustlerrelationPager, error) {
	pager := &gamehustlerrelationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultGameHustlerRelationOrder
	}
	return pager, nil
}

func (p *gamehustlerrelationPager) applyFilter(query *GameHustlerRelationQuery) (*GameHustlerRelationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *gamehustlerrelationPager) toCursor(ghr *GameHustlerRelation) Cursor {
	return p.order.Field.toCursor(ghr)
}

func (p *gamehustlerrelationPager) applyCursors(query *GameHustlerRelationQuery, after, before *Cursor) (*GameHustlerRelationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultGameHustlerRelationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *gamehustlerrelationPager) applyOrder(query *GameHustlerRelationQuery) *GameHustlerRelationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultGameHustlerRelationOrder.Field {
		query = query.Order(DefaultGameHustlerRelationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *gamehustlerrelationPager) orderExpr(query *GameHustlerRelationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultGameHustlerRelationOrder.Field {
			b.Comma().Ident(DefaultGameHustlerRelationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to GameHustlerRelation.
func (ghr *GameHustlerRelationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...GameHustlerRelationPaginateOption,
) (*GameHustlerRelationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newGameHustlerRelationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ghr, err = pager.applyFilter(ghr); err != nil {
		return nil, err
	}
	conn := &GameHustlerRelationConnection{Edges: []*GameHustlerRelationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ghr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ghr, err = pager.applyCursors(ghr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ghr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ghr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ghr = pager.applyOrder(ghr)
	nodes, err := ghr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// GameHustlerRelationOrderField defines the ordering field of GameHustlerRelation.
type GameHustlerRelationOrderField struct {
	// Value extracts the ordering value from the given GameHustlerRelation.
	Value    func(*GameHustlerRelation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) gamehustlerrelation.OrderOption
	toCursor func(*GameHustlerRelation) Cursor
}

// GameHustlerRelationOrder defines the ordering of GameHustlerRelation.
type GameHustlerRelationOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *GameHustlerRelationOrderField `json:"field"`
}

// DefaultGameHustlerRelationOrder is the default ordering of GameHustlerRelation.
var DefaultGameHustlerRelationOrder = &GameHustlerRelationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &GameHustlerRelationOrderField{
		Value: func(ghr *GameHustlerRelation) (ent.Value, error) {
			return ghr.ID, nil
		},
		column: gamehustlerrelation.FieldID,
		toTerm: gamehustlerrelation.ByID,
		toCursor: func(ghr *GameHustlerRelation) Cursor {
			return Cursor{ID: ghr.ID}
		},
	},
}

// ToEdge converts GameHustlerRelation into GameHustlerRelationEdge.
func (ghr *GameHustlerRelation) ToEdge(order *GameHustlerRelationOrder) *GameHustlerRelationEdge {
	if order == nil {
		order = DefaultGameHustlerRelationOrder
	}
	return &GameHustlerRelationEdge{
		Node:   ghr,
		Cursor: order.Field.toCursor(ghr),
	}
}

// HustlerEdge is the edge representation of Hustler.
type HustlerEdge struct {
	Node   *Hustler `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// HustlerConnection is the connection containing edges to Hustler.
type HustlerConnection struct {
	Edges      []*HustlerEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *HustlerConnection) build(nodes []*Hustler, pager *hustlerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Hustler
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Hustler {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Hustler {
			return nodes[i]
		}
	}
	c.Edges = make([]*HustlerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HustlerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HustlerPaginateOption enables pagination customization.
type HustlerPaginateOption func(*hustlerPager) error

// WithHustlerOrder configures pagination ordering.
func WithHustlerOrder(order *HustlerOrder) HustlerPaginateOption {
	if order == nil {
		order = DefaultHustlerOrder
	}
	o := *order
	return func(pager *hustlerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHustlerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHustlerFilter configures pagination filter.
func WithHustlerFilter(filter func(*HustlerQuery) (*HustlerQuery, error)) HustlerPaginateOption {
	return func(pager *hustlerPager) error {
		if filter == nil {
			return errors.New("HustlerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hustlerPager struct {
	reverse bool
	order   *HustlerOrder
	filter  func(*HustlerQuery) (*HustlerQuery, error)
}

func newHustlerPager(opts []HustlerPaginateOption, reverse bool) (*hustlerPager, error) {
	pager := &hustlerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHustlerOrder
	}
	return pager, nil
}

func (p *hustlerPager) applyFilter(query *HustlerQuery) (*HustlerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hustlerPager) toCursor(h *Hustler) Cursor {
	return p.order.Field.toCursor(h)
}

func (p *hustlerPager) applyCursors(query *HustlerQuery, after, before *Cursor) (*HustlerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHustlerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hustlerPager) applyOrder(query *HustlerQuery) *HustlerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHustlerOrder.Field {
		query = query.Order(DefaultHustlerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hustlerPager) orderExpr(query *HustlerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHustlerOrder.Field {
			b.Comma().Ident(DefaultHustlerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Hustler.
func (h *HustlerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HustlerPaginateOption,
) (*HustlerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHustlerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if h, err = pager.applyFilter(h); err != nil {
		return nil, err
	}
	conn := &HustlerConnection{Edges: []*HustlerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = h.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if h, err = pager.applyCursors(h, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		h.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := h.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	h = pager.applyOrder(h)
	nodes, err := h.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HustlerOrderFieldCreatedAt orders Hustler by created_at.
	HustlerOrderFieldCreatedAt = &HustlerOrderField{
		Value: func(h *Hustler) (ent.Value, error) {
			return h.CreatedAt, nil
		},
		column: hustler.FieldCreatedAt,
		toTerm: hustler.ByCreatedAt,
		toCursor: func(h *Hustler) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.CreatedAt,
			}
		},
	}
	// HustlerOrderFieldBestAskPriceEth orders Hustler by best_ask_price_eth.
	HustlerOrderFieldBestAskPriceEth = &HustlerOrderField{
		Value: func(h *Hustler) (ent.Value, error) {
			return h.BestAskPriceEth, nil
		},
		column: hustler.FieldBestAskPriceEth,
		toTerm: hustler.ByBestAskPriceEth,
		toCursor: func(h *Hustler) Cursor {
			return Cursor{
				ID:    h.ID,
				Value: h.BestAskPriceEth,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HustlerOrderField) String() string {
	var str string
	switch f.column {
	case HustlerOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	case HustlerOrderFieldBestAskPriceEth.column:
		str = "BEST_ASK_PRICE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HustlerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HustlerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HustlerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *HustlerOrderFieldCreatedAt
	case "BEST_ASK_PRICE":
		*f = *HustlerOrderFieldBestAskPriceEth
	default:
		return fmt.Errorf("%s is not a valid HustlerOrderField", str)
	}
	return nil
}

// HustlerOrderField defines the ordering field of Hustler.
type HustlerOrderField struct {
	// Value extracts the ordering value from the given Hustler.
	Value    func(*Hustler) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hustler.OrderOption
	toCursor func(*Hustler) Cursor
}

// HustlerOrder defines the ordering of Hustler.
type HustlerOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *HustlerOrderField `json:"field"`
}

// DefaultHustlerOrder is the default ordering of Hustler.
var DefaultHustlerOrder = &HustlerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HustlerOrderField{
		Value: func(h *Hustler) (ent.Value, error) {
			return h.ID, nil
		},
		column: hustler.FieldID,
		toTerm: hustler.ByID,
		toCursor: func(h *Hustler) Cursor {
			return Cursor{ID: h.ID}
		},
	},
}

// ToEdge converts Hustler into HustlerEdge.
func (h *Hustler) ToEdge(order *HustlerOrder) *HustlerEdge {
	if order == nil {
		order = DefaultHustlerOrder
	}
	return &HustlerEdge{
		Node:   h,
		Cursor: order.Field.toCursor(h),
	}
}

// ItemEdge is the edge representation of Item.
type ItemEdge struct {
	Node   *Item  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ItemConnection is the connection containing edges to Item.
type ItemConnection struct {
	Edges      []*ItemEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *ItemConnection) build(nodes []*Item, pager *itemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Item
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Item {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Item {
			return nodes[i]
		}
	}
	c.Edges = make([]*ItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ItemPaginateOption enables pagination customization.
type ItemPaginateOption func(*itemPager) error

// WithItemOrder configures pagination ordering.
func WithItemOrder(order *ItemOrder) ItemPaginateOption {
	if order == nil {
		order = DefaultItemOrder
	}
	o := *order
	return func(pager *itemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithItemFilter configures pagination filter.
func WithItemFilter(filter func(*ItemQuery) (*ItemQuery, error)) ItemPaginateOption {
	return func(pager *itemPager) error {
		if filter == nil {
			return errors.New("ItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type itemPager struct {
	reverse bool
	order   *ItemOrder
	filter  func(*ItemQuery) (*ItemQuery, error)
}

func newItemPager(opts []ItemPaginateOption, reverse bool) (*itemPager, error) {
	pager := &itemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultItemOrder
	}
	return pager, nil
}

func (p *itemPager) applyFilter(query *ItemQuery) (*ItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *itemPager) toCursor(i *Item) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *itemPager) applyCursors(query *ItemQuery, after, before *Cursor) (*ItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *itemPager) applyOrder(query *ItemQuery) *ItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultItemOrder.Field {
		query = query.Order(DefaultItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *itemPager) orderExpr(query *ItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultItemOrder.Field {
			b.Comma().Ident(DefaultItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Item.
func (i *ItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ItemPaginateOption,
) (*ItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &ItemConnection{Edges: []*ItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if i, err = pager.applyCursors(i, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	i = pager.applyOrder(i)
	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ItemOrderFieldGreatness orders Item by greatness.
	ItemOrderFieldGreatness = &ItemOrderField{
		Value: func(i *Item) (ent.Value, error) {
			return i.Greatness, nil
		},
		column: item.FieldGreatness,
		toTerm: item.ByGreatness,
		toCursor: func(i *Item) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Greatness,
			}
		},
	}
	// ItemOrderFieldBestAskPriceEth orders Item by best_ask_price_eth.
	ItemOrderFieldBestAskPriceEth = &ItemOrderField{
		Value: func(i *Item) (ent.Value, error) {
			return i.BestAskPriceEth, nil
		},
		column: item.FieldBestAskPriceEth,
		toTerm: item.ByBestAskPriceEth,
		toCursor: func(i *Item) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.BestAskPriceEth,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ItemOrderField) String() string {
	var str string
	switch f.column {
	case ItemOrderFieldGreatness.column:
		str = "GREATNESS"
	case ItemOrderFieldBestAskPriceEth.column:
		str = "BEST_ASK_PRICE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ItemOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ItemOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ItemOrderField %T must be a string", v)
	}
	switch str {
	case "GREATNESS":
		*f = *ItemOrderFieldGreatness
	case "BEST_ASK_PRICE":
		*f = *ItemOrderFieldBestAskPriceEth
	default:
		return fmt.Errorf("%s is not a valid ItemOrderField", str)
	}
	return nil
}

// ItemOrderField defines the ordering field of Item.
type ItemOrderField struct {
	// Value extracts the ordering value from the given Item.
	Value    func(*Item) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) item.OrderOption
	toCursor func(*Item) Cursor
}

// ItemOrder defines the ordering of Item.
type ItemOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *ItemOrderField `json:"field"`
}

// DefaultItemOrder is the default ordering of Item.
var DefaultItemOrder = &ItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ItemOrderField{
		Value: func(i *Item) (ent.Value, error) {
			return i.ID, nil
		},
		column: item.FieldID,
		toTerm: item.ByID,
		toCursor: func(i *Item) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Item into ItemEdge.
func (i *Item) ToEdge(order *ItemOrder) *ItemEdge {
	if order == nil {
		order = DefaultItemOrder
	}
	return &ItemEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// SearchEdge is the edge representation of Search.
type SearchEdge struct {
	Node   *Search `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SearchConnection is the connection containing edges to Search.
type SearchConnection struct {
	Edges      []*SearchEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *SearchConnection) build(nodes []*Search, pager *searchPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Search
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Search {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Search {
			return nodes[i]
		}
	}
	c.Edges = make([]*SearchEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SearchEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SearchPaginateOption enables pagination customization.
type SearchPaginateOption func(*searchPager) error

// WithSearchOrder configures pagination ordering.
func WithSearchOrder(order *SearchOrder) SearchPaginateOption {
	if order == nil {
		order = DefaultSearchOrder
	}
	o := *order
	return func(pager *searchPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSearchOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSearchFilter configures pagination filter.
func WithSearchFilter(filter func(*SearchQuery) (*SearchQuery, error)) SearchPaginateOption {
	return func(pager *searchPager) error {
		if filter == nil {
			return errors.New("SearchQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type searchPager struct {
	reverse bool
	order   *SearchOrder
	filter  func(*SearchQuery) (*SearchQuery, error)
}

func newSearchPager(opts []SearchPaginateOption, reverse bool) (*searchPager, error) {
	pager := &searchPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSearchOrder
	}
	return pager, nil
}

func (p *searchPager) applyFilter(query *SearchQuery) (*SearchQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *searchPager) toCursor(s *Search) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *searchPager) applyCursors(query *SearchQuery, after, before *Cursor) (*SearchQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSearchOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *searchPager) applyOrder(query *SearchQuery) *SearchQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSearchOrder.Field {
		query = query.Order(DefaultSearchOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *searchPager) orderExpr(query *SearchQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSearchOrder.Field {
			b.Comma().Ident(DefaultSearchOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Search.
func (s *SearchQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SearchPaginateOption,
) (*SearchConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSearchPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SearchConnection{Edges: []*SearchEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SearchOrderFieldGreatness orders Search by greatness.
	SearchOrderFieldGreatness = &SearchOrderField{
		Value: func(s *Search) (ent.Value, error) {
			return s.Greatness, nil
		},
		column: search.FieldGreatness,
		toTerm: search.ByGreatness,
		toCursor: func(s *Search) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Greatness,
			}
		},
	}
	// SearchOrderFieldSalePrice orders Search by sale_price.
	SearchOrderFieldSalePrice = &SearchOrderField{
		Value: func(s *Search) (ent.Value, error) {
			return s.SalePrice, nil
		},
		column: search.FieldSalePrice,
		toTerm: search.BySalePrice,
		toCursor: func(s *Search) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.SalePrice,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SearchOrderField) String() string {
	var str string
	switch f.column {
	case SearchOrderFieldGreatness.column:
		str = "GREATNESS"
	case SearchOrderFieldSalePrice.column:
		str = "SALE_PRICE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SearchOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SearchOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SearchOrderField %T must be a string", v)
	}
	switch str {
	case "GREATNESS":
		*f = *SearchOrderFieldGreatness
	case "SALE_PRICE":
		*f = *SearchOrderFieldSalePrice
	default:
		return fmt.Errorf("%s is not a valid SearchOrderField", str)
	}
	return nil
}

// SearchOrderField defines the ordering field of Search.
type SearchOrderField struct {
	// Value extracts the ordering value from the given Search.
	Value    func(*Search) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) search.OrderOption
	toCursor func(*Search) Cursor
}

// SearchOrder defines the ordering of Search.
type SearchOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SearchOrderField `json:"field"`
}

// DefaultSearchOrder is the default ordering of Search.
var DefaultSearchOrder = &SearchOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SearchOrderField{
		Value: func(s *Search) (ent.Value, error) {
			return s.ID, nil
		},
		column: search.FieldID,
		toTerm: search.ByID,
		toCursor: func(s *Search) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Search into SearchEdge.
func (s *Search) ToEdge(order *SearchOrder) *SearchEdge {
	if order == nil {
		order = DefaultSearchOrder
	}
	return &SearchEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SyncStateEdge is the edge representation of SyncState.
type SyncStateEdge struct {
	Node   *SyncState `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// SyncStateConnection is the connection containing edges to SyncState.
type SyncStateConnection struct {
	Edges      []*SyncStateEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *SyncStateConnection) build(nodes []*SyncState, pager *syncstatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SyncState
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SyncState {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SyncState {
			return nodes[i]
		}
	}
	c.Edges = make([]*SyncStateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SyncStateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SyncStatePaginateOption enables pagination customization.
type SyncStatePaginateOption func(*syncstatePager) error

// WithSyncStateOrder configures pagination ordering.
func WithSyncStateOrder(order *SyncStateOrder) SyncStatePaginateOption {
	if order == nil {
		order = DefaultSyncStateOrder
	}
	o := *order
	return func(pager *syncstatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSyncStateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSyncStateFilter configures pagination filter.
func WithSyncStateFilter(filter func(*SyncStateQuery) (*SyncStateQuery, error)) SyncStatePaginateOption {
	return func(pager *syncstatePager) error {
		if filter == nil {
			return errors.New("SyncStateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type syncstatePager struct {
	reverse bool
	order   *SyncStateOrder
	filter  func(*SyncStateQuery) (*SyncStateQuery, error)
}

func newSyncStatePager(opts []SyncStatePaginateOption, reverse bool) (*syncstatePager, error) {
	pager := &syncstatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSyncStateOrder
	}
	return pager, nil
}

func (p *syncstatePager) applyFilter(query *SyncStateQuery) (*SyncStateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *syncstatePager) toCursor(ss *SyncState) Cursor {
	return p.order.Field.toCursor(ss)
}

func (p *syncstatePager) applyCursors(query *SyncStateQuery, after, before *Cursor) (*SyncStateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSyncStateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *syncstatePager) applyOrder(query *SyncStateQuery) *SyncStateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSyncStateOrder.Field {
		query = query.Order(DefaultSyncStateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *syncstatePager) orderExpr(query *SyncStateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSyncStateOrder.Field {
			b.Comma().Ident(DefaultSyncStateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SyncState.
func (ss *SyncStateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SyncStatePaginateOption,
) (*SyncStateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSyncStatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ss, err = pager.applyFilter(ss); err != nil {
		return nil, err
	}
	conn := &SyncStateConnection{Edges: []*SyncStateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ss.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ss, err = pager.applyCursors(ss, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ss.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ss.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ss = pager.applyOrder(ss)
	nodes, err := ss.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SyncStateOrderField defines the ordering field of SyncState.
type SyncStateOrderField struct {
	// Value extracts the ordering value from the given SyncState.
	Value    func(*SyncState) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) syncstate.OrderOption
	toCursor func(*SyncState) Cursor
}

// SyncStateOrder defines the ordering of SyncState.
type SyncStateOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *SyncStateOrderField `json:"field"`
}

// DefaultSyncStateOrder is the default ordering of SyncState.
var DefaultSyncStateOrder = &SyncStateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SyncStateOrderField{
		Value: func(ss *SyncState) (ent.Value, error) {
			return ss.ID, nil
		},
		column: syncstate.FieldID,
		toTerm: syncstate.ByID,
		toCursor: func(ss *SyncState) Cursor {
			return Cursor{ID: ss.ID}
		},
	},
}

// ToEdge converts SyncState into SyncStateEdge.
func (ss *SyncState) ToEdge(order *SyncStateOrder) *SyncStateEdge {
	if order == nil {
		order = DefaultSyncStateOrder
	}
	return &SyncStateEdge{
		Node:   ss,
		Cursor: order.Field.toCursor(ss),
	}
}

// WalletEdge is the edge representation of Wallet.
type WalletEdge struct {
	Node   *Wallet `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// WalletConnection is the connection containing edges to Wallet.
type WalletConnection struct {
	Edges      []*WalletEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *WalletConnection) build(nodes []*Wallet, pager *walletPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Wallet
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Wallet {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Wallet {
			return nodes[i]
		}
	}
	c.Edges = make([]*WalletEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WalletEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WalletPaginateOption enables pagination customization.
type WalletPaginateOption func(*walletPager) error

// WithWalletOrder configures pagination ordering.
func WithWalletOrder(order *WalletOrder) WalletPaginateOption {
	if order == nil {
		order = DefaultWalletOrder
	}
	o := *order
	return func(pager *walletPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWalletOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWalletFilter configures pagination filter.
func WithWalletFilter(filter func(*WalletQuery) (*WalletQuery, error)) WalletPaginateOption {
	return func(pager *walletPager) error {
		if filter == nil {
			return errors.New("WalletQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type walletPager struct {
	reverse bool
	order   *WalletOrder
	filter  func(*WalletQuery) (*WalletQuery, error)
}

func newWalletPager(opts []WalletPaginateOption, reverse bool) (*walletPager, error) {
	pager := &walletPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWalletOrder
	}
	return pager, nil
}

func (p *walletPager) applyFilter(query *WalletQuery) (*WalletQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *walletPager) toCursor(w *Wallet) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *walletPager) applyCursors(query *WalletQuery, after, before *Cursor) (*WalletQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWalletOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *walletPager) applyOrder(query *WalletQuery) *WalletQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWalletOrder.Field {
		query = query.Order(DefaultWalletOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *walletPager) orderExpr(query *WalletQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWalletOrder.Field {
			b.Comma().Ident(DefaultWalletOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Wallet.
func (w *WalletQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WalletPaginateOption,
) (*WalletConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWalletPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WalletConnection{Edges: []*WalletEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WalletOrderFieldCreatedAt orders Wallet by created_at.
	WalletOrderFieldCreatedAt = &WalletOrderField{
		Value: func(w *Wallet) (ent.Value, error) {
			return w.CreatedAt, nil
		},
		column: wallet.FieldCreatedAt,
		toTerm: wallet.ByCreatedAt,
		toCursor: func(w *Wallet) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WalletOrderField) String() string {
	var str string
	switch f.column {
	case WalletOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WalletOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WalletOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WalletOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *WalletOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid WalletOrderField", str)
	}
	return nil
}

// WalletOrderField defines the ordering field of Wallet.
type WalletOrderField struct {
	// Value extracts the ordering value from the given Wallet.
	Value    func(*Wallet) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) wallet.OrderOption
	toCursor func(*Wallet) Cursor
}

// WalletOrder defines the ordering of Wallet.
type WalletOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *WalletOrderField `json:"field"`
}

// DefaultWalletOrder is the default ordering of Wallet.
var DefaultWalletOrder = &WalletOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WalletOrderField{
		Value: func(w *Wallet) (ent.Value, error) {
			return w.ID, nil
		},
		column: wallet.FieldID,
		toTerm: wallet.ByID,
		toCursor: func(w *Wallet) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Wallet into WalletEdge.
func (w *Wallet) ToEdge(order *WalletOrder) *WalletEdge {
	if order == nil {
		order = DefaultWalletOrder
	}
	return &WalletEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WalletItemsEdge is the edge representation of WalletItems.
type WalletItemsEdge struct {
	Node   *WalletItems `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// WalletItemsConnection is the connection containing edges to WalletItems.
type WalletItemsConnection struct {
	Edges      []*WalletItemsEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *WalletItemsConnection) build(nodes []*WalletItems, pager *walletitemsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WalletItems
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WalletItems {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WalletItems {
			return nodes[i]
		}
	}
	c.Edges = make([]*WalletItemsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WalletItemsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WalletItemsPaginateOption enables pagination customization.
type WalletItemsPaginateOption func(*walletitemsPager) error

// WithWalletItemsOrder configures pagination ordering.
func WithWalletItemsOrder(order *WalletItemsOrder) WalletItemsPaginateOption {
	if order == nil {
		order = DefaultWalletItemsOrder
	}
	o := *order
	return func(pager *walletitemsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWalletItemsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWalletItemsFilter configures pagination filter.
func WithWalletItemsFilter(filter func(*WalletItemsQuery) (*WalletItemsQuery, error)) WalletItemsPaginateOption {
	return func(pager *walletitemsPager) error {
		if filter == nil {
			return errors.New("WalletItemsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type walletitemsPager struct {
	reverse bool
	order   *WalletItemsOrder
	filter  func(*WalletItemsQuery) (*WalletItemsQuery, error)
}

func newWalletItemsPager(opts []WalletItemsPaginateOption, reverse bool) (*walletitemsPager, error) {
	pager := &walletitemsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWalletItemsOrder
	}
	return pager, nil
}

func (p *walletitemsPager) applyFilter(query *WalletItemsQuery) (*WalletItemsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *walletitemsPager) toCursor(wi *WalletItems) Cursor {
	return p.order.Field.toCursor(wi)
}

func (p *walletitemsPager) applyCursors(query *WalletItemsQuery, after, before *Cursor) (*WalletItemsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWalletItemsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *walletitemsPager) applyOrder(query *WalletItemsQuery) *WalletItemsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWalletItemsOrder.Field {
		query = query.Order(DefaultWalletItemsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *walletitemsPager) orderExpr(query *WalletItemsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWalletItemsOrder.Field {
			b.Comma().Ident(DefaultWalletItemsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WalletItems.
func (wi *WalletItemsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WalletItemsPaginateOption,
) (*WalletItemsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWalletItemsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wi, err = pager.applyFilter(wi); err != nil {
		return nil, err
	}
	conn := &WalletItemsConnection{Edges: []*WalletItemsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = wi.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wi, err = pager.applyCursors(wi, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		wi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wi.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wi = pager.applyOrder(wi)
	nodes, err := wi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WalletItemsOrderField defines the ordering field of WalletItems.
type WalletItemsOrderField struct {
	// Value extracts the ordering value from the given WalletItems.
	Value    func(*WalletItems) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) walletitems.OrderOption
	toCursor func(*WalletItems) Cursor
}

// WalletItemsOrder defines the ordering of WalletItems.
type WalletItemsOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *WalletItemsOrderField `json:"field"`
}

// DefaultWalletItemsOrder is the default ordering of WalletItems.
var DefaultWalletItemsOrder = &WalletItemsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WalletItemsOrderField{
		Value: func(wi *WalletItems) (ent.Value, error) {
			return wi.ID, nil
		},
		column: walletitems.FieldID,
		toTerm: walletitems.ByID,
		toCursor: func(wi *WalletItems) Cursor {
			return Cursor{ID: wi.ID}
		},
	},
}

// ToEdge converts WalletItems into WalletItemsEdge.
func (wi *WalletItems) ToEdge(order *WalletItemsOrder) *WalletItemsEdge {
	if order == nil {
		order = DefaultWalletItemsOrder
	}
	return &WalletItemsEdge{
		Node:   wi,
		Cursor: order.Field.toCursor(wi),
	}
}
